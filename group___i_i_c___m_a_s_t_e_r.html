<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZ/T2M Flexible Software Package Documentation: I2C Master on IIC (r_iic_master)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZ/T2M Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.1.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___i_i_c___m_a_s_t_e_r.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">I2C Master on IIC (r_iic_master)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf27ed4f61dc662c28564646bd8bf01c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gaf27ed4f61dc662c28564646bd8bf01c3">R_IIC_MASTER_Open</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__cfg__t">i2c_master_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gaf27ed4f61dc662c28564646bd8bf01c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6147f27a169deef934b6f46a0de3652f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#ga6147f27a169deef934b6f46a0de3652f">R_IIC_MASTER_Read</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_dest, uint32_t const bytes, bool const restart)</td></tr>
<tr class="separator:ga6147f27a169deef934b6f46a0de3652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f6d1f0e12c28bf77c27941fbf18359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gad6f6d1f0e12c28bf77c27941fbf18359">R_IIC_MASTER_Write</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, uint8_t *const p_src, uint32_t const bytes, bool const restart)</td></tr>
<tr class="separator:gad6f6d1f0e12c28bf77c27941fbf18359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ef762ddd49f1a137ce9e24c6573059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#ga85ef762ddd49f1a137ce9e24c6573059">R_IIC_MASTER_Abort</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga85ef762ddd49f1a137ce9e24c6573059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71642b0b148f43ffb3e6b8cf2a3c949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gac71642b0b148f43ffb3e6b8cf2a3c949">R_IIC_MASTER_SlaveAddressSet</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, uint32_t const slave, <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga6203bcd8d8127b8fd442a2d33d112940">i2c_master_addr_mode_t</a> const addr_mode)</td></tr>
<tr class="separator:gac71642b0b148f43ffb3e6b8cf2a3c949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga535b73426b62ef08adecfde663160133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#ga535b73426b62ef08adecfde663160133">R_IIC_MASTER_CallbackSet</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__callback__args__t">i2c_master_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__callback__args__t">i2c_master_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga535b73426b62ef08adecfde663160133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88558649a9cf9ccd54b745457227ab7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#ga88558649a9cf9ccd54b745457227ab7c">R_IIC_MASTER_Close</a> (<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga88558649a9cf9ccd54b745457227ab7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff4810180163d8d57963043bc8c1bfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#ga5ff4810180163d8d57963043bc8c1bfa">R_IIC_MASTER_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:ga5ff4810180163d8d57963043bc8c1bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the IIC peripheral on RZ microprocessor. This module implements the <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html">I2C Master Interface</a>. </p>
<h1><a class="anchor" id="r-iic_master-overview"></a>
Overview</h1>
<p>The I2C master on IIC HAL module supports transactions with an I2C Slave device. Callbacks must be provided which are invoked when a transmit or receive operation has completed. The callback argument will contain information about the transaction status, bytes transferred and a pointer to the user defined context.</p>
<h2><a class="anchor" id="r-iic_master-features"></a>
Features</h2>
<ul>
<li>Supports multiple transmission rates<ul>
<li><a class="anchor" id="um_i2c_master_standard_mode_clock_rate_configuration"></a>Standard Mode Support with up to 100-kHz transaction rate.</li>
<li><a class="anchor" id="um_i2c_master_fast_mode_clock_rate_configuration"></a>Fast Mode Support with up to 400-kHz transaction rate.</li>
</ul>
</li>
<li><a class="anchor" id="um_i2c_master_read_from_slave_device"></a>I2C Master Read from a slave device.</li>
<li><a class="anchor" id="um_i2c_master_write_to_slave_device"></a>I2C Master Write to a slave device.</li>
<li><a class="anchor" id="um_i2c_master_abort_i2c_peripheral"></a>Abort any in-progress transactions.</li>
<li><a class="anchor" id="um_i2c_master_change_slave_address_at_run_time"></a>Set the address of the slave device.</li>
<li><a class="anchor" id="um_i2c_master_notify_generated_event_via_callback"></a>Non-blocking behavior is achieved by the use of callbacks.</li>
<li>Additional build-time features<ul>
<li><a class="anchor" id="um_i2c_master_optional_dmac_support_for_data_transfer"></a>Optional (build time) DMAC support for read and write respectively.</li>
<li><a class="anchor" id="um_i2c_master_optional_10_bit_slave_addressing"></a>Optional (build time) support for 10-bit slave addressing.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="r-iic_master-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_iic_master</h2>
The following build time configurations are defined in fsp_cfg/r_iic_master_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>DMAC on Transmission and Reception</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, DMAC instances will be included in the build for both transmission and reception. Even if enabled, DMAC is not used without adding DMAC driver. </td></tr>
<tr>
<td>10-bit slave addressing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>If enabled, the driver will support 10-bit slave addressing mode along with the default 7-bit slave addressing mode. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Connectivity &gt; I2C Master Driver on r_iic_master</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Connectivity &gt; I2C Master Driver on r_iic_master.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_i2c_master0 </td><td>Module name. </td></tr>
<tr>
<td>Channel</td><td>Value must be a non-negative integer</td><td>0 </td><td>Specify the IIC channel. Do not specify the safety channel when using DMAC. </td></tr>
<tr>
<td>Rate</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Standard</li>
<li>
Fast-mode</li>
</ul>
</td><td>Standard </td><td>Select the transfer rate. </td></tr>
<tr>
<td>Rise Time (ns)</td><td>Value must be a non-negative integer</td><td>120 </td><td>Set the rise time (tr) in nanoseconds. </td></tr>
<tr>
<td>Fall Time (ns)</td><td>Value must be a non-negative integer</td><td>120 </td><td>Set the fall time (tf) in nanoseconds. </td></tr>
<tr>
<td>Duty Cycle (%)</td><td>Value must be an integer between 0 and 100</td><td>50 </td><td>Set the SCL duty cycle. </td></tr>
<tr>
<td>Slave Address</td><td>Value must be non-negative</td><td>0x00 </td><td>Specify the slave address. </td></tr>
<tr>
<td>Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
7-Bit</li>
<li>
10-Bit</li>
</ul>
</td><td>7-Bit </td><td>Select the slave address mode. Ensure 10-bit slave addressing is enabled in the configuration to use 10-Bit setting here. </td></tr>
<tr>
<td>Timeout Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Short Mode</li>
<li>
Long Mode</li>
</ul>
</td><td>Short Mode </td><td>Select the timeout mode to detect bus hang. </td></tr>
<tr>
<td>Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function must be provided. This will be called from the interrupt service routine (ISR) upon IIC transaction completion reporting the transaction status. </td></tr>
<tr>
<td>Interrupt Priority Level</td><td>MCU Specific Options</td><td></td><td>Select the interrupt priority level. This is set for TXI, RXI, TEI and ERI interrupts. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-iic_master-clock-configuration"></a>
Clock Configuration</h2>
<p>The IIC peripheral module uses the PCLKL as its clock source. The actual I2C transfer rate will be calculated and set by the tooling depending on the selected transfer rate. If the PCLKL is configured in such a manner that the selected internal rate cannot be achieved, an error will be returned.</p>
<h2><a class="anchor" id="r-iic_master-pin-configuration"></a>
Pin Configuration</h2>
<p>The IIC peripheral module uses pins on the MCU to communicate to external devices. I/O pins must be selected and configured as required by the external device. An I2C channel would consist of two pins - SDA and SCL for data/address and clock respectively.</p>
<h1><a class="anchor" id="r-iic_master-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-iic_master-interrupt-configuration"></a>
Interrupt Configuration</h2>
<ul>
<li>The IIC error (EEI), receive buffer full (RXI), transmit buffer empty (TXI) and transmit end (TEI) interrupts for the selected channel used must be enabled in the properties of the selected device.</li>
<li>Set equal priority levels for all the interrupts mentioned above. Setting the interrupts to different priority levels could result in improper operation.</li>
</ul>
<h2><a class="anchor" id="r-iic_master-rate_calculation"></a>
IIC Master Rate Calculation</h2>
<ul>
<li>The FSP Configuration editor calculates the internal baud-rate setting based on the configured transfer rate. The closest possible baud-rate that can be achieved (less than or equal to the requested rate) at the current PCLKL settings is calculated and used.</li>
<li>If a valid clock rate could not be calculated, an error is returned by the tool.</li>
</ul>
<h2><a class="anchor" id="r-iic_master-enabling-dmac"></a>
Enabling DMAC with the IIC</h2>
<ul>
<li>DMAC transfer support is configurable and is disabled from the build by default. IIC driver provides two DMAC instances for transmission and reception respectively. The DMAC instances can be enabled individually during configuration.</li>
<li>DMAC activation is not available for safety channel.</li>
<li>For further details on DMAC please refer <a class="el" href="group___d_m_a_c.html">Direct Memory Access Controller (r_dmac)</a></li>
</ul>
<h2><a class="anchor" id="r-iic_master-multiple-devices-on-same-bus"></a>
Multiple Devices on the Bus</h2>
<ul>
<li>A single IIC instance can be used to communicate with multiple slave devices on the same channel by using the SlaveAddressSet API.</li>
</ul>
<h2><a class="anchor" id="r-iic_master-multi-master-support"></a>
Multi-Master Support</h2>
<ul>
<li>If multiple masters are connected on the same bus, the I2C Master is capable of detecting bus busy state before initiating the communication.</li>
</ul>
<h2><a class="anchor" id="r-iic_master-restart"></a>
Restart</h2>
<ul>
<li>IIC master can hold the the bus after an I2C transaction by issuing Restart. This will mimic a stop followed by start condition.</li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structiic__master__clock__settings__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#structiic__master__clock__settings__t">iic_master_clock_settings_t</a></td></tr>
<tr class="separator:structiic__master__clock__settings__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structiic__master__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#structiic__master__instance__ctrl__t">iic_master_instance_ctrl_t</a></td></tr>
<tr class="separator:structiic__master__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structiic__master__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#structiic__master__extended__cfg__t">iic_master_extended_cfg_t</a></td></tr>
<tr class="separator:structiic__master__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf8ecd43a76bfa058281bb8b6b3981d3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gaf8ecd43a76bfa058281bb8b6b3981d3f">iic_master_timeout_mode_t</a> </td></tr>
<tr class="separator:gaf8ecd43a76bfa058281bb8b6b3981d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structiic__master__clock__settings__t" id="structiic__master__clock__settings__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structiic__master__clock__settings__t">&#9670;&nbsp;</a></span>iic_master_clock_settings_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct iic_master_clock_settings_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>I2C clock settings </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a213bb6cc78cf57022dbc0b0b2087c0b4"></a>uint8_t</td>
<td class="fieldname">
cks_value</td>
<td class="fielddoc">
Internal Reference Clock Select. </td></tr>
<tr><td class="fieldtype">
<a id="a020f8656c45afc7d90378c7ef26a6955"></a>uint8_t</td>
<td class="fieldname">
brh_value</td>
<td class="fielddoc">
High-level period of SCL clock. </td></tr>
<tr><td class="fieldtype">
<a id="a505dbb8fdf8f4ffac481adab9c08b3fc"></a>uint8_t</td>
<td class="fieldname">
brl_value</td>
<td class="fielddoc">
Low-level period of SCL clock. </td></tr>
</table>

</div>
</div>
<a name="structiic__master__instance__ctrl__t" id="structiic__master__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structiic__master__instance__ctrl__t">&#9670;&nbsp;</a></span>iic_master_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct iic_master_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>I2C control structure. DO NOT INITIALIZE. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:add9086252af4b1102d55d5179c54501e"><td class="memItemLeft" align="right" valign="top"><a id="add9086252af4b1102d55d5179c54501e"></a>
<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__cfg__t">i2c_master_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#add9086252af4b1102d55d5179c54501e">p_cfg</a></td></tr>
<tr class="memdesc:add9086252af4b1102d55d5179c54501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the configuration structure. <br /></td></tr>
<tr class="separator:add9086252af4b1102d55d5179c54501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaff2bd66e14355feb702e9da413dcef"><td class="memItemLeft" align="right" valign="top"><a id="acaff2bd66e14355feb702e9da413dcef"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#acaff2bd66e14355feb702e9da413dcef">slave</a></td></tr>
<tr class="memdesc:acaff2bd66e14355feb702e9da413dcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address of the slave device. <br /></td></tr>
<tr class="separator:acaff2bd66e14355feb702e9da413dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ed29da004060c0b29e55a70d224ca"><td class="memItemLeft" align="right" valign="top"><a id="aa55ed29da004060c0b29e55a70d224ca"></a>
<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga6203bcd8d8127b8fd442a2d33d112940">i2c_master_addr_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#aa55ed29da004060c0b29e55a70d224ca">addr_mode</a></td></tr>
<tr class="memdesc:aa55ed29da004060c0b29e55a70d224ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how slave fields should be interpreted. <br /></td></tr>
<tr class="separator:aa55ed29da004060c0b29e55a70d224ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb5138976e0af300351789792bad289"><td class="memItemLeft" align="right" valign="top"><a id="afcb5138976e0af300351789792bad289"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#afcb5138976e0af300351789792bad289">open</a></td></tr>
<tr class="memdesc:afcb5138976e0af300351789792bad289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to determine if the device is open. <br /></td></tr>
<tr class="separator:afcb5138976e0af300351789792bad289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5089d3a81d0c67663c6aa443c97e0996"><td class="memItemLeft" align="right" valign="top"><a id="a5089d3a81d0c67663c6aa443c97e0996"></a>
R_IIC0_Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a5089d3a81d0c67663c6aa443c97e0996">p_reg</a></td></tr>
<tr class="memdesc:a5089d3a81d0c67663c6aa443c97e0996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base register for this channel. <br /></td></tr>
<tr class="separator:a5089d3a81d0c67663c6aa443c97e0996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1855a6c633eae183b8be6d63a4b7da"><td class="memItemLeft" align="right" valign="top"><a id="a6e1855a6c633eae183b8be6d63a4b7da"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a6e1855a6c633eae183b8be6d63a4b7da">p_buff</a></td></tr>
<tr class="memdesc:a6e1855a6c633eae183b8be6d63a4b7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the data associated with the transfer. <br /></td></tr>
<tr class="separator:a6e1855a6c633eae183b8be6d63a4b7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9589c9227d797247a2789a150d5e57"><td class="memItemLeft" align="right" valign="top"><a id="aae9589c9227d797247a2789a150d5e57"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#aae9589c9227d797247a2789a150d5e57">total</a></td></tr>
<tr class="memdesc:aae9589c9227d797247a2789a150d5e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the total number of data bytes to transfer. <br /></td></tr>
<tr class="separator:aae9589c9227d797247a2789a150d5e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036cc7463235abf542eb066ed59ba07a"><td class="memItemLeft" align="right" valign="top"><a id="a036cc7463235abf542eb066ed59ba07a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a036cc7463235abf542eb066ed59ba07a">remain</a></td></tr>
<tr class="memdesc:a036cc7463235abf542eb066ed59ba07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the remaining data bytes to transfer. <br /></td></tr>
<tr class="separator:a036cc7463235abf542eb066ed59ba07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b87790a7ac9b19f2fe567e13dc89f7"><td class="memItemLeft" align="right" valign="top"><a id="a43b87790a7ac9b19f2fe567e13dc89f7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a43b87790a7ac9b19f2fe567e13dc89f7">loaded</a></td></tr>
<tr class="memdesc:a43b87790a7ac9b19f2fe567e13dc89f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the number of data bytes written to the register. <br /></td></tr>
<tr class="separator:a43b87790a7ac9b19f2fe567e13dc89f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c9e167b14544d769aec2bea6496c36"><td class="memItemLeft" align="right" valign="top"><a id="a32c9e167b14544d769aec2bea6496c36"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a32c9e167b14544d769aec2bea6496c36">addr_low</a></td></tr>
<tr class="memdesc:a32c9e167b14544d769aec2bea6496c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the last address byte to issue. <br /></td></tr>
<tr class="separator:a32c9e167b14544d769aec2bea6496c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44725b855848e982eee89634b4d065cc"><td class="memItemLeft" align="right" valign="top"><a id="a44725b855848e982eee89634b4d065cc"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a44725b855848e982eee89634b4d065cc">addr_high</a></td></tr>
<tr class="memdesc:a44725b855848e982eee89634b4d065cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the first address byte to issue in 10-bit mode. <br /></td></tr>
<tr class="separator:a44725b855848e982eee89634b4d065cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91684e02e8006966f5be1151d8e517fd"><td class="memItemLeft" align="right" valign="top"><a id="a91684e02e8006966f5be1151d8e517fd"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a91684e02e8006966f5be1151d8e517fd">addr_total</a></td></tr>
<tr class="memdesc:a91684e02e8006966f5be1151d8e517fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the total number of address bytes to transfer. <br /></td></tr>
<tr class="separator:a91684e02e8006966f5be1151d8e517fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d14c76f1a445a276f198a4d5c1689b"><td class="memItemLeft" align="right" valign="top"><a id="a49d14c76f1a445a276f198a4d5c1689b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a49d14c76f1a445a276f198a4d5c1689b">addr_remain</a></td></tr>
<tr class="memdesc:a49d14c76f1a445a276f198a4d5c1689b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the remaining address bytes to transfer. <br /></td></tr>
<tr class="separator:a49d14c76f1a445a276f198a4d5c1689b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab677eca1f6932a02db7bbe3e3e2e7d59"><td class="memItemLeft" align="right" valign="top"><a id="ab677eca1f6932a02db7bbe3e3e2e7d59"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#ab677eca1f6932a02db7bbe3e3e2e7d59">addr_loaded</a></td></tr>
<tr class="memdesc:ab677eca1f6932a02db7bbe3e3e2e7d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the number of address bytes written to the register. <br /></td></tr>
<tr class="separator:ab677eca1f6932a02db7bbe3e3e2e7d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c10c0dcf07cd6b8291c1f705d408d"><td class="memItemLeft" align="right" valign="top"><a id="a2f0c10c0dcf07cd6b8291c1f705d408d"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a2f0c10c0dcf07cd6b8291c1f705d408d">read</a></td></tr>
<tr class="memdesc:a2f0c10c0dcf07cd6b8291c1f705d408d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the direction of the data byte transfer. <br /></td></tr>
<tr class="separator:a2f0c10c0dcf07cd6b8291c1f705d408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec3c36566f526165a8534a58207b23f"><td class="memItemLeft" align="right" valign="top"><a id="a5ec3c36566f526165a8534a58207b23f"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a5ec3c36566f526165a8534a58207b23f">restart</a></td></tr>
<tr class="memdesc:a5ec3c36566f526165a8534a58207b23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds whether or not the restart should be issued when done. <br /></td></tr>
<tr class="separator:a5ec3c36566f526165a8534a58207b23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bcf68547e7005b213fecadd525df70"><td class="memItemLeft" align="right" valign="top"><a id="a66bcf68547e7005b213fecadd525df70"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a66bcf68547e7005b213fecadd525df70">err</a></td></tr>
<tr class="memdesc:a66bcf68547e7005b213fecadd525df70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether or not an error occurred during processing. <br /></td></tr>
<tr class="separator:a66bcf68547e7005b213fecadd525df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd56c979a7232ed84133e8198b83aa2f"><td class="memItemLeft" align="right" valign="top"><a id="afd56c979a7232ed84133e8198b83aa2f"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#afd56c979a7232ed84133e8198b83aa2f">restarted</a></td></tr>
<tr class="memdesc:afd56c979a7232ed84133e8198b83aa2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether or not a restart was issued during the previous transfer. <br /></td></tr>
<tr class="separator:afd56c979a7232ed84133e8198b83aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d08efea52b6463c1fd6e59ce67101ea"><td class="memItemLeft" align="right" valign="top"><a id="a1d08efea52b6463c1fd6e59ce67101ea"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a1d08efea52b6463c1fd6e59ce67101ea">dummy_read_completed</a></td></tr>
<tr class="memdesc:a1d08efea52b6463c1fd6e59ce67101ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether the dummy read is performed. <br /></td></tr>
<tr class="separator:a1d08efea52b6463c1fd6e59ce67101ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73911a7ba79b268e105371a4f80e61b3"><td class="memItemLeft" align="right" valign="top"><a id="a73911a7ba79b268e105371a4f80e61b3"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a73911a7ba79b268e105371a4f80e61b3">activation_on_rxi</a></td></tr>
<tr class="memdesc:a73911a7ba79b268e105371a4f80e61b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether the transfer is activated on RXI interrupt. <br /></td></tr>
<tr class="separator:a73911a7ba79b268e105371a4f80e61b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63182e37b4db69f3576650dbdfed6c1f"><td class="memItemLeft" align="right" valign="top"><a id="a63182e37b4db69f3576650dbdfed6c1f"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a63182e37b4db69f3576650dbdfed6c1f">activation_on_txi</a></td></tr>
<tr class="memdesc:a63182e37b4db69f3576650dbdfed6c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether the transfer is activated on TXI interrupt. <br /></td></tr>
<tr class="separator:a63182e37b4db69f3576650dbdfed6c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28be3bc532d9d7b0817221f631939f5d"><td class="memItemLeft" align="right" valign="top"><a id="a28be3bc532d9d7b0817221f631939f5d"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a28be3bc532d9d7b0817221f631939f5d">address_restarted</a></td></tr>
<tr class="memdesc:a28be3bc532d9d7b0817221f631939f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks whether the restart condition is send on 10 bit read. <br /></td></tr>
<tr class="separator:a28be3bc532d9d7b0817221f631939f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f285c33f95af2eada2c1c176e583f"><td class="memItemLeft" align="right" valign="top"><a id="a7e9f285c33f95af2eada2c1c176e583f"></a>
<a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gaf8ecd43a76bfa058281bb8b6b3981d3f">iic_master_timeout_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#a7e9f285c33f95af2eada2c1c176e583f">timeout_mode</a></td></tr>
<tr class="memdesc:a7e9f285c33f95af2eada2c1c176e583f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the timeout mode value. i.e short mode or long mode. <br /></td></tr>
<tr class="separator:a7e9f285c33f95af2eada2c1c176e583f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structiic__master__extended__cfg__t" id="structiic__master__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structiic__master__extended__cfg__t">&#9670;&nbsp;</a></span>iic_master_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct iic_master_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>R_IIC extended configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a25c3fc7a92165e8213ccf8308e1db1aa"></a><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gaf8ecd43a76bfa058281bb8b6b3981d3f">iic_master_timeout_mode_t</a></td>
<td class="fieldname">
timeout_mode</td>
<td class="fielddoc">
Timeout Detection Time Select: Long Mode = 0 and Short Mode = 1. </td></tr>
<tr><td class="fieldtype">
<a id="a3e2c32c0a211b6485aff83502c3c41a2"></a><a class="el" href="group___i_i_c___m_a_s_t_e_r.html#structiic__master__clock__settings__t">iic_master_clock_settings_t</a></td>
<td class="fieldname">
clock_settings</td>
<td class="fielddoc">
I2C Clock settings. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaf8ecd43a76bfa058281bb8b6b3981d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ecd43a76bfa058281bb8b6b3981d3f">&#9670;&nbsp;</a></span>iic_master_timeout_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i_i_c___m_a_s_t_e_r.html#gaf8ecd43a76bfa058281bb8b6b3981d3f">iic_master_timeout_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Timeout mode parameter definition </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf8ecd43a76bfa058281bb8b6b3981d3facc441997b6e18766361457d26227b4bd"></a>IIC_MASTER_TIMEOUT_MODE_LONG&#160;</td><td class="fielddoc"><p>Timeout Detection Time Select: Long Mode -&gt; TMOS = 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf8ecd43a76bfa058281bb8b6b3981d3fa4afacd0b267f604d06e2b83891c0e577"></a>IIC_MASTER_TIMEOUT_MODE_SHORT&#160;</td><td class="fielddoc"><p>Timeout Detection Time Select: Short Mode -&gt; TMOS = 1. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf27ed4f61dc662c28564646bd8bf01c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27ed4f61dc662c28564646bd8bf01c3">&#9670;&nbsp;</a></span>R_IIC_MASTER_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__cfg__t">i2c_master_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the I2C device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Requested clock rate was set exactly. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>Channel is not available on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Invalid input parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Parameter check failure due to one or more reasons below:<ol type="1">
<li>p_api_ctrl or p_cfg is NULL.</li>
<li>extended parameter is NULL.</li>
<li>Callback parameter is NULL.</li>
<li>Invalid IRQ number assigned </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6147f27a169deef934b6f46a0de3652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6147f27a169deef934b6f46a0de3652f">&#9670;&nbsp;</a></span>R_IIC_MASTER_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a read from the I2C device. The caller will be notified when the operation has completed (successfully) by an I2C_MASTER_EVENT_RX_COMPLETE in the callback.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Function executed without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl, p_dest or bytes is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Bus busy condition. Another transfer was in progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_IIC_MASTER_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6f6d1f0e12c28bf77c27941fbf18359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f6d1f0e12c28bf77c27941fbf18359">&#9670;&nbsp;</a></span>R_IIC_MASTER_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>restart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a write to the I2C device. The caller will be notified when the operation has completed (successfully) by an I2C_MASTER_EVENT_TX_COMPLETE in the callback.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Function executed without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl or p_src is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Bus busy condition. Another transfer was in progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_IIC_MASTER_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85ef762ddd49f1a137ce9e24c6573059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ef762ddd49f1a137ce9e24c6573059">&#9670;&nbsp;</a></span>R_IIC_MASTER_Abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely aborts any in-progress transfer and forces the IIC peripheral into ready state.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel was reset successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_IIC_MASTER_Open to initialize the control block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A callback will not be invoked in case an in-progress transfer gets aborted by calling this API. </dd></dl>

</div>
</div>
<a id="gac71642b0b148f43ffb3e6b8cf2a3c949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71642b0b148f43ffb3e6b8cf2a3c949">&#9670;&nbsp;</a></span>R_IIC_MASTER_SlaveAddressSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_SlaveAddressSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga6203bcd8d8127b8fd442a2d33d112940">i2c_master_addr_mode_t</a> const&#160;</td>
          <td class="paramname"><em>addr_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets address and addressing mode of the slave device. This function is used to set the device address and addressing mode of the slave without reconfiguring the entire bus.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Address of the slave is set correctly. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Pointer to control structure is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Another transfer was in-progress. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_IIC_MASTER_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga535b73426b62ef08adecfde663160133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga535b73426b62ef08adecfde663160133">&#9670;&nbsp;</a></span>R_IIC_MASTER_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__callback__args__t">i2c_master_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#structi2c__master__callback__args__t">i2c_master_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#a1a0c2ac15d2c2eb6a50baed682498620">i2c_master_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88558649a9cf9ccd54b745457227ab7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88558649a9cf9ccd54b745457227ab7c">&#9670;&nbsp;</a></span>R_IIC_MASTER_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___m_a_s_t_e_r___a_p_i.html#ga87f5194ba16044322815db81dc442138">i2c_master_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the I2C device. May power down IIC peripheral. This function will safely terminate any in-progress I2C transfers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Device closed without issue. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_api_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_IIC_MASTER_Open to initialize the control block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A callback will not be invoked in case an in-progress transfer gets aborted by calling this API. </dd></dl>

</div>
</div>
<a id="ga5ff4810180163d8d57963043bc8c1bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff4810180163d8d57963043bc8c1bfa">&#9670;&nbsp;</a></span>R_IIC_MASTER_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IIC_MASTER_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets version information and stores it in the provided version structure.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful version get. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_version is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.1.0 User's Manual Copyright © (2022) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
