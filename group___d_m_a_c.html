<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZT Flexible Software Package Documentation: Direct Memory Access Controller (r_dmac)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZT Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___d_m_a_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Direct Memory Access Controller (r_dmac)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___t_r_a_n_s_f_e_r___m_o_d_u_l_e_s.html">Transfer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7e5fda31237adb83fee8cf5a42daed48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga7e5fda31237adb83fee8cf5a42daed48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e932ab91dd283665438d06813d162bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga6e932ab91dd283665438d06813d162bf">R_DMAC_Reconfigure</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *p_info)</td></tr>
<tr class="separator:ga6e932ab91dd283665438d06813d162bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5dc2be3a25f6b4c9582915ec6445c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gaca5dc2be3a25f6b4c9582915ec6445c0">R_DMAC_Reset</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void const *volatile p_src, void *volatile p_dest, uint16_t const num_transfers)</td></tr>
<tr class="separator:gaca5dc2be3a25f6b4c9582915ec6445c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047024929094fd5306c6cd2aeb17ecb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a> mode)</td></tr>
<tr class="separator:ga047024929094fd5306c6cd2aeb17ecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae68c517e00cf0817dff0f96b651f7dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gaae68c517e00cf0817dff0f96b651f7dd">R_DMAC_SoftwareStop</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaae68c517e00cf0817dff0f96b651f7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d860f51f5aa6e25d3820dc2262aa15a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga8d860f51f5aa6e25d3820dc2262aa15a">R_DMAC_Enable</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga8d860f51f5aa6e25d3820dc2262aa15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14a3958fdb85b53cae9b11e8735b578d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga14a3958fdb85b53cae9b11e8735b578d">R_DMAC_Disable</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga14a3958fdb85b53cae9b11e8735b578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45893222e0710e310ae398c14ef47174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga45893222e0710e310ae398c14ef47174">R_DMAC_InfoGet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const p_info)</td></tr>
<tr class="separator:ga45893222e0710e310ae398c14ef47174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5aef880361cff7f61b88ecf418c1de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gabc5aef880361cff7f61b88ecf418c1de">R_DMAC_Close</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gabc5aef880361cff7f61b88ecf418c1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae415cc72455bc260ad1c5289e3308240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gae415cc72455bc260ad1c5289e3308240">R_DMAC_Reload</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void const *p_src, void *p_dest, uint32_t const num_transfers)</td></tr>
<tr class="separator:gae415cc72455bc260ad1c5289e3308240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53ef1808423dabba647a3a2eed5a4b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga53ef1808423dabba647a3a2eed5a4b02">R_DMAC_CallbackSet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga53ef1808423dabba647a3a2eed5a4b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37103a34f8b4bfb41d5adcd30ea8e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gab37103a34f8b4bfb41d5adcd30ea8e95">R_DMAC_LinkDescriptorSet</a> (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const p_ctrl, <a class="el" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> *p_descriptor)</td></tr>
<tr class="separator:gab37103a34f8b4bfb41d5adcd30ea8e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the DMAC peripheral on RZ microprocessor. This module implements the <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html">Transfer Interface</a>. </p>
<h1><a class="anchor" id="r-dmac-overview"></a>
Overview</h1>
<p>The Direct Memory Access Controller (DMAC) transfers data from one memory location to another without using the CPU.</p>
<h2><a class="anchor" id="r-dmac-features"></a>
Features</h2>
<ul>
<li>Supports multiple transfer modes<ul>
<li>Normal transfer</li>
<li>Block transfer</li>
</ul>
</li>
<li>Support Register mode and Link mode</li>
<li>Supports Next0 Register set and Next1 Register set<a class="anchor" id="um_dmac_next1_register_set"></a></li>
<li>Address increment, fixed<a class="anchor" id="um_transfer_address_inc_dec_fixed"></a></li>
<li>Triggered by various events<ul>
<li>Some exceptions apply, see the Event table in the Event Numbers section of the Interrupt Controller Unit chapter of the hardware manual</li>
</ul>
</li>
<li>Supports 1, 2, 4, 8, 16, 32, 64(DMAC0 only) byte data units<a class="anchor" id="um_transfer_unit"></a><a class="anchor" id="um_dmac_src_unit"></a><a class="anchor" id="um_dmac_dest_unit"></a></li>
<li>Configurable DMA transfer activation request source, detection method of DMA request signal and DACK output mode<a class="anchor" id="um_dmac_activation_request_source_set"></a><a class="anchor" id="um_dmac_request_signal_set"></a><a class="anchor" id="um_dmac_dack_output_mode_set"></a></li>
<li>Configurable DMA transfer interval<a class="anchor" id="um_dmac_transfer_interval_set"></a></li>
<li>Configurable DMAC channel priority<a class="anchor" id="um_dmac_channel_priority_set"></a> </li>
</ul>
<h1><a class="anchor" id="r-dmac-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_transfer_normal_mode"></a><a class="anchor" id="um_transfer_block_mode"></a><a class="anchor" id="um_transfer_activation_source"></a><a class="anchor" id="um_transfer_block_repeat_area"></a><a class="anchor" id="um_dmac_end_interrupt"></a> <h2>Build Time Configurations for r_dmac</h2>
The following build time configurations are defined in fsp_cfg/r_dmac_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Channel Priority Control &gt; Unit 0 &gt; Arbitration method (Channel 0-7)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Round Robin</li>
</ul>
</td><td>Fixed </td><td>Select Unit0 Channel 0 - 7 channel priority </td></tr>
<tr>
<td>Channel Priority Control &gt; Unit 0 &gt; Arbitration method (Channel 8-15)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Round Robin</li>
</ul>
</td><td>Fixed </td><td>Select Unit0 Channel 8 - 15 channel priority </td></tr>
<tr>
<td>Channel Priority Control &gt; Unit 1 &gt; Arbitration method (Channel 0-7)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Round Robin</li>
</ul>
</td><td>Fixed </td><td>Select Unit1 Channel 0 - 7 channel priority </td></tr>
<tr>
<td>Channel Priority Control &gt; Unit 1 &gt; Arbitration method (Channel 8-15)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Round Robin</li>
</ul>
</td><td>Fixed </td><td>Select Unit1 Channel 8 - 15 channel priority </td></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Multiplex Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable multiplex interrupt for a single driver. </td></tr>
</table>
</p>
<dl class="section note"><dt>Note</dt><dd>When DMAC and other modules (e.g. SCI_UART) form a stack, interlocking modules do not generate interrupt which is used as DMAC trigger and instead, a DMAC interrupt occurs when the transfer completes. In this case, it is recommended to match these Multiplex Interrupt settings. Otherwise, multiplex interrupts can be allowed at unintended timings for the user.</dd></dl>
<p><h2>Configurations for Transfer &gt; Transfer (r_dmac)</h2>
This module can be added to the Stacks tab via New Stack &gt; Transfer &gt; Transfer (r_dmac).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_transfer0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Unit</td><td>Value must be a non-negative integer</td><td>0 </td><td>Specify the hardware unit. </td></tr>
<tr>
<td>General &gt; Channel</td><td>Must be a valid integer between 0 and 15.</td><td>0 </td><td>Specify the hardware channel. </td></tr>
<tr>
<td>General &gt; DMA Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Register mode</li>
<li>
Link mode</li>
</ul>
</td><td>Register mode </td><td>Select the DMA mode. </td></tr>
<tr>
<td>General &gt; Activation Source</td><td>MCU Specific Options</td><td></td><td>Select the DMAC transfer start event.<br />
Don't select same event between defferent CPUs. </td></tr>
<tr>
<td>Register Mode &gt; Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Normal</li>
<li>
Block</li>
</ul>
</td><td>Normal </td><td>Select the transfer mode. </td></tr>
<tr>
<td>Register Mode &gt; Transfer Source Size</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 Byte</li>
<li>
2 Bytes</li>
<li>
4 Bytes</li>
<li>
8 Bytes</li>
<li>
16 Bytes</li>
<li>
32 Bytes</li>
<li>
64 Bytes</li>
</ul>
</td><td>2 Bytes </td><td>Select the transfer source size. </td></tr>
<tr>
<td>Register Mode &gt; Transfer Destination Size</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 Byte</li>
<li>
2 Bytes</li>
<li>
4 Bytes</li>
<li>
8 Bytes</li>
<li>
16 Bytes</li>
<li>
32 Bytes</li>
<li>
64 Bytes</li>
</ul>
</td><td>2 Bytes </td><td>Select the transfer destination size. </td></tr>
<tr>
<td>Register Mode &gt; Destination Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Incremented</li>
</ul>
</td><td>Fixed </td><td>Select the address mode for the destination. </td></tr>
<tr>
<td>Register Mode &gt; Source Address Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Fixed</li>
<li>
Incremented</li>
</ul>
</td><td>Fixed </td><td>Select the address mode for the source. </td></tr>
<tr>
<td>Register Mode &gt; Destination Pointer</td><td>Manual Entry</td><td>NULL </td><td>Specify the transfer destination pointer. </td></tr>
<tr>
<td>Register Mode &gt; Source Pointer</td><td>Manual Entry</td><td>NULL </td><td>Specify the transfer source pointer. </td></tr>
<tr>
<td>Register Mode &gt; Number of Transfers</td><td>Value must be a non-negative integer</td><td>1 </td><td>Specify the bytes of transfers. </td></tr>
<tr>
<td>Register Mode &gt; DMA Activation Request Source Select</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Requested by a transfer source module</li>
<li>
Requested by a transfer destination module</li>
</ul>
</td><td>Requested by a transfer source module </td><td>Select DMA activation request source. </td></tr>
<tr>
<td>Register Mode &gt; Low Detection Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Enable </td><td>Select low detection enable. </td></tr>
<tr>
<td>Register Mode &gt; High Detection Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Select high detection enable. </td></tr>
<tr>
<td>Register Mode &gt; Level Detection Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Edge</li>
<li>
Level</li>
</ul>
</td><td>Edge </td><td>Select level detection enable. </td></tr>
<tr>
<td>Register Mode &gt; DACK Output mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Level mode</li>
<li>
Bus cycle mode</li>
<li>
Mask mode</li>
</ul>
</td><td>Level mode </td><td>Select DACK output mode. </td></tr>
<tr>
<td>Register Mode &gt; Next 1 Register Set enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
<li>
Enable(Continuous)</li>
</ul>
</td><td>Disable </td><td>When Next0 Register Set Transfer completes, Next1 Register Set Transfer occurs </td></tr>
<tr>
<td>Register Mode &gt; Next 1 Register Set Destination Pointer</td><td>Manual Entry</td><td>NULL </td><td>Specify the transfer destination pointer. </td></tr>
<tr>
<td>Register Mode &gt; Next 1 Register Set Source Pointer</td><td>Manual Entry</td><td>NULL </td><td>Specify the transfer source pointer. </td></tr>
<tr>
<td>Register Mode &gt; Next 1 Register Set Number of Transfers</td><td>Value must be a non-negative integer</td><td>1 </td><td>Specify the bytes of transfers. </td></tr>
<tr>
<td>Register Mode &gt; Transfer Interval</td><td>Value must be a non-negative integer</td><td>0 </td><td>Transfer interval </td></tr>
<tr>
<td>Link Modes &gt; Descriptor</td><td>Name must be a valid C symbol</td><td>NULL </td><td>DMAC Link mode descriptor symbol name. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback that is called at the end of the transfer. </td></tr>
<tr>
<td>Interrupts &gt; Context</td><td>Manual Entry</td><td>NULL </td><td>Pointer to the context structure passed through the callback argument. </td></tr>
<tr>
<td>Interrupts &gt; Transfer End Interrupt Detect Type</td><td>MCU Specific Options</td><td></td><td>Select transfer end interrupt detect type. </td></tr>
<tr>
<td>Interrupts &gt; Transfer End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the transfer end interrupt priority. </td></tr>
</table>
</p>
<dl class="section warning"><dt>Warning</dt><dd>1. "DMA Activation Request Source Select", "Low Detection Enable", "High Detection Enable", and "DACK output" must be set according to the DMAC transfer source. For details, see 'DMA Transfer Request Detection Operation Setting Table' of RZ microprocessor manual.</dd>
<dd>
2. Do not set the same activation source for multiple channels of the same unit. If the same source is set, the operation cannot be guaranteed.</dd></dl>
<h2><a class="anchor" id="r-dmac-clock-configuration"></a>
Clock Configuration</h2>
<p>The DMAC peripheral module uses ICLK as the clock source. The ICLK frequency is set by using the <b>Clocks</b> tab of the FSP Configuration editor prior to a build, or by using the CGC module at run-time.</p>
<h2><a class="anchor" id="r-dmac-pin-configuration"></a>
Pin Configuration</h2>
<p>The following pins are available by this module.</p><ul>
<li>DREQ: DMA transfer request</li>
<li>DACK: Output of DMAC transfer request acceptance</li>
<li>TEND: Output of transfer completion</li>
</ul>
<h1><a class="anchor" id="r-dmac-usage_notes"></a>
Usage Notes</h1>
<h2>Transfer Modes</h2>
<p>The DMAC Module supports two modes of operation.</p>
<ul>
<li><b>Normal Mode</b> - In normal mode, a single data unit is transfered every time the configured event is received by the DMAC channel. A data unit can be 1-byte, 2-bytes, 4-bytes, 8-byte, 16-byte or 32-byte (64-byte can be set only for DMAC0). The source and destination addresses can be fixed or increment. A 32-bit counter decrements after each transfer. When the counter reaches 0, transfers will no longer be triggered by the event and the CPU can be interrupted to signal that all transfers have finished.</li>
<li><b>Block Mode</b> - In block mode, the amount of data units transfered by each interrupt. For one DMA request, performs transfers until a DMA transfer completes. When the counter reaches 0, transfers will no longer be triggered by the event and the CPU can be interrupted to signal that all transfers have finished.</li>
</ul>
<h2>Link Mode</h2>
<p>In Link mode, a DMA transfer is performed by reading a descriptor placed in the RAM area as the transfer information setting value. The descriptor is configured by <a class="el" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> struct. For more information see 'Link Mode' section in the RZ microprocessor manual.</p>
<dl class="section note"><dt>Note</dt><dd>1. The descriptor must be 4-byte align and cannot be placed in TCM area. The DMAC HAL driver provides a memory section ".dmac_link_mode" on SystemRAM area for the descriptor allocation. </dd>
<dd>
2. To set the transfer source/destination address, use the memory map with the DMAC unit0/1 as the bus master. For more information, see 'Address Space' chapter in the RZ microprocessor manual for details. </dd>
<dd>
3. <a class="el" href="group___d_m_a_c.html#aff95e0ca2f4c68bf9ee8e0de3725d689" title="Channel configuration (Set value for CHCFG_n register). ">dmac_link_cfg_t::channel_cfg</a> and <a class="el" href="group___d_m_a_c.html#aa78aa3a19bd0431a455971975ab43ec6" title="Channel extension configuration (Set value for CHEXT_n register). ">dmac_link_cfg_t::channel_extension_cfg</a> have configuration restrictions same as the DMAC CHCFG_n and CHEXT_n registers. For more information see 'CHCFG_n : Channel Configuration Register n' and 'CHEXT_n : Channel Extension Register n' section in the RZ microprocessor manual. </dd>
<dd>
4. Setting the link destination of the last descriptor to the address of the previous descriptor configures the descriptors in a loop. When set the descriptor to a loop, disable Parameter Checking of Build Time Configuration to avoid infinite loop operation.</dd></dl>
<h2><a class="anchor" id="r-dmac-error-interrupt"></a>
Error Interrupt</h2>
<p>The DMAC outputs an error signal to the ICU when DMA error interrupt occurs. ICU can output PERI_ERRn interrupt (Peripherals error event n) to GIC or cause error reset when ICU accepts error signal from DMAC. To use PERI_ERRn interrupt or reset at DMAC, <a class="el" href="group___i_c_u___e_r_r_o_r.html">Interrupt Controller Unit (ICU) ERROR (r_icu_error)</a> need to be configured. When the PERI_ERRn interrupt is configured to use interrupt and triggered, the callback function registered during open is called.</p>
<h2><a class="anchor" id="r-dmac-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the DMAC:</p>
<ul>
<li>When operating link mode on the Cortex-A55, the source address, destination address, and next link address set in the descriptor should be set with physical addresses. To set the physical address, use R_BSP_MmuVatoPa function to convert from the virtual address to the physical address. If virtual address is set in the descriptor, proper DMA transfer is not guaranteed.</li>
<li>When operating on the Cortex-A55, do not set the virtual address value that cannot be translated to physical value by MMU as source address, destination address, or descriptor address. These address values are converted to physical addresses in the driver.</li>
</ul>
<h1><a class="anchor" id="r_dmac-examples"></a>
Examples</h1>
<h2>Basic Example (Register mode operation)</h2>
<p>This is a basic example of minimal use of the DMAC register mode operation in an application.</p>
<p>In this case, one or more events have been routed to the DMAC for handling so it only needs to be enabled to start accepting transfers.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_minimal_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the DMAC so that it responds to transfer requests. */</span></div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#ga8d860f51f5aa6e25d3820dc2262aa15a">R_DMAC_Enable</a>(&amp;g_transfer0_ctrl);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>CMTW Example (Register mode operation)</h2>
<p>In this example, one or more events (include CMTW) have been routed to the DMAC for handling so it only needs to be enabled to start accepting transfers.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> user_dmac_callback (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (p_args-&gt;<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a1533ff38216742b8c72284b53161a690">event</a> == TRANSFER_EVENT_TRANSFER_END)</div><div class="line">    {</div><div class="line">        g_transfer_complete = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> timer_callback (<a class="code" href="group___t_i_m_e_r___a_p_i.html#structtimer__callback__args__t">timer_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___t_i_m_e_r___a_p_i.html#ggac3bee51f7c9078f794c5ac19522f91ebae310bef0d640f06765c01b4b91a5b84c">TIMER_EVENT_CYCLE_END</a> == p_args-&gt;<a class="code" href="group___t_i_m_e_r___a_p_i.html#a61b9aabfcafc5e362dce56af7ea36bcf">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Add application code to be called periodically here. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_cmtw_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Initialize p_src0 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH_0; i++)</div><div class="line">    {</div><div class="line">        p_src0[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize p_src1 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH_1; i++)</div><div class="line">    {</div><div class="line">        p_src1[i] = (uint8_t) (<span class="charliteral">&#39;0&#39;</span> + (i % 10));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize p_src2 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH_2; i++)</div><div class="line">    {</div><div class="line">        p_src2[i] = (uint8_t) (<span class="charliteral">&#39;a&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Open the CMTW instance. (CMTW timer for DMAC transfer trigger.) */</span></div><div class="line">    err = <a class="code" href="group___c_m_t_w.html#ga7b086a5e535460e7855000cc6141b22e">R_CMTW_Open</a>(&amp;g_timer0_ctrl, &amp;g_timer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> transfer_info_0;</div><div class="line"></div><div class="line">    <span class="comment">/* Transfer size settings */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a354b4d97746d9393110fc679d466ad99">src_size</a>  = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12a4284e820735faa08a0702f0d430f2924">TRANSFER_SIZE_64_BYTE</a>;</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a023152eeec3dda49c43b0a5576b07881">dest_size</a> = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12a4284e820735faa08a0702f0d430f2924">TRANSFER_SIZE_64_BYTE</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Next0 register settings. */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a197ef7d84898829f988dca88fc9e481c">p_src</a>  = (<span class="keywordtype">void</span> *) (&amp;p_src0[0]);</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#acc20817272cf1db573a1dbc54a9cb3bf">p_dest</a> = (<span class="keywordtype">void</span> *) (&amp;p_dest0[0]);</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ae3cc32eab1926d03875e2c9fa4e6190b">mode</a>   = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadfb7c2a6a73bfdf993e50505aa92992fada90d8a89f98ff82475383b14141b08d">TRANSFER_MODE_NORMAL</a>;</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a5aba602d71a6ba4e6be056a90b5ed9e8">length</a> = TRANSFER_LENGTH_0;</div><div class="line"></div><div class="line">    <span class="comment">/* Next1 register settings. */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a07ff7ab703d6c6e5f3e2fdeabce7519a">p_next1_src</a>  = (<span class="keywordtype">void</span> *) (uint32_t) &amp;p_src1[0];</div><div class="line">    transfer_info_0.p_next1_dest = (<span class="keywordtype">void</span> *) (uint32_t) &amp;p_dest1[0];</div><div class="line">    transfer_info_0.next1_length = TRANSFER_LENGTH_1;</div><div class="line"></div><div class="line">    <span class="comment">/* Triggered by CMTW, transfer is performed continuously with Next0 -&gt; Next1 setting. */</span></div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#ga6e932ab91dd283665438d06813d162bf">R_DMAC_Reconfigure</a>(&amp;g_transfer0_ctrl, &amp;transfer_info_0);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Start the timer for DMAC trigger. */</span></div><div class="line">    (void) <a class="code" href="group___c_m_t_w.html#ga874d0098275f48ec3c84e8587d262fce">R_CMTW_Start</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the 1st(Next0 register set) DMA transfer completion. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the 2nd(Next1 register set) DMA transfer completion. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Stop the timer for DMAC trigger. Transfer will be triggered by software */</span></div><div class="line">    (void) <a class="code" href="group___c_m_t_w.html#ga842bb3b9c5c12cdfff41dd8595defc70">R_CMTW_Stop</a>(&amp;g_timer0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Set Transfer settings by using reconfigure API. */</span></div><div class="line">    <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> transfer_info_1 = transfer_info_0;</div><div class="line">    transfer_info_1.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a197ef7d84898829f988dca88fc9e481c">p_src</a>  = (<span class="keywordtype">void</span> *) (&amp;p_src2[0]);</div><div class="line">    transfer_info_1.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#acc20817272cf1db573a1dbc54a9cb3bf">p_dest</a> = (<span class="keywordtype">void</span> *) (&amp;p_dest2[0]);</div><div class="line">    transfer_info_1.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ae3cc32eab1926d03875e2c9fa4e6190b">mode</a>   = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadfb7c2a6a73bfdf993e50505aa92992faa4f65de2d9454af406f60172ff858d55">TRANSFER_MODE_BLOCK</a>;</div><div class="line">    transfer_info_1.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a5aba602d71a6ba4e6be056a90b5ed9e8">length</a> = TRANSFER_LENGTH_2;</div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#ga6e932ab91dd283665438d06813d162bf">R_DMAC_Reconfigure</a>(&amp;g_transfer0_ctrl, &amp;transfer_info_1);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* SoftwareStart */</span></div><div class="line">    <span class="comment">/* Note: When executing SoftwareStart API continuously without calling Reconfigure API, */</span></div><div class="line">    <span class="comment">/*       Enable API must be called in advance.                                          */</span></div><div class="line">    <span class="comment">/*       (EN bit is automatically cleared after the transfer.                           */</span></div><div class="line">    <span class="comment">/*        see RZ microprocessor &#39;CHSTAT_n : Channel Status Register n&#39; section)         */</span></div><div class="line">    err = <a class="code" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart</a>(&amp;g_transfer0_ctrl, (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>) NULL);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer complete interrupt */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Reload Example (Register mode Next0/1 continuous execution operation)</h2>
<p>This is a basic example of minimal use of two Next register sets (Next0/1 register set) to continue DMA transfers in register mode. For more information see 'Next Register Continuous Execution Settings' section in the RZ microprocessor manual.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> dmac_reload_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH_0; i++)</div><div class="line">    {</div><div class="line">        p_src0[i] = (uint8_t) (i % UINT8_MAX);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH_1; i++)</div><div class="line">    {</div><div class="line">        p_src1[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH_2; i++)</div><div class="line">    {</div><div class="line">        p_src2[i] = (uint8_t) (<span class="charliteral">&#39;a&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Reconfigure for the DMA transfer (1st(Next0 register set) and 2nd(Next1 register set) DMA transfer) information. */</span></div><div class="line">    <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> transfer_info_0;</div><div class="line"></div><div class="line">    <span class="comment">/* Transfer size settings */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a354b4d97746d9393110fc679d466ad99">src_size</a>  = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12accfeb24892ec24e42ccf14e4d4896c21">TRANSFER_SIZE_1_BYTE</a>;</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a023152eeec3dda49c43b0a5576b07881">dest_size</a> = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga6c224e5afb174f3f6ea9eddbb9da8b12accfeb24892ec24e42ccf14e4d4896c21">TRANSFER_SIZE_1_BYTE</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Address mode settings. */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a1a73c1297d04667da6b2103db34f88ad">src_addr_mode</a>  = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadce62e6c2407d6ffd5a94636736f7c51a7665741e25c4cc78fd24745efbd2eaad">TRANSFER_ADDR_MODE_INCREMENTED</a>;</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a9e39c449b5d1f8a957b833833c7da06b">dest_addr_mode</a> = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadce62e6c2407d6ffd5a94636736f7c51a7665741e25c4cc78fd24745efbd2eaad">TRANSFER_ADDR_MODE_INCREMENTED</a>;</div><div class="line"></div><div class="line">    <span class="comment">/* Next0 register settings. */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a197ef7d84898829f988dca88fc9e481c">p_src</a>  = (<span class="keywordtype">void</span> *) (&amp;p_src0[0]);</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#acc20817272cf1db573a1dbc54a9cb3bf">p_dest</a> = (<span class="keywordtype">void</span> *) (&amp;p_dest0[0]);</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ae3cc32eab1926d03875e2c9fa4e6190b">mode</a>   = <a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#gadfb7c2a6a73bfdf993e50505aa92992fada90d8a89f98ff82475383b14141b08d">TRANSFER_MODE_NORMAL</a>;</div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a5aba602d71a6ba4e6be056a90b5ed9e8">length</a> = TRANSFER_LENGTH_0;</div><div class="line"></div><div class="line">    <span class="comment">/* Next1 register settings. */</span></div><div class="line">    transfer_info_0.<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a07ff7ab703d6c6e5f3e2fdeabce7519a">p_next1_src</a>  = (<span class="keywordtype">void</span> *) (uint32_t) &amp;p_src1[0];</div><div class="line">    transfer_info_0.p_next1_dest = (<span class="keywordtype">void</span> *) (uint32_t) &amp;p_dest1[0];</div><div class="line">    transfer_info_0.next1_length = TRANSFER_LENGTH_1;</div><div class="line"></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga6e932ab91dd283665438d06813d162bf">R_DMAC_Reconfigure</a>(&amp;g_transfer0_ctrl, &amp;transfer_info_0);</div><div class="line"></div><div class="line">    <span class="comment">/* Software Start. (Block Transfer) */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart</a>(&amp;g_transfer0_ctrl, (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>) NULL);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the 1st(Next0 register set) DMA transfer completion. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Set for the next DMA transfer (3rd(Next0 register set) DMA transfer) information. */</span></div><div class="line">    <span class="comment">/* While performing a DMA transfer of a Next register, set the other Next register. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#gae415cc72455bc260ad1c5289e3308240">R_DMAC_Reload</a>(&amp;g_transfer0_ctrl, &amp;p_src2[0], &amp;p_dest2[0], TRANSFER_LENGTH_2);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the 2nd(Next1 register set) DMA transfer completion. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    g_transfer_complete = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for the 3rd(Next0 register set) DMA transfer completion. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Link Mode Example (Cortex-R52 CPU0 Side)</h2>
<p>This is a basic example of minimal use of the DMAC link mode operation in an application. DMAC transfer is triggered by <a class="el" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>DMAC accesses to TCMs of Cortex-R52 CPU0 via AXIS interface in Cortex-R52 CPU0. Therefore, when setting a TCM area of Cortex-R52 CPU0 as the transfer source/destination address, CPU0 TCM via AXIS area must be set. For more information, see 'Address Space' chapter in the RZ microprocessor manual for details.</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define TRANSFER_LENGTH                     (128)</span></div><div class="line">uint8_t g_src_cr52_cpu0[TRANSFER_LENGTH];  <span class="comment">/* Placed at TCM area of Cortex-R52 CPU0 */</span></div><div class="line">uint8_t g_dest_cr52_cpu0[TRANSFER_LENGTH]; <span class="comment">/* Placed at TCM area of Cortex-R52 CPU0 */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define CPU0_TCM_VIA_AXIS_ADDRESS_OFFSET    (0x20000000)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define DMAC_CHCFG_SETTING_VALUE            (0x80444220)</span></div><div class="line"><span class="preprocessor">#define DMAC_CHEXT_SCA_POS                  (4UL)</span></div><div class="line"><span class="preprocessor">#define DMAC_CHEXT_DCA_POS                  (12UL)</span></div><div class="line"><span class="preprocessor">#define DMAC_CHEXT_SETTING_VALUE_FOR_TCM    ((0x02U &lt;&lt; DMAC_CHEXT_SCA_POS) | (0x02U &lt;&lt; DMAC_CHEXT_DCA_POS))</span></div><div class="line"></div><div class="line"><a class="code" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> transfer0_descriptor_cr52_cpu0 BSP_ALIGN_VARIABLE (4) BSP_PLACE_IN_SECTION(&quot;.dmac_link_mode&quot;) =</div><div class="line">{</div><div class="line">    .header.link_valid         = <a class="code" href="group___d_m_a_c.html#ggac0f8e5b884076714f7b2780fed1fee68ac2477ddcee37a6e9085dd8e7a9f18831">DMAC_LINK_VALID_DESCRIPTOR_ENABLE</a>,</div><div class="line">    .header.link_end           = <a class="code" href="group___d_m_a_c.html#gga4a4428a1a93151a05cd0b8e26a1482f5a40a13502e51ad168077818e194dff1f9">DMAC_LINK_END_ENABLE</a>,</div><div class="line">    .header.write_back_disable = <a class="code" href="group___d_m_a_c.html#gga85528156741050dd0e12836da2604329ad021f16c86987f6b72b6e8be9952b9c0">DMAC_LINK_WRITE_BACK_DISABLE</a>,</div><div class="line">    .header.interrupt_mask     = <a class="code" href="group___d_m_a_c.html#gga26d8829b918ac50911e94bb98affd911aa2caaad8f67849e0323ef830dba29aed">DMAC_LINK_INTERRUPT_MASK_ENABLE</a>,</div><div class="line">    .p_src                 = (<span class="keywordtype">void</span> *) ((uint32_t) &amp;g_src_cr52_cpu0[0] + CPU0_TCM_VIA_AXIS_ADDRESS_OFFSET),  <span class="comment">/* Source address */</span></div><div class="line">    .p_dest                = (<span class="keywordtype">void</span> *) ((uint32_t) &amp;g_dest_cr52_cpu0[0] + CPU0_TCM_VIA_AXIS_ADDRESS_OFFSET), <span class="comment">/* Destination address */</span></div><div class="line">    .transaction_byte      = TRANSFER_LENGTH,                                                               <span class="comment">/* Transaction byte */</span></div><div class="line">    .channel_cfg           = DMAC_CHCFG_SETTING_VALUE,                                                      <span class="comment">/* Channel configuration register setting */</span></div><div class="line">    .channel_interval      = 0,                                                                             <span class="comment">/* Channel interval. */</span></div><div class="line">    .channel_extension_cfg = DMAC_CHEXT_SETTING_VALUE_FOR_TCM,                                              <span class="comment">/* Channel extension register setting */</span></div><div class="line">    .p_next_link_addr      = NULL,                                                                          <span class="comment">/* Next link address */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_link_mode_example_cpu0 (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src_cr52_cpu0[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Reset transfer descriptor. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#gab37103a34f8b4bfb41d5adcd30ea8e95">R_DMAC_LinkDescriptorSet</a>(&amp;g_transfer0_ctrl, &amp;transfer0_descriptor_cr52_cpu0);</div><div class="line"></div><div class="line">    <span class="comment">/* Trigger the transfer using software. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart</a>(&amp;g_transfer0_ctrl, (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>) NULL);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer complete interrupt */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Link Mode Example (Cortex-R52 CPU1 Side)</h2>
<p>This is a basic example of minimal use of the DMAC link mode operation in an application. DMAC transfer is triggered by <a class="el" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart()</a>.</p>
<p>In this example, the transfer source/destination address is set to a Non-Cached area of System RAM.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define TRANSFER_LENGTH             (128)</span></div><div class="line">uint8_t g_src_cr52_cpu1[TRANSFER_LENGTH] BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.noncache_buffer&quot;</span>);  <span class="comment">/* Placed at System RAM Non-Cache buffer area */</span></div><div class="line">uint8_t g_dest_cr52_cpu1[TRANSFER_LENGTH] BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.noncache_buffer&quot;</span>); <span class="comment">/* Placed at System RAM Non-Cache buffer area */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define DMAC_CHCFG_SETTING_VALUE    (0x80444220)</span></div><div class="line"><span class="preprocessor">#define DMAC_CHEXT_SETTING_VALUE    (0x00)</span></div><div class="line"></div><div class="line"><a class="code" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> transfer0_descriptor_cr52_cpu1 BSP_ALIGN_VARIABLE (4) BSP_PLACE_IN_SECTION(&quot;.dmac_link_mode&quot;) =</div><div class="line">{</div><div class="line">    .header.link_valid         = <a class="code" href="group___d_m_a_c.html#ggac0f8e5b884076714f7b2780fed1fee68ac2477ddcee37a6e9085dd8e7a9f18831">DMAC_LINK_VALID_DESCRIPTOR_ENABLE</a>,</div><div class="line">    .header.link_end           = <a class="code" href="group___d_m_a_c.html#gga4a4428a1a93151a05cd0b8e26a1482f5a40a13502e51ad168077818e194dff1f9">DMAC_LINK_END_ENABLE</a>,</div><div class="line">    .header.write_back_disable = <a class="code" href="group___d_m_a_c.html#gga85528156741050dd0e12836da2604329ad021f16c86987f6b72b6e8be9952b9c0">DMAC_LINK_WRITE_BACK_DISABLE</a>,</div><div class="line">    .header.interrupt_mask     = <a class="code" href="group___d_m_a_c.html#gga26d8829b918ac50911e94bb98affd911aa2caaad8f67849e0323ef830dba29aed">DMAC_LINK_INTERRUPT_MASK_ENABLE</a>,</div><div class="line">    .p_src                 = &amp;g_src_cr52_cpu1[0],      <span class="comment">/* Source address */</span></div><div class="line">    .p_dest                = &amp;g_dest_cr52_cpu1[0],     <span class="comment">/* Destination address */</span></div><div class="line">    .transaction_byte      = TRANSFER_LENGTH,          <span class="comment">/* Transaction byte */</span></div><div class="line">    .channel_cfg           = DMAC_CHCFG_SETTING_VALUE, <span class="comment">/* Channel configuration register setting */</span></div><div class="line">    .channel_interval      = 0,                        <span class="comment">/* Channel interval. */</span></div><div class="line">    .channel_extension_cfg = DMAC_CHEXT_SETTING_VALUE, <span class="comment">/* Channel extension register setting */</span></div><div class="line">    .p_next_link_addr      = NULL,                     <span class="comment">/* Next link address */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_link_mode_example_cpu1 (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src_cr52_cpu1[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Reset transfer descriptor. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#gab37103a34f8b4bfb41d5adcd30ea8e95">R_DMAC_LinkDescriptorSet</a>(&amp;g_transfer0_ctrl, &amp;transfer0_descriptor_cr52_cpu1);</div><div class="line"></div><div class="line">    <span class="comment">/* Trigger the transfer using software. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart</a>(&amp;g_transfer0_ctrl, (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>) NULL);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer complete interrupt */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Link Mode Example (Cortex-A55 Side)</h2>
<p>This is a basic example of minimal use of the DMAC link mode operation in an application. DMAC transfer is triggered by <a class="el" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart()</a>.</p>
<p>In this example, the transfer source/destination address is set to a Non-Cached area of System RAM.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor"> #define TRANSFER_LENGTH                         (128)</span></div><div class="line">uint8_t g_src_ca55[TRANSFER_LENGTH] BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.noncache_buffer&quot;</span>);  <span class="comment">/* Placed at System RAM Non-Cache buffer area */</span></div><div class="line">uint8_t g_dest_ca55[TRANSFER_LENGTH] BSP_PLACE_IN_SECTION(<span class="stringliteral">&quot;.noncache_buffer&quot;</span>); <span class="comment">/* Placed at System RAM Non-Cache buffer area */</span></div><div class="line"><span class="preprocessor"> #define DMAC_NEXT_DESCRIPTOR_VIRTUAL_ADDRESS    (0x0)</span></div><div class="line"><span class="preprocessor"> #define DMAC_CHCFG_SETTING_VALUE                (0x80444220)</span></div><div class="line"><span class="preprocessor"> #define DMAC_CHEXT_SETTING_VALUE                (0x00)</span></div><div class="line"></div><div class="line"><a class="code" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> transfer0_descriptor_ca55 BSP_ALIGN_VARIABLE (8) BSP_PLACE_IN_SECTION(&quot;.dmac_link_mode&quot;) =</div><div class="line">{</div><div class="line">    .header.link_valid         = <a class="code" href="group___d_m_a_c.html#ggac0f8e5b884076714f7b2780fed1fee68ac2477ddcee37a6e9085dd8e7a9f18831">DMAC_LINK_VALID_DESCRIPTOR_ENABLE</a>,</div><div class="line">    .header.link_end           = <a class="code" href="group___d_m_a_c.html#gga4a4428a1a93151a05cd0b8e26a1482f5a40a13502e51ad168077818e194dff1f9">DMAC_LINK_END_ENABLE</a>,</div><div class="line">    .header.write_back_disable = <a class="code" href="group___d_m_a_c.html#gga85528156741050dd0e12836da2604329ad021f16c86987f6b72b6e8be9952b9c0">DMAC_LINK_WRITE_BACK_DISABLE</a>,</div><div class="line">    .header.interrupt_mask     = <a class="code" href="group___d_m_a_c.html#gga26d8829b918ac50911e94bb98affd911aa2caaad8f67849e0323ef830dba29aed">DMAC_LINK_INTERRUPT_MASK_ENABLE</a>,</div><div class="line">    .src_addr              = 0,                        <span class="comment">/* Source address (dummy) */</span></div><div class="line">    .dest_addr             = 0,                        <span class="comment">/* Destination address (dummy) */</span></div><div class="line">    .transaction_byte      = TRANSFER_LENGTH,          <span class="comment">/* Transaction byte */</span></div><div class="line">    .channel_cfg           = DMAC_CHCFG_SETTING_VALUE, <span class="comment">/* Channel configuration register setting */</span></div><div class="line">    .channel_interval      = 0,                        <span class="comment">/* Channel interval. */</span></div><div class="line">    .channel_extension_cfg = DMAC_CHEXT_SETTING_VALUE, <span class="comment">/* Channel extension register setting */</span></div><div class="line">    .next_link_addr        = 0,                        <span class="comment">/* Next link address (dummy) */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dmac_link_mode_example_ca55 (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; TRANSFER_LENGTH; i++)</div><div class="line">    {</div><div class="line">        g_src_ca55[i] = (uint8_t) (<span class="charliteral">&#39;A&#39;</span> + (i % 26));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*  To set the physical address, use R_BSP_MmuVatoPa function to convert from the virtual address to the physical address. */</span></div><div class="line">    uint64_t * p_src_paddress;</div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga2de8191850f60f69955bf0a0a532ee42">R_BSP_MmuVatoPa</a>((uint64_t) &amp;g_src_ca55[0], p_src_paddress);</div><div class="line">    transfer0_descriptor_ca55.src_addr = (uint32_t) *p_src_paddress;</div><div class="line"></div><div class="line">    uint64_t * p_dest_paddress;</div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga2de8191850f60f69955bf0a0a532ee42">R_BSP_MmuVatoPa</a>((uint64_t) &amp;g_dest_ca55[0], p_dest_paddress);</div><div class="line">    transfer0_descriptor_ca55.dest_addr = (uint32_t) *p_dest_paddress;</div><div class="line"></div><div class="line">    uint64_t * p_next_link_paddress;</div><div class="line">    <a class="code" href="group___b_s_p___m_c_u.html#ga2de8191850f60f69955bf0a0a532ee42">R_BSP_MmuVatoPa</a>(DMAC_NEXT_DESCRIPTOR_VIRTUAL_ADDRESS, p_next_link_paddress);</div><div class="line">    transfer0_descriptor_ca55.next_link_addr = (uint32_t) *p_next_link_address;</div><div class="line"></div><div class="line">    <span class="comment">/* Open the transfer instance with initial configuration. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga7e5fda31237adb83fee8cf5a42daed48">R_DMAC_Open</a>(&amp;g_transfer0_ctrl, &amp;g_transfer0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Reset transfer descriptor. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#gab37103a34f8b4bfb41d5adcd30ea8e95">R_DMAC_LinkDescriptorSet</a>(&amp;g_transfer0_ctrl, &amp;transfer0_descriptor_ca55);</div><div class="line"></div><div class="line">    <span class="comment">/* Trigger the transfer using software. */</span></div><div class="line">    <a class="code" href="group___d_m_a_c.html#ga047024929094fd5306c6cd2aeb17ecb1">R_DMAC_SoftwareStart</a>(&amp;g_transfer0_ctrl, (<a class="code" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>) NULL);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (!g_transfer_complete)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for transfer complete interrupt */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structdmac__link__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a></td></tr>
<tr class="separator:structdmac__link__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdmac__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#structdmac__instance__ctrl__t">dmac_instance_ctrl_t</a></td></tr>
<tr class="separator:structdmac__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structdmac__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#structdmac__extended__cfg__t">dmac_extended_cfg_t</a></td></tr>
<tr class="separator:structdmac__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1e459d63cbd5b7c819ca786a55093307"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga1e459d63cbd5b7c819ca786a55093307">DMAC_MAX_NORMAL_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:ga1e459d63cbd5b7c819ca786a55093307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cd4e308943601114ffcafdc621c116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gab4cd4e308943601114ffcafdc621c116">DMAC_MAX_BLOCK_TRANSFER_LENGTH</a></td></tr>
<tr class="separator:gab4cd4e308943601114ffcafdc621c116"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac0f8e5b884076714f7b2780fed1fee68"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gac0f8e5b884076714f7b2780fed1fee68">dmac_link_valid_t</a> </td></tr>
<tr class="separator:gac0f8e5b884076714f7b2780fed1fee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a4428a1a93151a05cd0b8e26a1482f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga4a4428a1a93151a05cd0b8e26a1482f5">dmac_link_end_t</a> </td></tr>
<tr class="separator:ga4a4428a1a93151a05cd0b8e26a1482f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85528156741050dd0e12836da2604329"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga85528156741050dd0e12836da2604329">dmac_link_write_back_t</a> </td></tr>
<tr class="separator:ga85528156741050dd0e12836da2604329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d8829b918ac50911e94bb98affd911"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga26d8829b918ac50911e94bb98affd911">dmac_link_interrupt_mask_t</a> </td></tr>
<tr class="separator:ga26d8829b918ac50911e94bb98affd911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91c9975b2193c2f4b25139573a618c61"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga91c9975b2193c2f4b25139573a618c61">dmac_register_select_reverse_t</a> </td></tr>
<tr class="separator:ga91c9975b2193c2f4b25139573a618c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb65e50e49c0ffc2943c8c5085c0c0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga2fb65e50e49c0ffc2943c8c5085c0c0f">dmac_ack_mode_t</a> </td></tr>
<tr class="separator:ga2fb65e50e49c0ffc2943c8c5085c0c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3527028a6bd65a3b22f4a14be6b9829e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga3527028a6bd65a3b22f4a14be6b9829e">dmac_detection_t</a> </td></tr>
<tr class="separator:ga3527028a6bd65a3b22f4a14be6b9829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf701953caca92cce67e0426664b10c50"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#gaf701953caca92cce67e0426664b10c50">dmac_request_direction_t</a> </td></tr>
<tr class="separator:gaf701953caca92cce67e0426664b10c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81ff959e77bb3e4e37a7e4e68d23a02b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga81ff959e77bb3e4e37a7e4e68d23a02b">dmac_channel_scheduling_t</a> </td></tr>
<tr class="separator:ga81ff959e77bb3e4e37a7e4e68d23a02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873499bc88e96b4626d26f6591372cc7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ga873499bc88e96b4626d26f6591372cc7">dmac_mode_select_t</a> </td></tr>
<tr class="separator:ga873499bc88e96b4626d26f6591372cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structdmac__link__cfg__t" id="structdmac__link__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdmac__link__cfg__t">&#9670;&nbsp;</a></span>dmac_link_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dmac_link_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Descriptor structure used in DMAC link mode, and variables of <a class="el" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> must be allocated in the memory area. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="af503f29d605b5dacf81576be4c997c1d"></a>union <a class="el" href="group___d_m_a_c.html#uniondmac__link__cfg__t_8____unnamed____">dmac_link_cfg_t</a></td>
<td class="fieldname">
__unnamed__</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a010ba2472a0e4e9501cf8571fa058df0"></a>void const  *volatile</td>
<td class="fieldname">
p_src</td>
<td class="fielddoc">
Source address. </td></tr>
<tr><td class="fieldtype">
<a id="abfb258c690661510dd57a10077a17f8b"></a>void *volatile</td>
<td class="fieldname">
p_dest</td>
<td class="fielddoc">
Destination address. </td></tr>
<tr><td class="fieldtype">
<a id="a7b3015ee86fae992ede031cba2242ec2"></a>volatile uint32_t</td>
<td class="fieldname">
transaction_byte</td>
<td class="fielddoc">
Transaction byte. </td></tr>
<tr><td class="fieldtype">
<a id="aff95e0ca2f4c68bf9ee8e0de3725d689"></a>volatile uint32_t</td>
<td class="fieldname">
channel_cfg</td>
<td class="fielddoc">
Channel configuration (Set value for CHCFG_n register). </td></tr>
<tr><td class="fieldtype">
<a id="a711db2abd2d9bae91dbafef2188218c9"></a>volatile uint32_t</td>
<td class="fieldname">
channel_interval</td>
<td class="fielddoc">
Channel interval (Set value for CHITVL register). </td></tr>
<tr><td class="fieldtype">
<a id="aa78aa3a19bd0431a455971975ab43ec6"></a>volatile uint32_t</td>
<td class="fieldname">
channel_extension_cfg</td>
<td class="fielddoc">
Channel extension configuration (Set value for CHEXT_n register). </td></tr>
<tr><td class="fieldtype">
<a id="a50bfdd5f070eaff0092ff624a84bc706"></a>void *volatile</td>
<td class="fieldname">
p_next_link_addr</td>
<td class="fielddoc">
Next link address. </td></tr>
</table>

</div>
</div>
<a name="structdmac__instance__ctrl__t" id="structdmac__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdmac__instance__ctrl__t">&#9670;&nbsp;</a></span>dmac_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dmac_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Control block used by driver. DO NOT INITIALIZE - this structure will be initialized in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#a84d48960cdfe867ef54fd4635a85ceeb">transfer_api_t::open</a>. </p>
</div>
</div>
</div>
<a name="structdmac__extended__cfg__t" id="structdmac__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structdmac__extended__cfg__t">&#9670;&nbsp;</a></span>dmac_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dmac_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>DMAC transfer configuration extension. This extension is required. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a68b7564427a42697bd26a4c4206c2fd6"><td class="memItemLeft" align="right" valign="top"><a id="a68b7564427a42697bd26a4c4206c2fd6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a68b7564427a42697bd26a4c4206c2fd6">unit</a></td></tr>
<tr class="memdesc:a68b7564427a42697bd26a4c4206c2fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit number. <br /></td></tr>
<tr class="separator:a68b7564427a42697bd26a4c4206c2fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ee22f2e357c5098bbe67bbdf920371"><td class="memItemLeft" align="right" valign="top"><a id="a96ee22f2e357c5098bbe67bbdf920371"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a96ee22f2e357c5098bbe67bbdf920371">channel</a></td></tr>
<tr class="memdesc:a96ee22f2e357c5098bbe67bbdf920371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel number. <br /></td></tr>
<tr class="separator:a96ee22f2e357c5098bbe67bbdf920371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77ec8a7d9579e9091dfeee342a596e7"><td class="memItemLeft" align="right" valign="top"><a id="ad77ec8a7d9579e9091dfeee342a596e7"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ad77ec8a7d9579e9091dfeee342a596e7">dmac_int_irq</a></td></tr>
<tr class="memdesc:ad77ec8a7d9579e9091dfeee342a596e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC interrupt number. <br /></td></tr>
<tr class="separator:ad77ec8a7d9579e9091dfeee342a596e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebcd194714d90e3a1ae502744a6a2e6"><td class="memItemLeft" align="right" valign="top"><a id="a7ebcd194714d90e3a1ae502744a6a2e6"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a7ebcd194714d90e3a1ae502744a6a2e6">dmac_int_ipl</a></td></tr>
<tr class="memdesc:a7ebcd194714d90e3a1ae502744a6a2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC interrupt priority. <br /></td></tr>
<tr class="separator:a7ebcd194714d90e3a1ae502744a6a2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d19b6c334536f89e11c91d2b9fa9c6"><td class="memItemLeft" align="right" valign="top"><a id="a67d19b6c334536f89e11c91d2b9fa9c6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a67d19b6c334536f89e11c91d2b9fa9c6">dmac_int_irq_detect_type</a></td></tr>
<tr class="memdesc:a67d19b6c334536f89e11c91d2b9fa9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC interrupt detection type. <br /></td></tr>
<tr class="separator:a67d19b6c334536f89e11c91d2b9fa9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae520b30cee620c91a4aa4d123ef437bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_p___m_c_u___r_z_t2_h.html#gaebe723200f2a7f181f08324128b9d7b5">elc_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ae520b30cee620c91a4aa4d123ef437bc">activation_source</a></td></tr>
<tr class="separator:ae520b30cee620c91a4aa4d123ef437bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955287924ce9f03af386b253441bfbfe"><td class="memItemLeft" align="right" valign="top"><a id="a955287924ce9f03af386b253441bfbfe"></a>
<a class="el" href="group___d_m_a_c.html#ga2fb65e50e49c0ffc2943c8c5085c0c0f">dmac_ack_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a955287924ce9f03af386b253441bfbfe">ack_mode</a></td></tr>
<tr class="memdesc:a955287924ce9f03af386b253441bfbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">DACK output mode. <br /></td></tr>
<tr class="separator:a955287924ce9f03af386b253441bfbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a63419e2521a7554b2747b015f5ff8"><td class="memItemLeft" align="right" valign="top"><a id="a39a63419e2521a7554b2747b015f5ff8"></a>
<a class="el" href="group___d_m_a_c.html#ga3527028a6bd65a3b22f4a14be6b9829e">dmac_detection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a39a63419e2521a7554b2747b015f5ff8">detection_mode</a></td></tr>
<tr class="memdesc:a39a63419e2521a7554b2747b015f5ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC request detection method. <br /></td></tr>
<tr class="separator:a39a63419e2521a7554b2747b015f5ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc1a5d5ec0b52edb051a63f4f41b8f7"><td class="memItemLeft" align="right" valign="top"><a id="a9dc1a5d5ec0b52edb051a63f4f41b8f7"></a>
<a class="el" href="group___d_m_a_c.html#gaf701953caca92cce67e0426664b10c50">dmac_request_direction_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a9dc1a5d5ec0b52edb051a63f4f41b8f7">activation_request_source_select</a></td></tr>
<tr class="memdesc:a9dc1a5d5ec0b52edb051a63f4f41b8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC activation request source. <br /></td></tr>
<tr class="separator:a9dc1a5d5ec0b52edb051a63f4f41b8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268d7555146e0c93846793485cde22cf"><td class="memItemLeft" align="right" valign="top"><a id="a268d7555146e0c93846793485cde22cf"></a>
<a class="el" href="group___d_m_a_c.html#ga91c9975b2193c2f4b25139573a618c61">dmac_register_select_reverse_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a268d7555146e0c93846793485cde22cf">next_register_operation</a></td></tr>
<tr class="memdesc:a268d7555146e0c93846793485cde22cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next register operation settings. <br /></td></tr>
<tr class="separator:a268d7555146e0c93846793485cde22cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fb22128d44f4d604cbe77372d5743c"><td class="memItemLeft" align="right" valign="top"><a id="ad6fb22128d44f4d604cbe77372d5743c"></a>
<a class="el" href="group___d_m_a_c.html#ga873499bc88e96b4626d26f6591372cc7">dmac_mode_select_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ad6fb22128d44f4d604cbe77372d5743c">dmac_mode</a></td></tr>
<tr class="memdesc:ad6fb22128d44f4d604cbe77372d5743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMAC Mode. <br /></td></tr>
<tr class="separator:ad6fb22128d44f4d604cbe77372d5743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833a6755c7d4a233ea8243c903354a5"><td class="memItemLeft" align="right" valign="top"><a id="ad833a6755c7d4a233ea8243c903354a5"></a>
<a class="el" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#ad833a6755c7d4a233ea8243c903354a5">p_descriptor</a></td></tr>
<tr class="memdesc:ad833a6755c7d4a233ea8243c903354a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address of the descriptor (DMA Link Mode only) <br /></td></tr>
<tr class="separator:ad833a6755c7d4a233ea8243c903354a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3047f4912871cf9eb100800c9f296d87"><td class="memItemLeft" align="right" valign="top"><a id="a3047f4912871cf9eb100800c9f296d87"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a3047f4912871cf9eb100800c9f296d87">transfer_interval</a></td></tr>
<tr class="memdesc:a3047f4912871cf9eb100800c9f296d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA transfer interval. <br /></td></tr>
<tr class="separator:a3047f4912871cf9eb100800c9f296d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcec47da500a02cb015f31beab5f6ddb"><td class="memItemLeft" align="right" valign="top"><a id="adcec47da500a02cb015f31beab5f6ddb"></a>
<a class="el" href="group___d_m_a_c.html#ga81ff959e77bb3e4e37a7e4e68d23a02b">dmac_channel_scheduling_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#adcec47da500a02cb015f31beab5f6ddb">channel_scheduling</a></td></tr>
<tr class="memdesc:adcec47da500a02cb015f31beab5f6ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA channel scheduling. <br /></td></tr>
<tr class="separator:adcec47da500a02cb015f31beab5f6ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ef0783415dd7cb179580d406e78ace"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a97ef0783415dd7cb179580d406e78ace">p_callback</a> )(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *cb_data)</td></tr>
<tr class="separator:a97ef0783415dd7cb179580d406e78ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179371bb68b6d1ae0f7c1da5a2c46d34"><td class="memItemLeft" align="right" valign="top">void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___d_m_a_c.html#a179371bb68b6d1ae0f7c1da5a2c46d34">p_context</a></td></tr>
<tr class="separator:a179371bb68b6d1ae0f7c1da5a2c46d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="ae520b30cee620c91a4aa4d123ef437bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae520b30cee620c91a4aa4d123ef437bc">&#9670;&nbsp;</a></span>activation_source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_p___m_c_u___r_z_t2_h.html#gaebe723200f2a7f181f08324128b9d7b5">elc_event_t</a> dmac_extended_cfg_t::activation_source</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select which event will trigger the transfer. </p>

</div>
</div>
<a id="a97ef0783415dd7cb179580d406e78ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ef0783415dd7cb179580d406e78ace">&#9670;&nbsp;</a></span>p_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*  dmac_extended_cfg_t::p_callback) (<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for transfer end interrupt. </p>

</div>
</div>
<a id="a179371bb68b6d1ae0f7c1da5a2c46d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179371bb68b6d1ae0f7c1da5a2c46d34">&#9670;&nbsp;</a></span>p_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const* dmac_extended_cfg_t::p_context</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for user data. Passed to the user p_callback in <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a>. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1e459d63cbd5b7c819ca786a55093307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e459d63cbd5b7c819ca786a55093307">&#9670;&nbsp;</a></span>DMAC_MAX_NORMAL_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_NORMAL_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max configurable number of transfers in TRANSFER_MODE_NORMAL. </p>

</div>
</div>
<a id="gab4cd4e308943601114ffcafdc621c116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4cd4e308943601114ffcafdc621c116">&#9670;&nbsp;</a></span>DMAC_MAX_BLOCK_TRANSFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DMAC_MAX_BLOCK_TRANSFER_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of transfers per block in TRANSFER_MODE_BLOCK </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac0f8e5b884076714f7b2780fed1fee68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0f8e5b884076714f7b2780fed1fee68">&#9670;&nbsp;</a></span>dmac_link_valid_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#gac0f8e5b884076714f7b2780fed1fee68">dmac_link_valid_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the descriptor is enabled or disabled. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac0f8e5b884076714f7b2780fed1fee68a9cdd907c5124d2db3cab848436230cc6"></a>DMAC_LINK_VALID_DESCRIPTOR_DISABLE&#160;</td><td class="fielddoc"><p>The Descriptor is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac0f8e5b884076714f7b2780fed1fee68ac2477ddcee37a6e9085dd8e7a9f18831"></a>DMAC_LINK_VALID_DESCRIPTOR_ENABLE&#160;</td><td class="fielddoc"><p>The Descriptor is enabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4a4428a1a93151a05cd0b8e26a1482f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a4428a1a93151a05cd0b8e26a1482f5">&#9670;&nbsp;</a></span>dmac_link_end_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga4a4428a1a93151a05cd0b8e26a1482f5">dmac_link_end_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the link ends during DMA transfer of this descriptor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4a4428a1a93151a05cd0b8e26a1482f5a9df3657ff91e58b325f7feb863044565"></a>DMAC_LINK_END_DISABLE&#160;</td><td class="fielddoc"><p>The link continues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a4428a1a93151a05cd0b8e26a1482f5a40a13502e51ad168077818e194dff1f9"></a>DMAC_LINK_END_ENABLE&#160;</td><td class="fielddoc"><p>The link ends. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga85528156741050dd0e12836da2604329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85528156741050dd0e12836da2604329">&#9670;&nbsp;</a></span>dmac_link_write_back_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga85528156741050dd0e12836da2604329">dmac_link_write_back_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Masks write back execution of the dmac_link_cfg_t::link_valid. When disable, DMAC does not perform write-back operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga85528156741050dd0e12836da2604329a503f1bc1c3661d4774e2ecf181e245c8"></a>DMAC_LINK_WRITE_BACK_ENABLE&#160;</td><td class="fielddoc"><p>Set dmac_link_cfg_t::link_valid to disable after the DMA transfer ends. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga85528156741050dd0e12836da2604329ad021f16c86987f6b72b6e8be9952b9c0"></a>DMAC_LINK_WRITE_BACK_DISABLE&#160;</td><td class="fielddoc"><p>Remain dmac_link_cfg_t::link_valid after DMA transfer ends. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga26d8829b918ac50911e94bb98affd911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26d8829b918ac50911e94bb98affd911">&#9670;&nbsp;</a></span>dmac_link_interrupt_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga26d8829b918ac50911e94bb98affd911">dmac_link_interrupt_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When dmac_link_cfg_t::link_valid is DMAC_LINK_VALID_DESCRIPTOR_DISABLE at loading of header, specifies whether DMA transfer completion interrupt mask or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga26d8829b918ac50911e94bb98affd911af70deb9b076e3ffba63b47688b009e30"></a>DMAC_LINK_INTERRUPT_MASK_DISABLE&#160;</td><td class="fielddoc"><p>DMA transfer completion interrupt is asserted. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga26d8829b918ac50911e94bb98affd911aa2caaad8f67849e0323ef830dba29aed"></a>DMAC_LINK_INTERRUPT_MASK_ENABLE&#160;</td><td class="fielddoc"><p>DMA transfer completion interrupt is masked. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga91c9975b2193c2f4b25139573a618c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91c9975b2193c2f4b25139573a618c61">&#9670;&nbsp;</a></span>dmac_register_select_reverse_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga91c9975b2193c2f4b25139573a618c61">dmac_register_select_reverse_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select the Next register set to be executed next. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga91c9975b2193c2f4b25139573a618c61a72907333ed0fc8bc19a1d7ded9e30dc5"></a>DMAC_REGISTER_SELECT_REVERSE_DISABLE&#160;</td><td class="fielddoc"><p>Use Next0 register set. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91c9975b2193c2f4b25139573a618c61a370bbc0955a015e0f64b54d61c55c73e"></a>DMAC_REGISTER_SELECT_REVERSE_ENABLE&#160;</td><td class="fielddoc"><p>Use Next1 register set. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga91c9975b2193c2f4b25139573a618c61a41b7224353ac180330421738419c8c79"></a>DMAC_REGISTER_SELECT_REVERSE_ENABLE_PERFORM_ACCORDINGLY&#160;</td><td class="fielddoc"><p>Use Next1 register set after Next0 register set transfer completed. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2fb65e50e49c0ffc2943c8c5085c0c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb65e50e49c0ffc2943c8c5085c0c0f">&#9670;&nbsp;</a></span>dmac_ack_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga2fb65e50e49c0ffc2943c8c5085c0c0f">dmac_ack_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DACK output mode. See 'DMA Transfer Request Detection Operation Setting Table' of RZ microprocessor manual. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2fb65e50e49c0ffc2943c8c5085c0c0faaa27e4cc5082830bb252a783af5fb46c"></a>DMAC_ACK_MODE_LEVEL_MODE&#160;</td><td class="fielddoc"><p>Level mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2fb65e50e49c0ffc2943c8c5085c0c0fa34c30d7a79f908ad460ff1f5fadddb50"></a>DMAC_ACK_MODE_BUS_CYCLE_MODE&#160;</td><td class="fielddoc"><p>Bus cycle mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2fb65e50e49c0ffc2943c8c5085c0c0fa98337a8182cf1c03269909aca9113fb0"></a>DMAC_ACK_MODE_MASK_DACK_OUTPUT&#160;</td><td class="fielddoc"><p>Output is masked. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3527028a6bd65a3b22f4a14be6b9829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3527028a6bd65a3b22f4a14be6b9829e">&#9670;&nbsp;</a></span>dmac_detection_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga3527028a6bd65a3b22f4a14be6b9829e">dmac_detection_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detection method of the DMA request signal. See 'DMA Transfer Request Detection Operation Setting Table' of RZ microprocessor manual. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3527028a6bd65a3b22f4a14be6b9829ea1f49e45fb93bbc8ce56a75de3a11affb"></a>DMAC_DETECTION_FALLING_EDGE&#160;</td><td class="fielddoc"><p>Falling edge detection. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3527028a6bd65a3b22f4a14be6b9829ea6294b67aef9ab9ed62ba6b3bbf98223d"></a>DMAC_DETECTION_RISING_EDGE&#160;</td><td class="fielddoc"><p>Rising edge detection. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3527028a6bd65a3b22f4a14be6b9829ea32226f832af2e985ccf76afc75af9971"></a>DMAC_DETECTION_LOW_LEVEL&#160;</td><td class="fielddoc"><p>Low level detection. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3527028a6bd65a3b22f4a14be6b9829ea5c2d59f791ebb7c94d0d203aa196ce92"></a>DMAC_DETECTION_HIGH_LEVEL&#160;</td><td class="fielddoc"><p>High level detection. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf701953caca92cce67e0426664b10c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf701953caca92cce67e0426664b10c50">&#9670;&nbsp;</a></span>dmac_request_direction_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#gaf701953caca92cce67e0426664b10c50">dmac_request_direction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA activation request source select. See 'DMA Transfer Request Detection Operation Setting Table' of RZ microprocessor manual. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf701953caca92cce67e0426664b10c50a3c6b7cb060592a002539d61ce49f5354"></a>DMAC_REQUEST_DIRECTION_SOURCE_MODULE&#160;</td><td class="fielddoc"><p>Requested by a transfer source module. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf701953caca92cce67e0426664b10c50a5b12a64340c2a6e780b3976b59059533"></a>DMAC_REQUEST_DIRECTION_DESTINATION_MODULE&#160;</td><td class="fielddoc"><p>Requested by a transfer destination module. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga81ff959e77bb3e4e37a7e4e68d23a02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81ff959e77bb3e4e37a7e4e68d23a02b">&#9670;&nbsp;</a></span>dmac_channel_scheduling_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga81ff959e77bb3e4e37a7e4e68d23a02b">dmac_channel_scheduling_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMAC channel scheduling. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga81ff959e77bb3e4e37a7e4e68d23a02ba31321e8bdb5deb117614b6e1f4c45269"></a>DMAC_CHANNEL_SCHEDULING_FIXED&#160;</td><td class="fielddoc"><p>Fixed priority mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga81ff959e77bb3e4e37a7e4e68d23a02bad80560a675c08f023fa9f625c7d30396"></a>DMAC_CHANNEL_SCHEDULING_ROUND_ROBIN&#160;</td><td class="fielddoc"><p>Round-robin mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga873499bc88e96b4626d26f6591372cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873499bc88e96b4626d26f6591372cc7">&#9670;&nbsp;</a></span>dmac_mode_select_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___d_m_a_c.html#ga873499bc88e96b4626d26f6591372cc7">dmac_mode_select_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMAC mode setting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga873499bc88e96b4626d26f6591372cc7a9c4395e96bfe849404b24faa6315b618"></a>DMAC_MODE_SELECT_REGISTER&#160;</td><td class="fielddoc"><p>Register mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga873499bc88e96b4626d26f6591372cc7a8bb68933123b0a14e1324905f92f7f41"></a>DMAC_MODE_SELECT_LINK&#160;</td><td class="fielddoc"><p>Link mode. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7e5fda31237adb83fee8cf5a42daed48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e5fda31237adb83fee8cf5a42daed48">&#9670;&nbsp;</a></span>R_DMAC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__cfg__t">transfer_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a DMAC channel.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful open. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The configured channel is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>The IRQ associated with the activation source is not enabled in the BSP. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The control structure is already opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Transfer source address is invalid. Transfer destination address is invalid. Descriptor address is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When operating on the Cortex-A55, if you set 0x0 (NULL) as the source or destination address, FSP_ERR_INVALID_ADDRESS is not returned, even if the address is invalid. </dd></dl>

</div>
</div>
<a id="ga6e932ab91dd283665438d06813d162bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e932ab91dd283665438d06813d162bf">&#9670;&nbsp;</a></span>R_DMAC_Reconfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__info__t">transfer_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconfigure the transfer with new transfer info.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer is configured and will start when trigger occurs. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>DMAC is not enabled. The current configuration must not be valid. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>DMA mode is link mode. This function can only be used when the DMA mode is register mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Transfer source address is invalid. Transfer destination address is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When operating on the Cortex-A55, if you set 0x0 (NULL) as the source or destination address, FSP_ERR_INVALID_ADDRESS is not returned, even if the address is invalid. </dd></dl>

</div>
</div>
<a id="gaca5dc2be3a25f6b4c9582915ec6445c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5dc2be3a25f6b4c9582915ec6445c0">&#9670;&nbsp;</a></span>R_DMAC_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *volatile&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *volatile&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>num_transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset transfer source, destination, and number of transfers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga047024929094fd5306c6cd2aeb17ecb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047024929094fd5306c6cd2aeb17ecb1">&#9670;&nbsp;</a></span>R_DMAC_SoftwareStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_SoftwareStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga11917a0ab2cb8b878937c97691b07fd9">transfer_start_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a transfer request by software.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer started written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae68c517e00cf0817dff0f96b651f7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae68c517e00cf0817dff0f96b651f7dd">&#9670;&nbsp;</a></span>R_DMAC_SoftwareStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_SoftwareStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop software transfers if they were started with TRANSFER_START_MODE_REPEAT.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d860f51f5aa6e25d3820dc2262aa15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d860f51f5aa6e25d3820dc2262aa15a">&#9670;&nbsp;</a></span>R_DMAC_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable transfers for the configured activation source.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14a3958fdb85b53cae9b11e8735b578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14a3958fdb85b53cae9b11e8735b578d">&#9670;&nbsp;</a></span>R_DMAC_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable transfers so that they are no longer triggered by the activation source.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Counter value written successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45893222e0710e310ae398c14ef47174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45893222e0710e310ae398c14ef47174">&#9670;&nbsp;</a></span>R_DMAC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__properties__t">transfer_properties_t</a> *const&#160;</td>
          <td class="paramname"><em>p_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set driver specific information in provided pointer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information has been written to p_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc5aef880361cff7f61b88ecf418c1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc5aef880361cff7f61b88ecf418c1de">&#9670;&nbsp;</a></span>R_DMAC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable transfer and clean up internal data. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ade5973e7a8e994f9146e0db84bee8bf4">transfer_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful close. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae415cc72455bc260ad1c5289e3308240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae415cc72455bc260ad1c5289e3308240">&#9670;&nbsp;</a></span>R_DMAC_Reload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_Reload </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *volatile&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *volatile&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>num_transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the following transfer settings to continue the transfer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Successful continuous transfer settings. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This API cannot be called during link mode operation or setting not to use the Next1 register. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CALL</td><td>Invalid call. The series of transfer processing has finished. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Transfer source address is invalid. Transfer destination address is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53ef1808423dabba647a3a2eed5a4b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53ef1808423dabba647a3a2eed5a4b02">&#9670;&nbsp;</a></span>R_DMAC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#structtransfer__callback__args__t">transfer_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#aec396dcd365f215cabfa1097e2a963de">transfer_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab37103a34f8b4bfb41d5adcd30ea8e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37103a34f8b4bfb41d5adcd30ea8e95">&#9670;&nbsp;</a></span>R_DMAC_LinkDescriptorSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_DMAC_LinkDescriptorSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___t_r_a_n_s_f_e_r___a_p_i.html#ga665f80fc984ccf7585606be8eeccbb98">transfer_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___d_m_a_c.html#structdmac__link__cfg__t">dmac_link_cfg_t</a> *&#160;</td>
          <td class="paramname"><em>p_descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconfigure the transfer descriptor information with new transfer descriptor.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Transfer is configured and will start when trigger occurs. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input parameter is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>DMAC is not enabled. The current configuration must not be valid. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>DMA mode is register mode. This function can only be used when the DMA mode is link mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Handle is not initialized. Call R_DMAC_Open to initialize the control block. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ADDRESS</td><td>Descriptor address is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
