<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZT Flexible Software Package Documentation: Bus State Controller (BSC) SDRAM (r_bsc_sdram)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZT Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v2.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___b_s_c___s_d_r_a_m.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Bus State Controller (BSC) SDRAM (r_bsc_sdram)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_y_s_t_e_m___m_o_d_u_l_e_s.html">System</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f2e78724073df56351b78425722a8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga2f2e78724073df56351b78425722a8d9">R_BSC_SDRAM_Open</a> (<a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *p_ctrl, <a class="el" href="group___s_d_r_a_m___a_p_i.html#structsdram__cfg__t">sdram_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga2f2e78724073df56351b78425722a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f746dccad9ebd1d56524ada849ec43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga33f746dccad9ebd1d56524ada849ec43">R_BSC_SDRAM_SelfRefreshEnter</a> (<a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga33f746dccad9ebd1d56524ada849ec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa30d462968c00221b648f82352b0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga7aa30d462968c00221b648f82352b0cb">R_BSC_SDRAM_SelfRefreshExit</a> (<a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga7aa30d462968c00221b648f82352b0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae99f1d77f255dfe64daacebbcbd6b103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#gae99f1d77f255dfe64daacebbcbd6b103">R_BSC_SDRAM_PowerDownEnter</a> (<a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:gae99f1d77f255dfe64daacebbcbd6b103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd7d6874d39f9d83b4ec87575d7fe20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#gaacd7d6874d39f9d83b4ec87575d7fe20">R_BSC_SDRAM_PowerDownExit</a> (<a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:gaacd7d6874d39f9d83b4ec87575d7fe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e095ec54c16c07b189163782461fcbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga0e095ec54c16c07b189163782461fcbc">R_BSC_SDRAM_Close</a> (<a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga0e095ec54c16c07b189163782461fcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the BSC peripheral on RZ microprocessor. This module implements the <a class="el" href="group___s_d_r_a_m___a_p_i.html">SDRAM Interface</a>. </p>
<h1><a class="anchor" id="r-bsc-sdram-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-bsc-sdram-features"></a>
Features</h2>
<p>The BSC SDRAM driver has the following key features:</p><ul>
<li>Memory mapped write/read access to the SDRAM<a class="anchor" id="um_sdram_write"></a><a class="anchor" id="um_sdram_read"></a></li>
<li>Supports 16bit Data bus size<a class="anchor" id="um_sdram_databus_settings"></a></li>
<li>Supports CS3 space<a class="anchor" id="um_sdram_cs_settings"></a></li>
<li>Can be configured with SDRAM device<a class="anchor" id="um_sdram_configuration"></a><a class="anchor" id="um_sdram_cas_latency_settings"></a></li>
<li>Can be configured with SDRAM timing<a class="anchor" id="um_sdram_timing_settings"></a></li>
<li>Auto-Refresh operation<a class="anchor" id="um_sdram_auto_refresh"></a></li>
<li>Entering and exiting Self-Refresh mode<a class="anchor" id="um_sdram_self_refresh_mode"></a></li>
<li>Entering and exiting Power-Down mode<a class="anchor" id="um_sdram_power_down_mode"></a></li>
<li>Auto-precharge mode (using READA and WRITA commands) operation or Bank active mode (using READ and WRIT commands) operation<a class="anchor" id="um_bsc_sdram_write_bank_active"></a><a class="anchor" id="um_bsc_sdram_read_bank_active"></a> <a class="anchor" id="um_sdram_uninitialized_global_variables"></a> </li>
</ul>
<h1><a class="anchor" id="r-bsc-sdram-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_bsc_sdram_access_idle_cycle_settings"></a> <h2>Build Time Configurations for r_bsc_sdram</h2>
The following build time configurations are defined in fsp_cfg/r_bsc_sdram_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Multiplex Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable multiplex interrupt for a single driver. </td></tr>
</table>
 <h2>Configurations for Storage &gt; SDRAM (r_bsc_sdram)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; SDRAM (r_bsc_sdram).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_sdram0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Chip Select</td><td>Chip Select 3</td><td>Chip Select 3 </td><td>Specify the SDRAM chip select line to use. </td></tr>
<tr>
<td>General &gt; Data Bus Width</td><td>16-bit</td><td>16-bit </td><td>Select the number of SDRAM data bus width. </td></tr>
<tr>
<td>Idle Cycles &gt; Read-Read Cycles In The Same CS Space</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
4 CYCLES</li>
<li>
6 CYCLES</li>
<li>
8 CYCLES</li>
<li>
10 CYCLES</li>
<li>
12 CYCLES</li>
</ul>
</td><td>4 CYCLES </td><td>Idle cycle insertion between Read-Read cycles in the same CS space. </td></tr>
<tr>
<td>Idle Cycles &gt; Read-Read Cycles In The Different CS Spaces</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
4 CYCLES</li>
<li>
6 CYCLES</li>
<li>
8 CYCLES</li>
<li>
10 CYCLES</li>
<li>
12 CYCLES</li>
</ul>
</td><td>4 CYCLES </td><td>Idle cycle insertion between Read-Read cycles in different CS space. </td></tr>
<tr>
<td>Idle Cycles &gt; Read-Write Cycles In The Same CS Spaces</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
4 CYCLES</li>
<li>
6 CYCLES</li>
<li>
8 CYCLES</li>
<li>
10 CYCLES</li>
<li>
12 CYCLES</li>
</ul>
</td><td>4 CYCLES </td><td>Idle cycle insertion between Read-Write cycles in the same CS space. </td></tr>
<tr>
<td>Idle Cycles &gt; Read-Write Cycles In The Different CS Spaces</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
4 CYCLES</li>
<li>
6 CYCLES</li>
<li>
8 CYCLES</li>
<li>
10 CYCLES</li>
<li>
12 CYCLES</li>
</ul>
</td><td>4 CYCLES </td><td>Idle cycle insertion between Read-Write cycles in different CS space. </td></tr>
<tr>
<td>Idle Cycles &gt; Write-Read Cycles And Write-Write Cycles</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
4 CYCLES</li>
<li>
6 CYCLES</li>
<li>
8 CYCLES</li>
<li>
10 CYCLES</li>
<li>
12 CYCLES</li>
</ul>
</td><td>4 CYCLES </td><td>Idle cycles between Write-Read cycles and Write-Write cycles. </td></tr>
<tr>
<td>Address Bit Width &gt; Row Address Bit Width</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
11-bit</li>
<li>
12-bit</li>
<li>
13-bit</li>
</ul>
</td><td>11-bit </td><td>Select the number of SDRAM row address bus width. </td></tr>
<tr>
<td>Address Bit Width &gt; Column Address Bit Width</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
8-bit</li>
<li>
9-bit</li>
<li>
10-bit</li>
</ul>
</td><td>8-bit </td><td>Select the number of SDRAM column address bus width. </td></tr>
<tr>
<td>Wait Insertion for SDRAM Timing &gt; RAS# Precharge Cycle (PRECHARGE to ACTIVE)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
3 CYCLES</li>
</ul>
</td><td>0 CYCLE </td><td>Number of Auto-Precharge Completion Wait States (tRP) </td></tr>
<tr>
<td>Wait Insertion for SDRAM Timing &gt; RAS# To CAS# Delay Cycle (ACTIVE to READ/WRITE)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
3 CYCLES</li>
</ul>
</td><td>0 CYCLE </td><td>Number of Waits between ACTV Command and READ(A)/WRIT(A) Command (tRCD) </td></tr>
<tr>
<td>Wait Insertion for SDRAM Timing &gt; CAS Latency</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
3 CYCLES</li>
<li>
4 CYCLES</li>
</ul>
</td><td>1 CYCLE </td><td>CAS Latency (tCL) </td></tr>
<tr>
<td>Wait Insertion for SDRAM Timing &gt; Last data in to Active Latency (WRITA to ACTIVE) / Write Recovery Cycle (WRIT to PRECHARGE)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
0 CYCLE</li>
<li>
1 CYCLE</li>
<li>
2 CYCLES</li>
<li>
3 CYCLES</li>
</ul>
</td><td>0 CYCLE </td><td>The state number from the issuance of the WRITA command until the issuance of the ACTV command (tDAL) / The state number from the issuance of the WRIT command until the issuance of the PRE command (tWR) </td></tr>
<tr>
<td>Wait Insertion for SDRAM Timing &gt; Row Cycle (ACTIVE to ACTIVE)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
2 CYCLES</li>
<li>
3 CYCLES</li>
<li>
5 CYCLES</li>
<li>
8 CYCLES</li>
</ul>
</td><td>2 CYCLES </td><td>Number of Idle States from REF Command/Self-Refresh Release to ACTV/REF/MRS Command (tRC) </td></tr>
<tr>
<td>Auto Refresh &gt; Refresh Cycle Period (tREF)</td><td>Value must be non-negative</td><td>64 </td><td>Refresh Cycle Time (tREF) </td></tr>
<tr>
<td>Auto Refresh &gt; Refresh Cycle Period Unit</td><td>Milliseconds</td><td>Milliseconds </td><td>Unit of the period specified above </td></tr>
<tr>
<td>Auto Refresh &gt; The Number of Continuous Refresh Cycles</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
2</li>
<li>
4</li>
<li>
6</li>
<li>
8</li>
</ul>
</td><td>1 </td><td>A refresh request is generated and an auto-refresh is performed for the number of times specified by this configuration. </td></tr>
<tr>
<td>Extra &gt; MRS Burst Setting</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Burst Read / Burst Write</li>
<li>
Burst Read / Single Write</li>
</ul>
</td><td>Burst Read / Burst Write </td><td>Write Burst Mode setting of SDRAM mode register </td></tr>
<tr>
<td>Extra &gt; Command Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Auto Precharge Mode (using READA and WRITA commands)</li>
<li>
Bank Active Mode (using READ and WRIT commands)</li>
</ul>
</td><td>Auto Precharge Mode (using READA and WRITA commands) </td><td>Select whether to access in auto-precharge mode (using READA and WRITA commands) or in bank active mode (using READ and WRIT commands). </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided. If this callback function is provided, it will be called from the interrupt service routine (ISR). </td></tr>
<tr>
<td>Interrupts &gt; Refresh Timer Compare Match Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select the refresh timer compare match interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-bsc-sdram-auto-refresh-operation-configuration"></a>
Auto-Refresh operation interval configuration</h2>
<p>Auto-Refresh operation interval is calculated from "Refresh Cycle Period (tREF)" , "Row Address Bit Width" and "The Number of Continuous Refresh Cycles" user-setting. In the example below, Auto-Refresh operation interval setting target to the BSC peripheral is 7.8125 us. This interval is counted by CKIO clock.</p>
<p>Refresh Cycle Period (tREF) = 64 ms</p>
<p>Row Address Bit Width = 13bit = 8192 row</p>
<p>The Number of Continuous Refresh Cycles = 1</p>
<p>Auto-Refresh operation interval = (64 ms / 8192) * 1 = 7.8125 us</p>
<h2><a class="anchor" id="r-bsc-sdram-clock-configuration"></a>
Clock Configuration</h2>
<p>The BSC clock is derived from External bus clock (BSC_CLK, CKIO). You can set the clock frequency using the <b>Clocks</b> tab of the FSP Configuration editor or by using the CGC Interface at run-time.</p>
<h1><a class="anchor" id="r-bsc-sdram-usage_notes"></a>
Usage Notes</h1>
<h2>BSC_SDRAM Memory Mapped Access</h2>
<p>After <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga2f2e78724073df56351b78425722a8d9">R_BSC_SDRAM_Open()</a> completes successfully, the connected SDRAM device contents are mapped to address 0x78000000(External address space CS3) or 0x58000000(Mirror space of External address space CS3) and can be read like internal memory.</p>
<p>When not using the cache, access the memory via the mirror space.</p>
<p>The address map for the external address space for BSC_SDRAM is as follows:</p>
<table class="doxtable">
<tr>
<th>Address </th><th>Space  </th></tr>
<tr>
<td>0x58000000 to 0x5BFFFFFF </td><td>CS3 mirror space </td></tr>
<tr>
<td>0x78000000 to 0x7BFFFFFF </td><td>CS3 space </td></tr>
</table>
<h2>Self-Refresh Operation</h2>
<p>After <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga2f2e78724073df56351b78425722a8d9">R_BSC_SDRAM_Open()</a> completes successfully, BSC_SDRAM starts Auto-Refresh operation which issues refresh command every configured cycle.</p>
<p>If not using the auto-refresh operation after <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga2f2e78724073df56351b78425722a8d9">R_BSC_SDRAM_Open()</a>, self-refresh operation can be started by calling <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga33f746dccad9ebd1d56524ada849ec43">R_BSC_SDRAM_SelfRefreshEnter()</a> after <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga2f2e78724073df56351b78425722a8d9">R_BSC_SDRAM_Open()</a>.</p>
<h1><a class="anchor" id="r-bsc-sdram-examples"></a>
Examples</h1>
<h2><a class="anchor" id="r-bsc-sdram-examples-basic"></a>
Basic Example</h2>
<p>This is a basic example of minimal use of the BSC_SDRAM module in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CS3_BASE                         (0x58000000)</span></div><div class="line"><span class="preprocessor">#define BSC_SDRAM_EXAMPLE_DATA_LENGTH    (256)</span></div><div class="line">uint16_t write_data[BSC_SDRAM_EXAMPLE_DATA_LENGTH];</div><div class="line">uint16_t read_data[BSC_SDRAM_EXAMPLE_DATA_LENGTH];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_bsc_sdram_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Write some data to the write buffer */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; BSC_SDRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        write_data[i] = i;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the BSC_SDRAM instance */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___b_s_c___s_d_r_a_m.html#ga2f2e78724073df56351b78425722a8d9">R_BSC_SDRAM_Open</a>(&amp;g_sdram_ctrl, &amp;g_sdram_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* After R_BSC_SDRAM_Open() and any required device specific initialization, data can be write directly</span></div><div class="line"><span class="comment">     * to the SDRAM connected to BSC. */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; BSC_SDRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        *((<span class="keyword">volatile</span> uint16_t *) CS3_BASE + 0x0000 + i) = write_data[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* After R_BSC_SDRAM_Open() and any required device specific initialization, data can be read directly</span></div><div class="line"><span class="comment">     * from the SDRAM connected to BSC. */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; BSC_SDRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        read_data[i] = *((<span class="keyword">volatile</span> uint16_t *) CS3_BASE + 0x0000 + i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the read_data. */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; BSC_SDRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (read_data[i] != write_data[i])</div><div class="line">        {</div><div class="line">            <span class="comment">/* Verify error. */</span></div><div class="line">            __BKPT(0);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structbsc__sdram__callback__args__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#structbsc__sdram__callback__args__t">bsc_sdram_callback_args_t</a></td></tr>
<tr class="separator:structbsc__sdram__callback__args__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structbsc__sdram__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#structbsc__sdram__extended__cfg__t">bsc_sdram_extended_cfg_t</a></td></tr>
<tr class="separator:structbsc__sdram__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structbsc__sdram__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#structbsc__sdram__instance__ctrl__t">bsc_sdram_instance_ctrl_t</a></td></tr>
<tr class="separator:structbsc__sdram__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga18786329189e0979c7835a569ac7fcb1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga18786329189e0979c7835a569ac7fcb1">bsc_sdram_chip_select_t</a> </td></tr>
<tr class="separator:ga18786329189e0979c7835a569ac7fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga159a39327eab5952ca46895345b624f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a> </td></tr>
<tr class="separator:ga159a39327eab5952ca46895345b624f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1c0e66f14f9002e9ac5468a5affd07"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#gada1c0e66f14f9002e9ac5468a5affd07">bsc_sdram_command_t</a> </td></tr>
<tr class="separator:gada1c0e66f14f9002e9ac5468a5affd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structbsc__sdram__callback__args__t" id="structbsc__sdram__callback__args__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structbsc__sdram__callback__args__t">&#9670;&nbsp;</a></span>bsc_sdram_callback_args_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bsc_sdram_callback_args_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Callback function parameter data. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a2771bd400d425c2688203265007fc46e"></a>void const  *</td>
<td class="fieldname">
p_context</td>
<td class="fielddoc">
Placeholder for user data. </td></tr>
</table>

</div>
</div>
<a name="structbsc__sdram__extended__cfg__t" id="structbsc__sdram__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structbsc__sdram__extended__cfg__t">&#9670;&nbsp;</a></span>bsc_sdram_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bsc_sdram_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Extended configuration. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a2eba7d793caf6f269da6bef9407bb9ac"><td class="memItemLeft" align="right" valign="top"><a id="a2eba7d793caf6f269da6bef9407bb9ac"></a>
<a class="el" href="group___b_s_c___s_d_r_a_m.html#ga18786329189e0979c7835a569ac7fcb1">bsc_sdram_chip_select_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#a2eba7d793caf6f269da6bef9407bb9ac">chip_select</a></td></tr>
<tr class="memdesc:a2eba7d793caf6f269da6bef9407bb9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select which device to use. <br /></td></tr>
<tr class="separator:a2eba7d793caf6f269da6bef9407bb9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ad31459c23e253a2e6aa64d26cb1ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#aa7ad31459c23e253a2e6aa64d26cb1ef">r_r_same_space_idle_cycle</a></td></tr>
<tr class="separator:aa7ad31459c23e253a2e6aa64d26cb1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e24f2112c965451875a7d49fc7ab44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#a34e24f2112c965451875a7d49fc7ab44">r_r_different_space_idle_cycle</a></td></tr>
<tr class="separator:a34e24f2112c965451875a7d49fc7ab44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed11f4e435b59db141dbdac850b7567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#aeed11f4e435b59db141dbdac850b7567">r_w_same_space_idle_cycle</a></td></tr>
<tr class="separator:aeed11f4e435b59db141dbdac850b7567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995b256efebfa5f8eb6eba5c1f2e2b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#a995b256efebfa5f8eb6eba5c1f2e2b62">r_w_different_space_idle_cycle</a></td></tr>
<tr class="separator:a995b256efebfa5f8eb6eba5c1f2e2b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf5b9c5313887ca5a789cdcde580cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#adaf5b9c5313887ca5a789cdcde580cdc">w_r_w_w_idle_cycle</a></td></tr>
<tr class="separator:adaf5b9c5313887ca5a789cdcde580cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c24dbb1c1e0a6a59a4ce11e3ffe0c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___b_s_c___s_d_r_a_m.html#gada1c0e66f14f9002e9ac5468a5affd07">bsc_sdram_command_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#a22c24dbb1c1e0a6a59a4ce11e3ffe0c5">command_mode</a></td></tr>
<tr class="separator:a22c24dbb1c1e0a6a59a4ce11e3ffe0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70339b6b7a736cdb097fbe1726b1a098"><td class="memItemLeft" align="right" valign="top"><a id="a70339b6b7a736cdb097fbe1726b1a098"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#a70339b6b7a736cdb097fbe1726b1a098">cmi_ipl</a></td></tr>
<tr class="memdesc:a70339b6b7a736cdb097fbe1726b1a098"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDRAM refresh compare match interrupt. <br /></td></tr>
<tr class="separator:a70339b6b7a736cdb097fbe1726b1a098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ce523aa4a47428a4093c1677bbfd84"><td class="memItemLeft" align="right" valign="top"><a id="af1ce523aa4a47428a4093c1677bbfd84"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#af1ce523aa4a47428a4093c1677bbfd84">cmi_irq</a></td></tr>
<tr class="memdesc:af1ce523aa4a47428a4093c1677bbfd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDRAM refresh compare match interrupt priority. <br /></td></tr>
<tr class="separator:af1ce523aa4a47428a4093c1677bbfd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0499a56f6c17c41e5ab9b3eb2ee760"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#abd0499a56f6c17c41e5ab9b3eb2ee760">p_callback</a> )(<a class="el" href="group___b_s_c___s_d_r_a_m.html#structbsc__sdram__callback__args__t">bsc_sdram_callback_args_t</a> *p_args)</td></tr>
<tr class="separator:abd0499a56f6c17c41e5ab9b3eb2ee760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae509c3fed7a7ac4dd1780a376f841adc"><td class="memItemLeft" align="right" valign="top">void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ae509c3fed7a7ac4dd1780a376f841adc">p_context</a></td></tr>
<tr class="separator:ae509c3fed7a7ac4dd1780a376f841adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="aa7ad31459c23e253a2e6aa64d26cb1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ad31459c23e253a2e6aa64d26cb1ef">&#9670;&nbsp;</a></span>r_r_same_space_idle_cycle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a> bsc_sdram_extended_cfg_t::r_r_same_space_idle_cycle</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Idle cycle between Read-Read cycles in the same CS space </p>

</div>
</div>
<a id="a34e24f2112c965451875a7d49fc7ab44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e24f2112c965451875a7d49fc7ab44">&#9670;&nbsp;</a></span>r_r_different_space_idle_cycle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a> bsc_sdram_extended_cfg_t::r_r_different_space_idle_cycle</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Idle cycle between Read-Read cycles in the different CS space </p>

</div>
</div>
<a id="aeed11f4e435b59db141dbdac850b7567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed11f4e435b59db141dbdac850b7567">&#9670;&nbsp;</a></span>r_w_same_space_idle_cycle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a> bsc_sdram_extended_cfg_t::r_w_same_space_idle_cycle</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Idle cycle between Read-Write cycles in the same CS space </p>

</div>
</div>
<a id="a995b256efebfa5f8eb6eba5c1f2e2b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b256efebfa5f8eb6eba5c1f2e2b62">&#9670;&nbsp;</a></span>r_w_different_space_idle_cycle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a> bsc_sdram_extended_cfg_t::r_w_different_space_idle_cycle</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Idle cycle between Read-Write cycles in the different CS space </p>

</div>
</div>
<a id="adaf5b9c5313887ca5a789cdcde580cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf5b9c5313887ca5a789cdcde580cdc">&#9670;&nbsp;</a></span>w_r_w_w_idle_cycle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a> bsc_sdram_extended_cfg_t::w_r_w_w_idle_cycle</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Idle cycle between Write-Read cycles and Write-Write cycles </p>

</div>
</div>
<a id="a22c24dbb1c1e0a6a59a4ce11e3ffe0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c24dbb1c1e0a6a59a4ce11e3ffe0c5">&#9670;&nbsp;</a></span>command_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___b_s_c___s_d_r_a_m.html#gada1c0e66f14f9002e9ac5468a5affd07">bsc_sdram_command_t</a> bsc_sdram_extended_cfg_t::command_mode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auto-precharge mode (using READA/WRITA commands) or Bank active mode (using READ/WRIT commands) </p>

</div>
</div>
<a id="abd0499a56f6c17c41e5ab9b3eb2ee760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0499a56f6c17c41e5ab9b3eb2ee760">&#9670;&nbsp;</a></span>p_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*  bsc_sdram_extended_cfg_t::p_callback) (<a class="el" href="group___b_s_c___s_d_r_a_m.html#structbsc__sdram__callback__args__t">bsc_sdram_callback_args_t</a> *p_args)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for SDRAM refresh compare match. </p>

</div>
</div>
<a id="ae509c3fed7a7ac4dd1780a376f841adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae509c3fed7a7ac4dd1780a376f841adc">&#9670;&nbsp;</a></span>p_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const* bsc_sdram_extended_cfg_t::p_context</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for user data. Passed to the user callback in <a class="el" href="group___b_s_c___s_d_r_a_m.html#structbsc__sdram__callback__args__t">bsc_sdram_callback_args_t</a>. </p>

</div>
</div>

</div>
</div>
<a name="structbsc__sdram__instance__ctrl__t" id="structbsc__sdram__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structbsc__sdram__instance__ctrl__t">&#9670;&nbsp;</a></span>bsc_sdram_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct bsc_sdram_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___s_d_r_a_m___a_p_i.html#af0d4fb46dbf4fa8b93de8f292f13189f">sdram_api_t::open</a> is called </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga18786329189e0979c7835a569ac7fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18786329189e0979c7835a569ac7fcb1">&#9670;&nbsp;</a></span>bsc_sdram_chip_select_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga18786329189e0979c7835a569ac7fcb1">bsc_sdram_chip_select_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SDRAM chip select. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga18786329189e0979c7835a569ac7fcb1a1cfbdbb13f78fe524ef586b0942eb953"></a>BSC_SDRAM_CHIP_SELECT_3&#160;</td><td class="fielddoc"><p>Device connected to Chip-Select 3. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga159a39327eab5952ca46895345b624f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga159a39327eab5952ca46895345b624f4">&#9670;&nbsp;</a></span>bsc_sdram_idle_cycle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___b_s_c___s_d_r_a_m.html#ga159a39327eab5952ca46895345b624f4">bsc_sdram_idle_cycle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of insertion idle cycle between access cycles </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4aa05f5ae2e4e4e7cc6c31938aa8d2b225"></a>BSC_SDRAM_IDLE_CYCLE_0&#160;</td><td class="fielddoc"><p>No idle cycle insertion. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4ac85db11369fe3e86f292eeb1d6aab3ba"></a>BSC_SDRAM_IDLE_CYCLE_1&#160;</td><td class="fielddoc"><p>1 idle cycle insertion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4ae9ccd04358d9c3440cb93a6e93c86ddb"></a>BSC_SDRAM_IDLE_CYCLE_2&#160;</td><td class="fielddoc"><p>2 idle cycle insertion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4aaae37b66694f5ec3b2f74b2cf88cf2ef"></a>BSC_SDRAM_IDLE_CYCLE_4&#160;</td><td class="fielddoc"><p>4 idle cycle insertion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4a4dca8577b5f4094650e0b2c98b6aa8ed"></a>BSC_SDRAM_IDLE_CYCLE_6&#160;</td><td class="fielddoc"><p>6 idle cycle insertion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4a0bb49ca612c63f998b818c615926fb7b"></a>BSC_SDRAM_IDLE_CYCLE_8&#160;</td><td class="fielddoc"><p>8 idle cycle insertion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4a9061d036bb3a085bd9ee8c30b770fa4e"></a>BSC_SDRAM_IDLE_CYCLE_10&#160;</td><td class="fielddoc"><p>10 idle cycle insertion </p>
</td></tr>
<tr><td class="fieldname"><a id="gga159a39327eab5952ca46895345b624f4a42d820b65fbfd983dc123f35f50ae838"></a>BSC_SDRAM_IDLE_CYCLE_12&#160;</td><td class="fielddoc"><p>12 idle cycle insertion </p>
</td></tr>
</table>

</div>
</div>
<a id="gada1c0e66f14f9002e9ac5468a5affd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada1c0e66f14f9002e9ac5468a5affd07">&#9670;&nbsp;</a></span>bsc_sdram_command_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___b_s_c___s_d_r_a_m.html#gada1c0e66f14f9002e9ac5468a5affd07">bsc_sdram_command_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify SDRAM command </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2f2e78724073df56351b78425722a8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f2e78724073df56351b78425722a8d9">&#9670;&nbsp;</a></span>R_BSC_SDRAM_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_BSC_SDRAM_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#structsdram__cfg__t">sdram_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the BSC_SDRAM driver module. Configure the BSC and operate the SDRAM initialization. (PALL command is firstly issued. REF command is issued 8 times. MRS command is finally issued.)</p>
<p>User can access to the SDRAM like internal memory starting at address 0x78000000 or 0x58000000.</p>
<dl class="section note"><dt>Note</dt><dd>After the driver is open, Auto-Refresh operation is started.</dd></dl>
<p>Implements <a class="el" href="group___s_d_r_a_m___a_p_i.html#af0d4fb46dbf4fa8b93de8f292f13189f">sdram_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_instance_ctrl or p_cfg is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_CHANNEL</td><td>Invalid Channel. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver has already been opened with the same p_instance_ctrl. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>SDRAM parameter is not available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33f746dccad9ebd1d56524ada849ec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33f746dccad9ebd1d56524ada849ec43">&#9670;&nbsp;</a></span>R_BSC_SDRAM_SelfRefreshEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_BSC_SDRAM_SelfRefreshEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters Self-Refresh mode.</p>
<p>Implements <a class="el" href="group___s_d_r_a_m___a_p_i.html#a9f0995e20936e538c8793d68311f58ad">sdram_api_t::selfRefreshEnter</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when SDRAM is in Power-down mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7aa30d462968c00221b648f82352b0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa30d462968c00221b648f82352b0cb">&#9670;&nbsp;</a></span>R_BSC_SDRAM_SelfRefreshExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_BSC_SDRAM_SelfRefreshExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits Self-Refresh mode. Auto-Refresh operation is re-started to the SDRAM.</p>
<p>Implements <a class="el" href="group___s_d_r_a_m___a_p_i.html#ac3c083bb66ce9c318f2a708adcd1467f">sdram_api_t::selfRefreshExit</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae99f1d77f255dfe64daacebbcbd6b103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae99f1d77f255dfe64daacebbcbd6b103">&#9670;&nbsp;</a></span>R_BSC_SDRAM_PowerDownEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_BSC_SDRAM_PowerDownEnter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enters Power-Down mode.</p>
<p>Implements <a class="el" href="group___s_d_r_a_m___a_p_i.html#a4df7ba804204795dbfc6c9a8d8bdd719">sdram_api_t::powerDownEnter</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when SDRAM is in Self-Refresh mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacd7d6874d39f9d83b4ec87575d7fe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd7d6874d39f9d83b4ec87575d7fe20">&#9670;&nbsp;</a></span>R_BSC_SDRAM_PowerDownExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_BSC_SDRAM_PowerDownExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits Power-Down mode.</p>
<p>Implements <a class="el" href="group___s_d_r_a_m___a_p_i.html#af983e5000f17d8a0ac2a47d79ed465ef">sdram_api_t::powerDownExit</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e095ec54c16c07b189163782461fcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e095ec54c16c07b189163782461fcbc">&#9670;&nbsp;</a></span>R_BSC_SDRAM_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_BSC_SDRAM_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___s_d_r_a_m___a_p_i.html#ga2660baf73e1d3d4305b8b618d85bc48f">sdram_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the BSC_SDRAM driver module.</p>
<p>Implements <a class="el" href="group___s_d_r_a_m___a_p_i.html#a5494ba235e83ab1634e9c2402f15e66e">sdram_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v2.0.0 User's Manual Copyright © (2024) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
