<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZT Flexible Software Package Documentation: PCIE_EP (r_pcie_ep)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZT Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___p_c_i_e___e_p.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">PCIE_EP (r_pcie_ep)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_o_n_n_e_c_t_i_v_i_t_y___m_o_d_u_l_e_s.html">Connectivity</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaae40203e88323684312cc877b3eec1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#gaae40203e88323684312cc877b3eec1cd">R_PCIE_EP_Open</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__cfg__t">pci_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gaae40203e88323684312cc877b3eec1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66785e833534937ae6a0873bcd687151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga66785e833534937ae6a0873bcd687151">R_PCIE_EP_ConfigurationRegisterWrite</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#ga4416af14da0b65e9990414db9e9e7ef3">pci_configuration_write_type_t</a> transaction_type, <a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga66785e833534937ae6a0873bcd687151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16cb10afa6a22db5685dc863682e18f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga16cb10afa6a22db5685dc863682e18f4">R_PCIE_EP_ConfigurationRegisterRead</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#gaf5292151cc185e0b230652e03d785697">pci_configuration_read_type_t</a> transaction_type, <a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga16cb10afa6a22db5685dc863682e18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77c7da365a348d333c50bfb347d6a353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga77c7da365a348d333c50bfb347d6a353">R_PCIE_EP_SelfConfigurationRegisterGet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, uint32_t register_number, uint32_t *p_data)</td></tr>
<tr class="separator:ga77c7da365a348d333c50bfb347d6a353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081dcdce971af61505f8aa09e63a01cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga081dcdce971af61505f8aa09e63a01cf">R_PCIE_EP_SelfConfigurationRegisterSet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, uint32_t register_number, uint32_t data)</td></tr>
<tr class="separator:ga081dcdce971af61505f8aa09e63a01cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e386c410d4aa014027d7da2b392608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga95e386c410d4aa014027d7da2b392608">R_PCIE_EP_IORegisterWrite</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga95e386c410d4aa014027d7da2b392608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a446fa84efd5280a784b0c2455a89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga20a446fa84efd5280a784b0c2455a89b">R_PCIE_EP_IORegisterRead</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga20a446fa84efd5280a784b0c2455a89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf460c96e72ea5f09e1553f4c7c33c64e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#gaf460c96e72ea5f09e1553f4c7c33c64e">R_PCIE_EP_MessageWrite</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const p_transfer, bool with_data)</td></tr>
<tr class="separator:gaf460c96e72ea5f09e1553f4c7c33c64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ffbe668269f3c8fc79dbfcf3825a323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga8ffbe668269f3c8fc79dbfcf3825a323">R_PCIE_EP_MessageRead</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga8ffbe668269f3c8fc79dbfcf3825a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50902be7f74ea3e0e15b86ac862cb41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#gac50902be7f74ea3e0e15b86ac862cb41">R_PCIE_EP_IntxAssert</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gac50902be7f74ea3e0e15b86ac862cb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a6d417536ed4dfdfa60d6101b8870b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#gaa9a6d417536ed4dfdfa60d6101b8870b">R_PCIE_EP_IntxDeassert</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaa9a6d417536ed4dfdfa60d6101b8870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88310295a2ebac80182f3b83a75a8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#gad88310295a2ebac80182f3b83a75a8a7">R_PCIE_EP_LinkStatusGet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__status__t">pci_status_t</a> *const p_status)</td></tr>
<tr class="separator:gad88310295a2ebac80182f3b83a75a8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47596bc657da531c27df9c6171d24535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga47596bc657da531c27df9c6171d24535">R_PCIE_EP_LinkWidthChange</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, uint32_t link_width, uint32_t option)</td></tr>
<tr class="separator:ga47596bc657da531c27df9c6171d24535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366d2b59973e540523c0f6782c43fd6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga366d2b59973e540523c0f6782c43fd6b">R_PCIE_EP_LinkSpeedChange</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#gae98003b04b0361c2f075e0b6cabfa850">pci_link_speed_t</a> link_speed, uint32_t option)</td></tr>
<tr class="separator:ga366d2b59973e540523c0f6782c43fd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362fd626fecc5a84cb7b15b9c4c25eb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga362fd626fecc5a84cb7b15b9c4c25eb9">R_PCIE_EP_LinkEqualizationRequest</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga362fd626fecc5a84cb7b15b9c4c25eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747520921228692db8b08593609710d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga747520921228692db8b08593609710d1">R_PCIE_EP_CallbackSet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga747520921228692db8b08593609710d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3de4a18309de27d563e8e855c004f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#gae3de4a18309de27d563e8e855c004f56">R_PCIE_EP_Close</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gae3de4a18309de27d563e8e855c004f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the PCI peripheral on RZ Microprocessor. This module implements the <a class="el" href="group___p_c_i___a_p_i.html">PCI Interface</a>. </p>
<h1><a class="anchor" id="r-pcie_ep-overview"></a>
Overview</h1>
<p>The PCI Express (PCIE) End Point HAL module supports transactions with an PCIE Root Complex device.</p>
<h2><a class="anchor" id="r-pcie_ep-features"></a>
Features</h2>
<ul>
<li>By accessing the memory space of the RZ Microprocessor, MRd/MWr requests are issued and data is exchanged with the PCIE device.<a class="anchor" id="um_pci_memory_write_request"></a><a class="anchor" id="um_pci_memory_read_request"></a></li>
<li>The following is possible with Msg/MsgD requests.<ul>
<li>Msg/MsgD can be sent/received.<a class="anchor" id="um_pci_message_send"></a><a class="anchor" id="um_pci_message_receive"></a></li>
</ul>
</li>
<li>Can be set to either "1 Lane / 2 Channels" or "2 Lanes / 1 Channel".</li>
<li>Can set its own Configuration Register0, including the Hwinit section, when opened.</li>
<li>Can read/write its own Configuration Register.<a class="anchor" id="um_pci_self_configuration_register_get"></a><a class="anchor" id="um_pci_self_configuration_register_set"></a></li>
<li>Can set BAR, PCIe and AXI window.<a class="anchor" id="um_pci_axi_window_settings"></a><a class="anchor" id="um_pci_pcie_window_settings"></a></li>
<li>INTx interrupts can be issued.<a class="anchor" id="um_pci_assert_deassert_intx"></a></li>
<li>MSI interrupts can be issued.<a class="anchor" id="um_pci_assert_msi"></a></li>
<li>Can get the link status.<a class="anchor" id="um_pci_link_status"></a></li>
<li>Can be notified when a function level reset is received.<a class="anchor" id="um_pci_function_level_reset_notify"></a></li>
<li>Two functions can be set.<a class="anchor" id="um_pci_multi_function"></a></li>
<li>Link width can be dynamically changed and user can be notified.<a class="anchor" id="um_pci_link_width_change"></a></li>
<li>Link Speed can be dynamically changed.<a class="anchor" id="um_pci_link_speed_change"></a></li>
<li>Equalization can be requested. Also, user can be notified when equalization is requested.<a class="anchor" id="um_pci_link_equalization"></a> <a class="anchor" id="um_pci_callback_set"></a> </li>
</ul>
<h1><a class="anchor" id="r-pcie_ep-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_pcie_ep</h2>
The following build time configurations are defined in fsp_cfg/r_pcie_ep_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Link Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
2Lanes / 1Channel</li>
<li>
1Lane / 2Channels</li>
</ul>
</td><td>2Lanes / 1Channel </td><td>Link Mode. </td></tr>
<tr>
<td>Multiplex Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable multiplex interrupt for a single driver. </td></tr>
</table>
 <h2>Configurations for Connectivity &gt; PCI (r_pcie_ep)</h2>
This module can be added to the Stacks tab via New Stack &gt; Connectivity &gt; PCI (r_pcie_ep).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_pci_ep0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Channel</td><td>Channel should be 0 or 1</td><td>0 </td><td>Specify the PCIE channel. </td></tr>
<tr>
<td>General &gt; Function</td><td>Function should be 0 or 1</td><td>0 </td><td>Specify the PCIE EP function. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Vender ID / Device ID &gt; Vender ID</td><td>Manual Entry</td><td>0x0000 </td><td>Vender ID. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Vender ID / Device ID &gt; Device ID</td><td>Manual Entry</td><td>0x0000 </td><td>Device ID. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Command &gt; Memory Space Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Memory Space Enable. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Command &gt; Bus Master Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Bus Master Enable. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Command &gt; Parity Error Response</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Parity Error Response. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Command &gt; SERR# Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>SERR# Enable. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Command &gt; Interrupt Disable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Interrupt Disable. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Revision ID / Class Code &gt; Revision ID</td><td>Manual Entry</td><td>0x00 </td><td>Revision ID. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Revision ID / Class Code &gt; Class Code</td><td>Manual Entry</td><td>0x000 </td><td>Class Code. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; Type</td><td>64bit</td><td>64bit </td><td>Base Address Register 0 / 1 Type. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; Prefetch</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Base Address Register 0 / 1 Prefetch. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; BAR0</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 0. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; BAR1</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 1. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 2 / 3 &gt; Type</td><td>64bit</td><td>64bit </td><td>Base Address Register 2 / 3 Type. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 2 / 3 &gt; Prefetch</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Base Address Register 2 / 3 Prefetch. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 2 / 3 &gt; BAR2</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 2. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 2 / 3 &gt; BAR3</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 3. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 4 / 5 &gt; Type</td><td>64bit</td><td>64bit </td><td>Base Address Register 4 / 5 Type. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 4 / 5 &gt; Prefetch</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Base Address Register 4 / 5 Prefetch. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 4 / 5 &gt; BAR4</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 4. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Base Address Register 4 / 5 &gt; BAR5</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 5. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Subsystem ID &gt; Subsystem Vendor ID</td><td>Manual Entry</td><td>0x0000 </td><td>Subsystem Vendor ID. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Subsystem ID &gt; Subsystem ID</td><td>Manual Entry</td><td>0x0000 </td><td>Subsystem ID. </td></tr>
<tr>
<td>Type 0 Configuration Space Setting &gt; Interrupt Register &gt; Interrupt Pin</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Assert_INTA#</li>
<li>
Assert_INTB#</li>
<li>
Assert_INTC#</li>
<li>
Assert_INTD#</li>
</ul>
</td><td>Assert_INTA# </td><td>Interrupt Pin. </td></tr>
<tr>
<td>Configuration Register Init List &gt; Name</td><td>Name must be a valid C symbol</td><td>g_pci_ep0_configuration_register_init_list </td><td>Configuration Register Init List symbol name. </td></tr>
<tr>
<td>Configuration Register Init List &gt; Length</td><td>The number of configuration register init lists must be a positive integer.</td><td>0 </td><td>Number of Configuration Register Init List. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>AXI Window 0 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 0 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 0 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 0 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 1 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 1 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 1 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 1 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 2 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 2 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 2 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 2 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 3 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 3 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 3 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 3 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 4 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 4 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 4 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 4 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 5 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 5 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 5 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 5 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 6 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 6 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 6 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 6 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 7 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 7 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1y)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 7 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 7 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>PCIe Window 0 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 0 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 0 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 0 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 1 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 1 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 1 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 1 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 2 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 2 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 2 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 2 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 3 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 3 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 3 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 3 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 4 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 4 Base Address The address must be 4Kbyte aligned.. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 4 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 4 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 5 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 5 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 5 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 5 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 6 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 6 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 6 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 6 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 7 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 7 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 7 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 7 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Event Interrupt Sources &gt; Event 0</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
DL_UpDown</li>
<li>
ASPM L1 Rejected</li>
<li>
RX_DLLP_PM_ENTER_L23</li>
<li>
Enable BME Parity Error Interrupt</li>
<li>
CA (Completer Abort)</li>
<li>
Enable AXIM RAM Parity Error Interrupt</li>
<li>
Request Complete</li>
<li>
Speed change operation completion</li>
<li>
Up/Down Configure operation complete</li>
</ul>
</td><td>0U </td><td>Select which event should trigger an Event interrupt. </td></tr>
<tr>
<td>PCIe Event Interrupt Sources &gt; Event 1</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
ERR_REPLAY_LOWER_UNCORRECTABLE_ERROR</li>
<li>
ERR_REPLAY_UPPER_UNCORRECTABLE_ERROR</li>
<li>
ERR_REPLAY_LOWER_CORRECTABLE_ERROR</li>
<li>
ERR_REPLAY_UPPER_CORRECTABLE_ERROR</li>
<li>
ERR_RPC_REPLAYFIFO_PERR</li>
<li>
TXB_PARITY_ERR</li>
</ul>
</td><td>0U </td><td>Select which event should trigger an Event interrupt. </td></tr>
<tr>
<td>PCIe Event Interrupt Sources &gt; Event 2</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
D3_hot_err_EN</li>
<li>
The ability to detect changes in CFG_LTR_MECHANISM</li>
</ul>
</td><td>0U </td><td>Select which event should trigger an Event interrupt. </td></tr>
<tr>
<td>Interrupt &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR). </td></tr>
<tr>
<td>Interrupt &gt; Function Level Reset (FLR) Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Function Level Reset (FLR) Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Message Receive Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Message Receive Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; EVENT Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>EVENT Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Non-D0 State transition receive Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Non-D0 State transition receive Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Power OFF Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Power OFF Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; PME_Turn_Off Message Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>PME_Turn_Off Message Interrupt Priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-pcie_ep-clock-configuration"></a>
Clock Configuration</h2>
<p>There is no clock configuration for the PCIe module.</p>
<h2><a class="anchor" id="r-pcie_ep-pin-configuration"></a>
Pin Configuration</h2>
<p>The following pins are available to connect to an external PCIe device:</p><ul>
<li>PCIE_REFCLK_P0: Ch0 Reference clock input (Positive)</li>
<li>PCIE_REFCLK_N0: Ch0 Reference clock input (Negative)</li>
<li>PCIE_REFCLK_P1: Ch1 Reference clock input (Positive)</li>
<li>PCIE_REFCLK_N1: Ch1 Reference clock input (Negative)</li>
<li>PCIE_RXDP_L0: Serial data input 0 (Positive)</li>
<li>PCIE_RXDN_L0: Serial data input 0 (Negative)</li>
<li>PCIE_RXDP_L1: Serial data input 1 (Positive)</li>
<li>PCIE_RXDN_L1: Serial data input 1 (Negative)</li>
<li>PCIE_TXDP_L0: Serial data output 0 (Positive)</li>
<li>PCIE_TXDN_L0: Serial data output 0 (Negative)</li>
<li>PCIE_TXDP_L1: Serial data output 1 (Positive)</li>
<li>PCIE_TXDN_L1: Serial data output 1 (Negative)</li>
<li>PCIE_RSTOUT0B: PCIE Reset output ch0 for Root Complex</li>
<li>PCIE_RSTOUT1B: PCIE Reset output ch1 for Root Complex</li>
</ul>
<h1><a class="anchor" id="r-pcie_ep-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-pcie_ep-configuration-register"></a>
Configuration Register</h2>
<h3><a class="anchor" id="r-pcie_ep-list-of-configuration-register"></a>
List of Configuration Register</h3>
<p>PCIE Configuration registers are accessed by other PCIe devices or by itself. The PCIE peripehral of RZ microprocessor supports the following configuration registers:</p>
<table class="doxtable">
<tr>
<th>Address Offset </th><th>Register Number </th><th>Register symbol </th><th>Register name  </th></tr>
<tr>
<td>0x000 </td><td>0 </td><td>PCI_EP_VID_Fi </td><td>Vendor and Device ID Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x004 </td><td>1 </td><td>PCI_EP_COM_STA_Fi </td><td>Command and Status Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x008 </td><td>2 </td><td>PCI_EP_RID_CC_Fi </td><td>Revision ID and Class Code Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x00C </td><td>3 </td><td>PCI_EP_CL_HT_Fi </td><td>Cache Line and Header Type Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x010 </td><td>4 </td><td>PCI_EP_BAR0_Fi </td><td>Base Address Register 0 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x014 </td><td>5 </td><td>PCI_EP_BAR1_Fi </td><td>Base Address Register 1 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x018 </td><td>6 </td><td>PCI_EP_BAR2_Fi </td><td>Base Address Register 2 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x01C </td><td>7 </td><td>PCI_EP_BAR3_Fi </td><td>Base Address Register 3 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x020 </td><td>8 </td><td>PCI_EP_BAR4_Fi </td><td>Base Address Register 4 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x024 </td><td>9 </td><td>PCI_EP_BAR5_Fi </td><td>Base Address Register 5 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x02C </td><td>11 </td><td>PCI_EP_SUBSID_Fi </td><td>Subsystem ID Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x034 </td><td>13 </td><td>PCI_EP_CP_Fi </td><td>Capabilities Pointer Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x03C </td><td>15 </td><td>PCI_EP_INT_Fi </td><td>Interrupt Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x040 </td><td>16 </td><td>PCI_EP_PMC_Fi </td><td>PM Capabilities Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x044 </td><td>17 </td><td>PCI_EP_PMSC_Fi </td><td>PM Status/Control Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x060 </td><td>24 </td><td>PCI_EP_PCIEC_Fi </td><td>PCI Express Capability Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x064 </td><td>25 </td><td>PCI_EP_DEVC_Fi </td><td>Device Capabilities Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x068 </td><td>26 </td><td>PCI_EP_DEVCS_Fi </td><td>Device Control/Status Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x06C </td><td>27 </td><td>PCI_EP_LINKC_Fi </td><td>Link Capabilities Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x070 </td><td>28 </td><td>PCI_EP_LINKCS_Fi </td><td>Link Control/Status Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x084 </td><td>33 </td><td>PCI_EP_DEVC2_Fi </td><td>Device Capabilities 2 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x088 </td><td>34 </td><td>PCI_EP_DEVCS2_Fi </td><td>Device Control 2/Status 2 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x08C </td><td>35 </td><td>PCI_EP_LINKC2_Fi </td><td>Link Capabilities 2 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x090 </td><td>36 </td><td>PCI_EP_LINCS2_Fi </td><td>Link Control 2/Status 2 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0A0 </td><td>40 </td><td>PCI_EP_BARMSK00L_Fi </td><td>Base Address Register Mask00 (Lower) Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0A4 </td><td>41 </td><td>PCI_EP_BARMSK00U_Fi </td><td>Base Address Register Mask00 (Upper) Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0A8 </td><td>42 </td><td>PCI_EP_BARMSK01L_Fi </td><td>Base Address Register Mask01 (Lower) Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0AC </td><td>43 </td><td>PCI_EP_BARMSK01U_Fi </td><td>Base Address Register Mask01 (Upper) Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0B0 </td><td>44 </td><td>PCI_EP_BARMSK02L_Fi </td><td>Base Address Register Mask02 (Lower) Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0B4 </td><td>45 </td><td>PCI_EP_BARMSK02U_Fi </td><td>Base Address Register Mask02 (Upper) Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0C8 </td><td>50 </td><td>PCI_EP_BSIZE00_01_Fi </td><td>Base Size 00/01 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0CC </td><td>51 </td><td>PCI_EP_BSIZE02_03_Fi </td><td>Base Size 02/03 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0D0 </td><td>52 </td><td>PCI_EP_BSIZE04_05_Fi </td><td>Base Size 04/05 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0D4 </td><td>53 </td><td>PCI_EP_BSIZE06_Fi </td><td>Base Size 06 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0D8 </td><td>54 </td><td>PCI_EP_TSUPPORT00_01_02_Fi </td><td>Type Supported 00/01/02 Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0E0 </td><td>56 </td><td>PCI_EP_MSICAP_Fi </td><td>MSI Capability Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0E4 </td><td>57 </td><td>PCI_EP_MSGADR_Fi </td><td>Message Address Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0E8 </td><td>58 </td><td>PCI_EP_MSGUADR_Fi </td><td>Message Upper Address Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0EC </td><td>59 </td><td>PCI_EP_MSGDAT_Fi </td><td>Message Data Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0F0 </td><td>60 </td><td>PCI_EP_MSKBIT_Fi </td><td>Mask Bits Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x0F4 </td><td>61 </td><td>PCI_EP_PENDBIT_Fi </td><td>Pending Bits Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x100 </td><td>64 </td><td>PCI_EP_ADVERC_Fi </td><td>Advanced Error Reporting Capability Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x104 </td><td>65 </td><td>PCI_EP_UNCESTS_Fi </td><td>Uncorrectable Error Status Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x108 </td><td>66 </td><td>PCI_EP_UNCEMASK_Fi </td><td>Uncorrectable Error Mask Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x10C </td><td>67 </td><td>PCI_EP_UNCESVY_Fi </td><td>Uncorrectable Error Severity Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x110 </td><td>68 </td><td>PCI_EP_CESTS_Fi </td><td>Correctable Error Status Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x114 </td><td>69 </td><td>PCI_EP_CEMASK_Fi </td><td>Correctable Error Mask Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x118 </td><td>70 </td><td>PCI_EP_ADVECC_Fi </td><td>Advanced Error Capabilities and Control Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x11C </td><td>71 </td><td>PCI_EP_HLOG0_Fi </td><td>Header Log Register 0 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x120 </td><td>72 </td><td>PCI_EP_HLOG1_Fi </td><td>Header Log Register 1 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x124 </td><td>73 </td><td>PCI_EP_HLOG2_Fi </td><td>Header Log Register 2 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x128 </td><td>74 </td><td>PCI_EP_HLOG3_Fi </td><td>Header Log Register 3 (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x150 </td><td>84 </td><td>PCI_EP_DEVSNEXTC_Fi </td><td>Device Serial Number Extended Capability Register (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x154 </td><td>85 </td><td>PCI_EP_SNL_Fi </td><td>Serial Number Register (Lower DW) (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x158 </td><td>86 </td><td>PCI_EP_SNU_Fi </td><td>Serial Number Register (Upper DW) (Function #i) (i = 0, 1) </td></tr>
<tr>
<td>0x1B0 </td><td>108 </td><td>PCI_EP_SPEECH_F0 </td><td>Secondary PCI Express Extended Capability Header Register (Function #0) </td></tr>
<tr>
<td>0x1B4 </td><td>109 </td><td>PCI_EP_LINC3_F0 </td><td>Link Control 3 Register (Function #0) </td></tr>
<tr>
<td>0x1B8 </td><td>110 </td><td>PCI_EP_LESTA_F0 </td><td>Lane Error Status Register (Function #0) </td></tr>
<tr>
<td>0x1BC </td><td>111 </td><td>PCI_EP_LEQCTI_F0 </td><td>Lane Equalization Control Register (Function #0) </td></tr>
</table>
<h3><a class="anchor" id="r-pcie_ep-initialization-of-configuration-register"></a>
Initializaiton of Configuration Register</h3>
<p>The PCIE_EP driver initializes the configuration register. Users can set the PCI compatible configuration registers up to address 0x40 using the FSP Configuration editor, and the configuration registers above address 0x40 can be set by setting pci_ep_configuration_register_init_t structure. The default template with one entry is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group___p_c_i___a_p_i.html#structpci__configuration__register__init__t">pci_configuration_register_init_t</a> g_pci_ep0_configuration_register_init_list[PCIE_EP_CH0_F0_CONFIG_REG_INIT_LIST_NUM] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        <span class="comment">/* Specify Register number.*/</span></div><div class="line">        .<a class="code" href="group___p_c_i___a_p_i.html#a301b19136279db1b1d1567aefbe1aae9">register_number</a> = 0x044 / 4,</div><div class="line"></div><div class="line">        <span class="comment">/* Value to be set in configuration register. */</span></div><div class="line">        .init_value      = 0x00000100,</div><div class="line"></div><div class="line">        <span class="comment">/* Mask setting for values when setting configuration registers. */</span></div><div class="line">        .init_value_mask = R_PCIE0_PCI_EP_PMSC_F0_PMEE_Msk,</div><div class="line">    },</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="r-pcie_ep-access-of-configureation-register"></a>
Access of Configuration Register</h3>
<p>The PCIE_EP driver provides an API to access the own configuration space. Use <a class="el" href="group___p_c_i_e___e_p.html#ga081dcdce971af61505f8aa09e63a01cf">R_PCIE_EP_SelfConfigurationRegisterSet</a> or <a class="el" href="group___p_c_i_e___e_p.html#ga77c7da365a348d333c50bfb347d6a353">R_PCIE_EP_SelfConfigurationRegisterGet</a> to access the configuration space of PCIe peripheral of this RZ Microprocessor.</p>
<h2><a class="anchor" id="r_pcie_ep-axi-window-settings"></a>
AXI Window settings (PCIe to AXI)</h2>
<p>The AXI Window settings are used when MWr/MRd data from PCI Express is transferred to AXI bus (Data Receive operation via MWr/MRd request). Set AXI Window Base and AXI Window Mask in the BAR region. (BAR: PCI Express Configuration Register, Base Address Register)</p>
<p>AXI access address is shown as below.</p>
<p>AXI Access Address = PCIe Access Address - BAR0 - AXI Window Base + AXI Window Destination</p>
<h3><a class="anchor" id="r_pcie_ep-example-of-axi-window-settings"></a>
Example of AXI Window settings</h3>
<table class="doxtable">
<tr>
<th>Element </th><th>Setting Value </th><th>Settings  </th></tr>
<tr>
<td>BAR0 </td><td>0x0000_0000_1000_0000 </td><td>Configuration Register "PCI_EP_BAR0_Fi"/"PCI_EP_BAR1_Fi". Can be set by Stack Configuration. </td></tr>
<tr>
<td>BAR Mask0 </td><td>0x0000_0000_0FFF_FFFC </td><td>Configuration Register "PCI_EP_BARMSK00L_Fi"/"PCI_EP_BARMSK00U_Fi". </td></tr>
<tr>
<td>AXI Window Base </td><td>0x0000_0000_0010_0000 </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>AXI Window Mask </td><td>0x0000_0000_0003_FFFF </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>AXI Window Destination </td><td>0x0000_0004_0100_0000 </td><td>Can be set by Stack Configuration. </td></tr>
</table>
<p>BAR0 Assigned region : 0x0000_0000_1000_0000 to 0x0000_0000_1FFF_FFFF (256 MB)</p>
<p>AXI Window region : 0x0000_0004_0100_0000 to 0x0000_0004_0103_FFFF (256 KB)</p>
<p>Up to four AXI windows can be configured in each BAR area. Setting examples of AXI windows allocated to each of the BAR areas is as follows:</p>
<table class="doxtable">
<tr>
<th>BAR (Memory space) </th><th>Setting example 1 </th><th>Setting example 2 </th><th>Setting example 3 </th><th>Setting example 4  </th></tr>
<tr>
<td>64bit memory space (1) (BAR1,BAR0) </td><td>AXI Window 0, AXI Window 1, AXI Window 2, AXI Window 3 </td><td>AXI Window 0, AXI Window 1, AXI Window 2 </td><td>AXI Window 0, AXI Window 1 </td><td>AXI Window 0 </td></tr>
</table>
<table class="doxtable">
<tr>
<th>BAR (Memory space) </th><th>Setting example 1 </th><th>Setting example 2 </th><th>Setting example 3 </th><th>Setting example 4  </th></tr>
<tr>
<td>64bit memory space (2) (BAR3,BAR2) </td><td>AXI Window 4, AXI Window 5, AXI Window 6, AXI Window 7 </td><td>AXI Window 4, AXI Window 5, AXI Window 6 </td><td>AXI Window 4, AXI Window 5 </td><td>AXI Window 4 </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>When configuring the AXI window in the FSP configuration editor, note the following conditions:<ul>
<li>For the AXI Window Base Address setting, the address must be 4Kbyte aligned.</li>
<li>For the AXI Window Mask setting, the lower 12 bits must be 1, and must be set 1 from the lowest bit. In addition, the 63rd bit must be 0.</li>
<li>For the AXI Window Destination Address setting, the address must be 4Kbyte aligned.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="r_pcie_ep-pcie-window-settings"></a>
PCIe Window settings (AXI to PCIe)</h2>
<p>PCIe Window settings are used when MWr/MRd data from AXI bus is transferred to PCI Express (Data Transmit operation via MWr/MRd request).</p>
<p>PCIe access address is shown as below.</p>
<p>PCIe Access Address = AXI Access Address - PCIe Window Base + PCIe Window Destination</p>
<h3><a class="anchor" id="r_pcie_ep-example-of-pcie-window-settings"></a>
Example of PCIe Window settings</h3>
<table class="doxtable">
<tr>
<th>Element </th><th>Setting Value </th><th>Settings  </th></tr>
<tr>
<td>BAR0 </td><td>0x0000_0000_1000_0000 </td><td>Configuration Register "PCI_EP_BAR0_Fi"/"PCI_EP_BAR1_Fi". Can be set by Stack Configuration. </td></tr>
<tr>
<td>BAR Mask0 </td><td>0x0000_0000_07FF_FFFC </td><td>Configuration Register "PCI_EP_BARMSK00L_Fi"/"PCI_EP_BARMSK00U_Fi". </td></tr>
<tr>
<td>PCIe Window Base </td><td>0x0000_0000_0070_0000 </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>PCIe Window Mask </td><td>0x0000_0000_000F_FFFF </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>PCIe Window Destination </td><td>0x0000_0004_0070_0000 </td><td>Can be set by Stack Configuration. </td></tr>
</table>
<p>BAR0 Assigned region : 0x0000_0000_1000_0000 to 0x0000_0000_17FF_FFFF (128 MB)</p>
<p>PCIe Window region : 0x0070_0000 to 0x007F_FFFF (1 MB)</p>
<dl class="section warning"><dt>Warning</dt><dd>When configuring the PCIe window in the FSP configuration editor, note the following conditions:<ul>
<li>For the PCIe Window Base Address setting, the address must be 4Kbyte aligned.</li>
<li>For the PCIe Window Mask setting, the lower 12 bits must be 1, and must be set 1 from the lowest bit. In addition, the 63rd bit must be 0.</li>
<li>For the PCIe Window Destination Address setting, the address must be 4Kbyte aligned.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="r_pcie_ep-address-expander"></a>
Address Expander</h2>
<p>Using the PCIE_EP HAL driver, other PCIe devices can be accessed through PCIEn space (8GB) or through PCIEn mirror space (256MB) (n=0,1). In particular, if the bus master supports 32-bit address space only, PCIEn space must be accessed through PCIEn mirror space. When using the mirror space, the address expander setting must first be configured in the BSP configuration. Consult Section "Address Expander" in the RZ microprocessor User's Manual for details.</p>
<h2><a class="anchor" id="r-pcie_ep-limitations"></a>
Limitations</h2>
<h1><a class="anchor" id="r-pcie_ep-examples"></a>
Examples</h1>
<h2>Configuration Space (above address 0x40) Initialization Example</h2>
<p>The below is an example of configuration space initialization.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="group___p_c_i___a_p_i.html#structpci__configuration__register__init__t">pci_configuration_register_init_t</a> p_pcie_cfg_reg_init[PCIE_CONFIGURATION_REGISTER_INIT_NUM] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___p_c_i___a_p_i.html#a301b19136279db1b1d1567aefbe1aae9">register_number</a> = 0x044 / 4,  <span class="comment">/* PM Status/Control Register number */</span></div><div class="line">        .init_value      = 0x00000100, <span class="comment">/* PMEE = 1 : PME Enable */</span></div><div class="line">        .init_value_mask = R_PCIE0_PCI_EP_PMSC_F0_PMEE_Msk,</div><div class="line">    },</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <h2>Basic Example</h2>
<p>This is a basic example of minimal use of the PCIE_EP module in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> pcie_ep_example ()</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Open PCIE module */</span></div><div class="line">    err = <a class="code" href="group___p_c_i_e___e_p.html#gaae40203e88323684312cc877b3eec1cd">R_PCIE_EP_Open</a>(&amp;g_pci0_ctrl, &amp;g_pci0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for link training from the RC side */</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structpcie__ep__window__settings__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#structpcie__ep__window__settings__t">pcie_ep_window_settings_t</a></td></tr>
<tr class="separator:structpcie__ep__window__settings__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpcie__ep__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#structpcie__ep__instance__ctrl__t">pcie_ep_instance_ctrl_t</a></td></tr>
<tr class="separator:structpcie__ep__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpcie__ep__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#structpcie__ep__extended__cfg__t">pcie_ep_extended_cfg_t</a></td></tr>
<tr class="separator:structpcie__ep__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1828593cbcfdeb2074a1a6453f503495"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___e_p.html#ga1828593cbcfdeb2074a1a6453f503495">pcie_ep_link_mode_t</a> </td></tr>
<tr class="separator:ga1828593cbcfdeb2074a1a6453f503495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structpcie__ep__window__settings__t" id="structpcie__ep__window__settings__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__ep__window__settings__t">&#9670;&nbsp;</a></span>pcie_ep_window_settings_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_ep_window_settings_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>AXI/PCIe window setting structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a408e0d69a135aadbe1f741131dcd4c39"></a>uint64_t</td>
<td class="fieldname">
base_address</td>
<td class="fielddoc">
AXI/PCIe Window Base address. </td></tr>
<tr><td class="fieldtype">
<a id="abac6c8f2a66184daa4ab4626191ad7f9"></a>uint64_t</td>
<td class="fieldname">
mask_address</td>
<td class="fielddoc">
AXI/PCIe Window Mask address. </td></tr>
<tr><td class="fieldtype">
<a id="a864414d555eca5cbc2e6e73a907e5fc4"></a>uint64_t</td>
<td class="fieldname">
destination_address</td>
<td class="fielddoc">
AXI/PCIe Destination address. </td></tr>
<tr><td class="fieldtype">
<a id="aaf494e943a50d46fea1d50b79fea54c7"></a>bool</td>
<td class="fieldname">
window_enable</td>
<td class="fielddoc">
AXI/PCIe Window setting Enable/Disable. </td></tr>
</table>

</div>
</div>
<a name="structpcie__ep__instance__ctrl__t" id="structpcie__ep__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__ep__instance__ctrl__t">&#9670;&nbsp;</a></span>pcie_ep_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_ep_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Driver instance control structure. </p>
</div>
</div>
</div>
<a name="structpcie__ep__extended__cfg__t" id="structpcie__ep__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__ep__extended__cfg__t">&#9670;&nbsp;</a></span>pcie_ep_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_ep_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>PCIE_EP extension data structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a52c8d0b9ba8378fea824fb26535f0e28"></a><a class="el" href="group___p_c_i_e___e_p.html#ga1828593cbcfdeb2074a1a6453f503495">pcie_ep_link_mode_t</a></td>
<td class="fieldname">
link_mode</td>
<td class="fielddoc">
PCI Express Link mode. </td></tr>
<tr><td class="fieldtype">
<a id="ac395800c04567e1f17c53607c03db44f"></a><a class="el" href="group___p_c_i_e___e_p.html#structpcie__ep__window__settings__t">pcie_ep_window_settings_t</a></td>
<td class="fieldname">
axi_window_settings[R_PCIE_EP_NUM_AXI_WINDOW]</td>
<td class="fielddoc">
Settings the AXI Window (PCIe to AXI) </td></tr>
<tr><td class="fieldtype">
<a id="a2e257b985cf716d3e0fd37980b5490cd"></a><a class="el" href="group___p_c_i_e___e_p.html#structpcie__ep__window__settings__t">pcie_ep_window_settings_t</a></td>
<td class="fieldname">
pci_window_settings[R_PCIE_EP_NUM_PCIE_WINDOW]</td>
<td class="fielddoc">
Settings the PCIe Window (AXI to PCIe) </td></tr>
<tr><td class="fieldtype">
<a id="acad74a652f225a3df413f759b61c75b1"></a>uint32_t</td>
<td class="fieldname">
event0_interrupts</td>
<td class="fielddoc">
Event0 interrupt enable bits. </td></tr>
<tr><td class="fieldtype">
<a id="a49cbcd1938c1c4e385d1781624172786"></a>uint32_t</td>
<td class="fieldname">
event1_interrupts</td>
<td class="fielddoc">
Event1 interrupt enable bits. </td></tr>
<tr><td class="fieldtype">
<a id="a7568c0c3e878ca074734704a07273b33"></a>uint32_t</td>
<td class="fieldname">
event2_interrupts</td>
<td class="fielddoc">
Event2 interrupt enable bits. </td></tr>
<tr><td class="fieldtype">
<a id="a0b4f56128b016b4afac5a08cacb0f790"></a>IRQn_Type</td>
<td class="fieldname">
msg_irq</td>
<td class="fielddoc">
PCI Express Message Receive Interrupt Number. </td></tr>
<tr><td class="fieldtype">
<a id="a031ea47cf7324395d218349ce6aec272"></a>uint8_t</td>
<td class="fieldname">
msg_ipl</td>
<td class="fielddoc">
PCI Express Message Receive Interrupt Priority. </td></tr>
<tr><td class="fieldtype">
<a id="a0e052480906d6ee725c4ec41b92fc0a7"></a>IRQn_Type</td>
<td class="fieldname">
flr_irq</td>
<td class="fielddoc">
Function Level Reset Interrupt Number. </td></tr>
<tr><td class="fieldtype">
<a id="a6e6ac6499f1504ac05770cdb44b107d5"></a>uint8_t</td>
<td class="fieldname">
flr_ipl</td>
<td class="fielddoc">
Function Level Reset Interrupt Priority. </td></tr>
<tr><td class="fieldtype">
<a id="aca864a58d62c7ab2b3534c3ddae902a4"></a>IRQn_Type</td>
<td class="fieldname">
d3_event_irq</td>
<td class="fielddoc">
Non-D0 State transition request receive output interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a9c9d94b2df53f0d0fa6d6df4e7fad17c"></a>uint8_t</td>
<td class="fieldname">
d3_event_ipl</td>
<td class="fielddoc">
Non-D0 State transition request receive output interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="a45381c02ca9e264e6f172c21c53a1c2e"></a>IRQn_Type</td>
<td class="fieldname">
pme_turn_off_rcv_irq</td>
<td class="fielddoc">
PME_Turn_Off Message receive interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a9ecab8cb41908759bfdb8de090907045"></a>uint8_t</td>
<td class="fieldname">
pme_turn_off_rcv_ipl</td>
<td class="fielddoc">
PME_Turn_Off Message receive interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="af25baee5219a576e163457cc7a8464b9"></a>IRQn_Type</td>
<td class="fieldname">
poweroff_indication_l2_irq</td>
<td class="fielddoc">
POWEROFF indication on L2 interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a375c7fab172e99c29f52546bf0efff6a"></a>uint8_t</td>
<td class="fieldname">
poweroff_indication_l2_ipl</td>
<td class="fielddoc">
POWEROFF indication on L2 interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="ac364763841a91c03d38dc30147fa2780"></a>IRQn_Type</td>
<td class="fieldname">
pcie_event_irq</td>
<td class="fielddoc">
Event Interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="aab684aaf9019e1832bb5daac3753ef8d"></a>uint8_t</td>
<td class="fieldname">
pcie_event_ipl</td>
<td class="fielddoc">
Event Interrupt priority. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1828593cbcfdeb2074a1a6453f503495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1828593cbcfdeb2074a1a6453f503495">&#9670;&nbsp;</a></span>pcie_ep_link_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___p_c_i_e___e_p.html#ga1828593cbcfdeb2074a1a6453f503495">pcie_ep_link_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PCI Express Link Mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1828593cbcfdeb2074a1a6453f503495a6a221f7a7c657ceeabce0c5db2386919"></a>PCIE_EP_LINK_MODE_2LANE_1CHANNEL&#160;</td><td class="fielddoc"><p>PCIe 2 lanes x 1 channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1828593cbcfdeb2074a1a6453f503495a12b2087f952ba387fec61a5ed7d7f6a8"></a>PCIE_EP_LINK_MODE_1LANE_2CHANNEL&#160;</td><td class="fielddoc"><p>PCIe 1 lane x 2 channels. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaae40203e88323684312cc877b3eec1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae40203e88323684312cc877b3eec1cd">&#9670;&nbsp;</a></span>R_PCIE_EP_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__cfg__t">pci_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the PCIE_EP API. Implements <a class="el" href="group___p_c_i___a_p_i.html#a79cbaa0de489936dfe4a4567ad2e11f1">pci_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>PCIE_EP successfully initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Invalid input argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66785e833534937ae6a0873bcd687151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66785e833534937ae6a0873bcd687151">&#9670;&nbsp;</a></span>R_PCIE_EP_ConfigurationRegisterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_ConfigurationRegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga4416af14da0b65e9990414db9e9e7ef3">pci_configuration_write_type_t</a>&#160;</td>
          <td class="paramname"><em>transaction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing CfgWr0/1 Request. API not supported. Implements <a class="el" href="group___p_c_i___a_p_i.html#a3e27535ff515e7f225147718b6192660">pci_api_t::configurationRegisterWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_EP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16cb10afa6a22db5685dc863682e18f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16cb10afa6a22db5685dc863682e18f4">&#9670;&nbsp;</a></span>R_PCIE_EP_ConfigurationRegisterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_ConfigurationRegisterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#gaf5292151cc185e0b230652e03d785697">pci_configuration_read_type_t</a>&#160;</td>
          <td class="paramname"><em>transaction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing CfgRd0/1 Request. API not supported. Implements <a class="el" href="group___p_c_i___a_p_i.html#a9aa57739805e24dbf9468db1168d1166">pci_api_t::configurationRegisterRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_EP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77c7da365a348d333c50bfb347d6a353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77c7da365a348d333c50bfb347d6a353">&#9670;&nbsp;</a></span>R_PCIE_EP_SelfConfigurationRegisterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_SelfConfigurationRegisterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read message data from PCI. Implements <a class="el" href="group___p_c_i___a_p_i.html#ac29888aa807bc3da902467d5ad4fffe3">pci_api_t::messageRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga081dcdce971af61505f8aa09e63a01cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081dcdce971af61505f8aa09e63a01cf">&#9670;&nbsp;</a></span>R_PCIE_EP_SelfConfigurationRegisterSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_SelfConfigurationRegisterSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the value of configuration register of this PCIE device. Implements <a class="el" href="group___p_c_i___a_p_i.html#aaaced4e67f1d55c0a467a58839bab457">pci_api_t::selfConfigurationRegisterSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95e386c410d4aa014027d7da2b392608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e386c410d4aa014027d7da2b392608">&#9670;&nbsp;</a></span>R_PCIE_EP_IORegisterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_IORegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing IOWr Request. API not supported. Implements <a class="el" href="group___p_c_i___a_p_i.html#ad3f4efb2160b728f9bdafe12e4427b6c">pci_api_t::iORegisterWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_EP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20a446fa84efd5280a784b0c2455a89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a446fa84efd5280a784b0c2455a89b">&#9670;&nbsp;</a></span>R_PCIE_EP_IORegisterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_IORegisterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing IORd Request. API not supported. Implements <a class="el" href="group___p_c_i___a_p_i.html#ae643638be50e3227ecc905f8518a9f9d">pci_api_t::iORegisterRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_EP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf460c96e72ea5f09e1553f4c7c33c64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf460c96e72ea5f09e1553f4c7c33c64e">&#9670;&nbsp;</a></span>R_PCIE_EP_MessageWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_MessageWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing Msg/MsgD Request. Implements <a class="el" href="group___p_c_i___a_p_i.html#a28ced4f2ee19d75d42e6850ca6ffc827">pci_api_t::messageWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The message was issued successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ffbe668269f3c8fc79dbfcf3825a323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ffbe668269f3c8fc79dbfcf3825a323">&#9670;&nbsp;</a></span>R_PCIE_EP_MessageRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_MessageRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read message data from PCI. Implements <a class="el" href="group___p_c_i___a_p_i.html#ac29888aa807bc3da902467d5ad4fffe3">pci_api_t::messageRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The message was read successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac50902be7f74ea3e0e15b86ac862cb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50902be7f74ea3e0e15b86ac862cb41">&#9670;&nbsp;</a></span>R_PCIE_EP_IntxAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_IntxAssert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assert INTx interrupt Request. Either INTA - INTD set by configuration register is asserted.</p>
<p>Implements <a class="el" href="group___p_c_i___a_p_i.html#a417431a426e07a808425895459c6587b">pci_api_t::intxAssert</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The INTx assert is success. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when MSI is enabled (MSIE bit in MSI Capability Register equals to 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9a6d417536ed4dfdfa60d6101b8870b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9a6d417536ed4dfdfa60d6101b8870b">&#9670;&nbsp;</a></span>R_PCIE_EP_IntxDeassert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_IntxDeassert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deassert INTx interrupt Request. Either INTA - INTD set by configuration register is deasserted.</p>
<p>Implements <a class="el" href="group___p_c_i___a_p_i.html#ad6d5bc97a21acf537238b89084fb1f47">pci_api_t::intxDeassert</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The INTx deassert is success. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_MODE</td><td>This function can't be called when MSI is enabled (MSIE bit in MSI Capability Register equals to 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad88310295a2ebac80182f3b83a75a8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88310295a2ebac80182f3b83a75a8a7">&#9670;&nbsp;</a></span>R_PCIE_EP_LinkStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_LinkStatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__status__t">pci_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the Link status and LTSSM state. Implements <a class="el" href="group___p_c_i___a_p_i.html#a605d81e55617fecf03ee543b640688c0">pci_api_t::linkStatusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The PCI status is in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47596bc657da531c27df9c6171d24535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47596bc657da531c27df9c6171d24535">&#9670;&nbsp;</a></span>R_PCIE_EP_LinkWidthChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_LinkWidthChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>link_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the PCI Express link width. Implements <a class="el" href="group___p_c_i___a_p_i.html#aa3fb300545618e863893df76ddc5c6b5">pci_api_t::linkWidthChange</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Required link width is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Link Width change was not done in time and timeout occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga366d2b59973e540523c0f6782c43fd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga366d2b59973e540523c0f6782c43fd6b">&#9670;&nbsp;</a></span>R_PCIE_EP_LinkSpeedChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_LinkSpeedChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#gae98003b04b0361c2f075e0b6cabfa850">pci_link_speed_t</a>&#160;</td>
          <td class="paramname"><em>link_speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the PCI Express link speed. Implements <a class="el" href="group___p_c_i___a_p_i.html#aba141c65f1a1735fe7807c6b2c72784a">pci_api_t::linkSpeedChange</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Required link speed is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Link speed change was not done in time and timeout occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga362fd626fecc5a84cb7b15b9c4c25eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga362fd626fecc5a84cb7b15b9c4c25eb9">&#9670;&nbsp;</a></span>R_PCIE_EP_LinkEqualizationRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_LinkEqualizationRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires the PCI Express link equalization request. Implements <a class="el" href="group___p_c_i___a_p_i.html#ace6807efb7c96559f56607f3a7b9cf97">pci_api_t::linkEqualizationRequest</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Link Equalization was not done in time and timeout occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga747520921228692db8b08593609710d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747520921228692db8b08593609710d1">&#9670;&nbsp;</a></span>R_PCIE_EP_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___p_c_i___a_p_i.html#a8d751a4ca5bfb0c1afa05508ed68d15a">pci_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3de4a18309de27d563e8e855c004f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3de4a18309de27d563e8e855c004f56">&#9670;&nbsp;</a></span>R_PCIE_EP_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_EP_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the PCIE_EP module. Implements <a class="el" href="group___p_c_i___a_p_i.html#abe39a28509a18a203786dab85062b932">pci_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The module is successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Invalid input argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
