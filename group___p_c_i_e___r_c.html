<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZT Flexible Software Package Documentation: PCIE_RC (r_pcie_rc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZT Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v2.3.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___p_c_i_e___r_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">PCIE_RC (r_pcie_rc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___c_o_n_n_e_c_t_i_v_i_t_y___m_o_d_u_l_e_s.html">Connectivity</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0b21189fd15a22d0333dd1a69403512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gad0b21189fd15a22d0333dd1a69403512">R_PCIE_RC_Open</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__cfg__t">pci_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gad0b21189fd15a22d0333dd1a69403512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2367dddb302cc5e915334e062c62172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, uint32_t register_number, uint32_t *p_data)</td></tr>
<tr class="separator:gae2367dddb302cc5e915334e062c62172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669559b157e440b12c54ffc9c56b59e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga669559b157e440b12c54ffc9c56b59e3">R_PCIE_RC_SelfConfigurationRegisterSet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, uint32_t register_number, uint32_t data)</td></tr>
<tr class="separator:ga669559b157e440b12c54ffc9c56b59e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b549a3562c5ebcd5fd66c6368ee2a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga19b549a3562c5ebcd5fd66c6368ee2a8">R_PCIE_RC_MessageWrite</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const p_transfer, bool with_data)</td></tr>
<tr class="separator:ga19b549a3562c5ebcd5fd66c6368ee2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f149ce5123415b0b4bf00c95e4da3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga0f149ce5123415b0b4bf00c95e4da3f8">R_PCIE_RC_MessageRead</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga0f149ce5123415b0b4bf00c95e4da3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41bb4177d75b85c4ffe224d537fb2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gad41bb4177d75b85c4ffe224d537fb2aa">R_PCIE_RC_ConfigurationRegisterWrite</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#ga4416af14da0b65e9990414db9e9e7ef3">pci_configuration_write_type_t</a> transaction_type, <a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:gad41bb4177d75b85c4ffe224d537fb2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57b920f20120f16b010e5617c287404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gab57b920f20120f16b010e5617c287404">R_PCIE_RC_ConfigurationRegisterRead</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#gaf5292151cc185e0b230652e03d785697">pci_configuration_read_type_t</a> transaction_type, <a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:gab57b920f20120f16b010e5617c287404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4874ef8466ecdd38557336753c2c346a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga4874ef8466ecdd38557336753c2c346a">R_PCIE_RC_IORegisterWrite</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga4874ef8466ecdd38557336753c2c346a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478e5d3425566132042831cdaac82924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga478e5d3425566132042831cdaac82924">R_PCIE_RC_IORegisterRead</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga478e5d3425566132042831cdaac82924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22461a21fa1bb07ba0500fdabbdce9f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga22461a21fa1bb07ba0500fdabbdce9f4">R_PCIE_RC_LinkStatusGet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#structpci__status__t">pci_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga22461a21fa1bb07ba0500fdabbdce9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ecef08d9c4c45ca21324e75baab2de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga6ecef08d9c4c45ca21324e75baab2de3">R_PCIE_RC_IntxAssert</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:ga6ecef08d9c4c45ca21324e75baab2de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf13130e1eb3caa7c271cb28ad1cdc79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gaf13130e1eb3caa7c271cb28ad1cdc79a">R_PCIE_RC_IntxDeassert</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaf13130e1eb3caa7c271cb28ad1cdc79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb29748b668e50e432dd7e4161d950a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gacb29748b668e50e432dd7e4161d950a9">R_PCIE_RC_LinkWidthChange</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, uint32_t link_width, uint32_t option)</td></tr>
<tr class="separator:gacb29748b668e50e432dd7e4161d950a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a1948b65b2f2760c28c024129f538f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gab0a1948b65b2f2760c28c024129f538f">R_PCIE_RC_LinkSpeedChange</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, <a class="el" href="group___p_c_i___a_p_i.html#gae98003b04b0361c2f075e0b6cabfa850">pci_link_speed_t</a> link_speed, uint32_t option)</td></tr>
<tr class="separator:gab0a1948b65b2f2760c28c024129f538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbbf421fdacba324727bd68726bc2a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gaabbbf421fdacba324727bd68726bc2a6">R_PCIE_RC_LinkEqualizationRequest</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaabbbf421fdacba324727bd68726bc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c022be4a1f42761121d4e75f9af111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga22c022be4a1f42761121d4e75f9af111">R_PCIE_RC_CallbackSet</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga22c022be4a1f42761121d4e75f9af111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4887fd4f72738f056b484f7a3b01933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#gaa4887fd4f72738f056b484f7a3b01933">R_PCIE_RC_Close</a> (<a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="separator:gaa4887fd4f72738f056b484f7a3b01933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the PCI peripheral on RZ Microprocessor. This module implements the <a class="el" href="group___p_c_i___a_p_i.html">PCI Interface</a>. </p>
<h1><a class="anchor" id="r-pcie_rc-overview"></a>
Overview</h1>
<p>The PCI Express (PCIE) Root Complex HAL module supports transactions with an PCIE End Point device.</p>
<h2><a class="anchor" id="r-pcie_rc-features"></a>
Features</h2>
<ul>
<li>By accessing the memory space of the RZ Microprocessor, MRd/MWr requests are issued and data is exchanged with the PCIE device.<a class="anchor" id="um_pcie_rc_memory_write_request"></a><a class="anchor" id="um_pcie_rc_memory_read_request"></a></li>
<li>The CfgRd0/CfgWr0 requests can be used to read and write to Configuration Register 0 on the EP side.<a class="anchor" id="um_pcie_rc_configuraiton_register_read_request"></a><a class="anchor" id="um_pcie_rc_configuraiton_register_write_request"></a></li>
<li>The following is possible with Msg/MsgD requests.<ul>
<li>Msg/MsgD can be sent/received.<a class="anchor" id="um_pcie_rc_message_send"></a><a class="anchor" id="um_pcie_rc_message_receive"></a></li>
<li>The Assert_INTx or Deassert_INTx message can be used to receive an INTx interrupt and notify via callback funtion.<a class="anchor" id="um_pcie_rc_assert_intx_notify"></a></li>
<li>The user can be notified of receipt of ERR_COR, ERR_NONFATAL, or ERR_FATAL messages. Errors are notified via the ICU_ERROR driver.<a class="anchor" id="um_pcie_rc_correctable_notify"></a><a class="anchor" id="um_pcie_rc_nonfatal_error_notify"></a><a class="anchor" id="um_pcie_rc_fatal_error_notify"></a></li>
</ul>
</li>
<li>Can be set to either "1 Lane / 2 Channels" or "2 Lanes / 1 Channel".</li>
<li>Can set its own Configuration Register1, including the Hwinit section, when opened.</li>
<li>Can read/write its own Configuration Register.<a class="anchor" id="um_pcie_rc_self_configuration_register_get"></a><a class="anchor" id="um_pcie_rc_self_configuration_register_set"></a></li>
<li>Can set BAR, PCIe, AXI windows and MSI window.<a class="anchor" id="um_pcie_rc_axi_window_settings"></a><a class="anchor" id="um_pcie_rc_pcie_window_settings"></a><a class="anchor" id="um_pcie_rc_msi_window_setting"></a></li>
<li>It is possible to accept MSI interrupts and notify the user.<a class="anchor" id="um_pcie_rc_assert_msi_notify"></a></li>
<li>Can get the link status.<a class="anchor" id="um_pcie_rc_link_status"></a></li>
<li>When various events occur due to the PCIEn_INT_PCIE_EVT interrupt, the user can be notified along with the cause.</li>
<li>Link width can be dynamically changed and user can be notified.<a class="anchor" id="um_pcie_rc_link_width_change"></a></li>
<li>Link Speed can be dynamically changed.<a class="anchor" id="um_pcie_rc_link_speed_change"></a></li>
<li>Equalization can be requested. Also, user can be notified when equalization is requested.<a class="anchor" id="um_pcie_rc_link_equalization"></a> <a class="anchor" id="um_pcie_rc_callback_set"></a> </li>
</ul>
<h1><a class="anchor" id="r-pcie_rc-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for r_pcie_rc</h2>
The following build time configurations are defined in fsp_cfg/r_pcie_rc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Link Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
2Lanes / 1Channel</li>
<li>
1Lane / 2Channels</li>
</ul>
</td><td>2Lanes / 1Channel </td><td>Link Mode. </td></tr>
<tr>
<td>Multiplex Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable multiplex interrupt for a single driver. </td></tr>
</table>
 <h2>Configurations for Connectivity &gt; PCI (r_pcie_rc)</h2>
This module can be added to the Stacks tab via New Stack &gt; Connectivity &gt; PCI (r_pcie_rc).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_pci_rc0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Channel</td><td>Channel should be 0 or 1</td><td>0 </td><td>Specify the PCIE channel. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Vender ID / Device ID &gt; Vender ID</td><td>Manual Entry</td><td>0x0000 </td><td>Vender ID. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Vender ID / Device ID &gt; Device ID</td><td>Manual Entry</td><td>0x0000 </td><td>Device ID. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Command &gt; Memory Space Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Memory Space Enable. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Command &gt; Bus Master Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Bus Master Enable. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Command &gt; Parity Error Response</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Parity Error Response. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Command &gt; Assert INTx Interrupt Disable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Assert INTx Interrupt Disable. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Revision ID / Class Code &gt; Revision ID</td><td>Manual Entry</td><td>0x00 </td><td>Revision ID. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Revision ID / Class Code &gt; Class Code</td><td>Manual Entry</td><td>0x000 </td><td>Class Code. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; Type</td><td>64bit</td><td>64bit </td><td>Base Address Register Type. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; Prefetch</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disable</li>
<li>
Enable</li>
</ul>
</td><td>Disable </td><td>Base Address Register Prefetch. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; BAR0</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 0. </td></tr>
<tr>
<td>Type 1 Configuration Space Setting &gt; Base Address Register 0 / 1 &gt; BAR1</td><td>Manual Entry</td><td>0x00000000 </td><td>Base Address Register 1. </td></tr>
<tr>
<td>Configuration Register Init List &gt; Name</td><td>Name must be a valid C symbol</td><td>g_pci_rc0_configuration_register_init_list </td><td>Configuration Register Init List symbol name. </td></tr>
<tr>
<td>Configuration Register Init List &gt; Length</td><td>The number of configuration register init lists must be a positive integer.</td><td>0 </td><td>Number of Configuration Register Init List. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>AXI Window 0 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 0 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 0 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 0 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 0 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 1 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 1 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 1 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 1 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 1 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 2 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 2 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 2 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 2 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 2 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 3 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 3 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 3 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 3 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 3 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 4 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 4 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 4 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 4 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 4 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 5 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 5 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 5 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 5 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 5 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 6 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 6 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 6 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 6 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 6 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>AXI Window 7 Enable. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; AXI Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 7 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; AXI Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>AXI Window 7 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>AXI Window Setting &gt; AXI Window Setting 7 &gt; AXI Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>AXI Window 7 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Enabled </td><td>PCIe Window 0 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 0 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 0 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 0 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 0 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 1 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 1 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 1 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 1 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 1 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 2 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 2 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 2 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 2 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 2 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 3 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 3 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 3 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 3 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 3 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 4 Enable. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 4 Base Address. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 4 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 4 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 4 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 5 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 5 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 5 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 5 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 5 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 6 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 6 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 6 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 6 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 6 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>PCIe Window 7 Enable. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; PCIe Window Base (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 7 Base Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; PCIe Window Mask (63bit width, Lower 12bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000FFF </td><td>PCIe Window 7 Mask. The address of lower 12bits must be 1 and 63th bit must be 0. </td></tr>
<tr>
<td>PCIe Window Setting &gt; PCIe Window Setting 7 &gt; PCIe Window Destination (64bit width, 4KB boundary)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>PCIe Window 7 Destination Address. The address must be 4Kbyte aligned. </td></tr>
<tr>
<td>MSI Setting &gt; MSI Window &gt; Window Enable</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>MSI Window Enable. </td></tr>
<tr>
<td>MSI Setting &gt; MSI Window &gt; MSI Receive Window Address (64bit width)</td><td>Manual Entry</td><td>0x0000000000000000 </td><td>MSI Receive Window Address. The address must be aligned according to MSI Receive Window Mask. </td></tr>
<tr>
<td>MSI Setting &gt; MSI Window &gt; MSI Receive Window Mask (63bit width, Lower 2bits must be 1)</td><td>Manual Entry</td><td>0x0000000000000003 </td><td>MSI Receive Window Mask. The address of lower 2bits must be 1. </td></tr>
<tr>
<td>PCIe Event Interrupt Sources &gt; Event 0</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
DL_UpDown</li>
<li>
ASPM L1 Rejected</li>
<li>
RX_DLLP_PM_ENTER_L23</li>
<li>
CA (Completer Abort)</li>
<li>
Request Complete</li>
<li>
Speed change operation completion</li>
<li>
Up/Down Configure operation complete</li>
</ul>
</td><td>0U </td><td>Select which event should trigger an Event interrupt. </td></tr>
<tr>
<td>PCIe Event Interrupt Sources &gt; Event 1</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
ERR_REPLAY_LOWER_UNCORRECTABLE_ERROR</li>
<li>
ERR_REPLAY_UPPER_UNCORRECTABLE_ERROR</li>
<li>
ERR_REPLAY_LOWER_CORRECTABLE_ERROR</li>
<li>
ERR_REPLAY_UPPER_CORRECTABLE_ERROR</li>
<li>
ERR_RPC_REPLAYFIFO_PERR</li>
<li>
TXB_PARITY_ERR</li>
</ul>
</td><td>0U </td><td>Select which event should trigger an Event interrupt. </td></tr>
<tr>
<td>Interrupt &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR). </td></tr>
<tr>
<td>Interrupt &gt; INTA Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>INTA Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; INTB Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>INTB Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; INTC Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>INTC Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; INTD Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>INTD Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; MSI Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>MSI Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Message Receive Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Message Receive Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; EVENT Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>EVENT Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Power OFF Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Power OFF Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Link Width Change Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Link Width Change Interrupt Priority. </td></tr>
<tr>
<td>Interrupt &gt; Link Equalization Request Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Link Equalization Request Interrupt Priority. </td></tr>
</table>
</p>
<dl class="section warning"><dt>Warning</dt><dd>When configuring the MSI window in the FSP configuration editor, note the following conditions:<ul>
<li>For the MSI Window Mask setting, the lower 2 bits must be 1, and the 63rd bit must be 0.</li>
<li>For the MSI Window Address setting, it must be aligned with the size set by MSI Window Mask.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="r-pcie_rc-clock-configuration"></a>
Clock Configuration</h2>
<p>There is no clock configuration for the PCIe module.</p>
<h2><a class="anchor" id="r-pcie_rc-pin-configuration"></a>
Pin Configuration</h2>
<p>The following pins are available to connect to an external PCIe device:</p><ul>
<li>PCIE_REFCLK_P0: Ch0 Reference clock input (Positive)</li>
<li>PCIE_REFCLK_N0: Ch0 Reference clock input (Negative)</li>
<li>PCIE_REFCLK_P1: Ch1 Reference clock input (Positive)</li>
<li>PCIE_REFCLK_N1: Ch1 Reference clock input (Negative)</li>
<li>PCIE_RXDP_L0: Serial data input 0 (Positive)</li>
<li>PCIE_RXDN_L0: Serial data input 0 (Negative)</li>
<li>PCIE_RXDP_L1: Serial data input 1 (Positive)</li>
<li>PCIE_RXDN_L1: Serial data input 1 (Negative)</li>
<li>PCIE_TXDP_L0: Serial data output 0 (Positive)</li>
<li>PCIE_TXDN_L0: Serial data output 0 (Negative)</li>
<li>PCIE_TXDP_L1: Serial data output 1 (Positive)</li>
<li>PCIE_TXDN_L1: Serial data output 1 (Negative)</li>
<li>PCIE_RSTOUT0B: PCIE Reset output ch0 for Root Complex</li>
<li>PCIE_RSTOUT1B: PCIE Reset output ch1 for Root Complex</li>
</ul>
<h1><a class="anchor" id="r-pcie_rc-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-pcie_rc-configuration-register"></a>
Configuration Register</h2>
<h3><a class="anchor" id="r-pcie_rc-list-of-configuration-register"></a>
List of Configuration Register</h3>
<p>PCIE Configuration registers are accessed by other PCIe devices or by itself. The PCIE peripehral of RZ microprocessor supports the following configuration registers:</p>
<table class="doxtable">
<tr>
<th>Address Offset </th><th>Register Number </th><th>Register symbol </th><th>Register name  </th></tr>
<tr>
<td>0x000 </td><td>0 </td><td>PCI_RC_VID </td><td>Vendor and Device ID Register </td></tr>
<tr>
<td>0x004 </td><td>1 </td><td>PCI_RC_COM_STA </td><td>Command and Status Register </td></tr>
<tr>
<td>0x008 </td><td>2 </td><td>PCI_RC_RID_CC </td><td>Revision ID and Class Code Register </td></tr>
<tr>
<td>0x00C </td><td>3 </td><td>PCI_RC_CL_HT </td><td>Cache Line and Header Type Register </td></tr>
<tr>
<td>0x010 </td><td>4 </td><td>PCI_RC_BAR0 </td><td>Base Address Register 0 </td></tr>
<tr>
<td>0x014 </td><td>5 </td><td>PCI_RC_BAR1 </td><td>Base Address Register 1 </td></tr>
<tr>
<td>0x018 </td><td>6 </td><td>PCI_RC_BNR </td><td>Bus Number Register </td></tr>
<tr>
<td>0x01C </td><td>7 </td><td>PCI_RC_IOBL_SS </td><td>I/O Base/Limit and Secondary Status Register </td></tr>
<tr>
<td>0x020 </td><td>8 </td><td>PCI_RC_MEMBL </td><td>Memory Base/Limit Register </td></tr>
<tr>
<td>0x024 </td><td>9 </td><td>PCI_RC_PMBL </td><td>Prefetchable Memory Base/Limit Register </td></tr>
<tr>
<td>0x028 </td><td>10 </td><td>PCI_RC_PBUP32 </td><td>Prefetchable Base Upper 32bits Register </td></tr>
<tr>
<td>0x02C </td><td>11 </td><td>PCI_RC_PLUP32 </td><td>Prefetchable Limit Upper 32bits Register </td></tr>
<tr>
<td>0x030 </td><td>12 </td><td>PCI_RC_IOBLUP16 </td><td>I/O Base/Limit Upper 16bits Register </td></tr>
<tr>
<td>0x034 </td><td>13 </td><td>PCI_RC_CP </td><td>Capability Pointer Register </td></tr>
<tr>
<td>0x03C </td><td>15 </td><td>PCI_RC_BC_INT </td><td>Bridge Control and Interrupt Register </td></tr>
<tr>
<td>0x040 </td><td>16 </td><td>PCI_RC_PMC PM </td><td>Capabilities Register </td></tr>
<tr>
<td>0x044 </td><td>17 </td><td>PCI_RC_PMSC </td><td>PM Status/Control Register </td></tr>
<tr>
<td>0x060 </td><td>24 </td><td>PCI_RC_PCIEC </td><td>PCI Express Capability Register </td></tr>
<tr>
<td>0x064 </td><td>25 </td><td>PCI_RC_DEVC </td><td>Device Capabilities Register </td></tr>
<tr>
<td>0x068 </td><td>26 </td><td>PCI_RC_DEVCS </td><td>Device Control/Status Register </td></tr>
<tr>
<td>0x06C </td><td>27 </td><td>PCI_RC_LINKC </td><td>Link Capabilities Register </td></tr>
<tr>
<td>0x070 </td><td>28 </td><td>PCI_RC_LINKCS </td><td>Link Control/Status Register </td></tr>
<tr>
<td>0x074 </td><td>29 </td><td>PCI_RC_SLOTC </td><td>Slot Capabilities Register </td></tr>
<tr>
<td>0x078 </td><td>30 </td><td>PCI_RC_SLOTCS </td><td>Slot Control/Status Register </td></tr>
<tr>
<td>0x07C </td><td>31 </td><td>PCI_RC_ROOTCC </td><td>Root Control/Capabilities Register </td></tr>
<tr>
<td>0x080 </td><td>32 </td><td>PCI_RC_ROOTS </td><td>Root Status Register </td></tr>
<tr>
<td>0x084 </td><td>33 </td><td>PCI_RC_DEVC2 </td><td>Device Capabilities 2 Register </td></tr>
<tr>
<td>0x088 </td><td>34 </td><td>PCI_RC_DEVCS2 </td><td>Device Control 2/Status 2 Register </td></tr>
<tr>
<td>0x08C </td><td>35 </td><td>PCI_RC_LINKC2 </td><td>Link Capabilities 2 Register </td></tr>
<tr>
<td>0x090 </td><td>36 </td><td>PCI_RC_LINCS2 </td><td>Link Control 2/Status 2 Register </td></tr>
<tr>
<td>0x0A0 </td><td>40 </td><td>PCI_RC_BARMSK00L </td><td>Base Address Register Mask 00 (Lower) Register </td></tr>
<tr>
<td>0x0A4 </td><td>41 </td><td>PCI_RC_BARMSK00U </td><td>Base Address Register Mask 00 (Upper) Register </td></tr>
<tr>
<td>0x0C8 </td><td>50 </td><td>PCI_RC_BSIZE00_01 </td><td>Base Size 00/01 Register </td></tr>
<tr>
<td>0x0D8 </td><td>54 </td><td>PCI_RC_TSUPPORT00_01_02 </td><td>Type Supported 00/01/02 Register </td></tr>
<tr>
<td>0x100 </td><td>64 </td><td>PCI_RC_ADVERC </td><td>Advanced Error Reporting Capability Register </td></tr>
<tr>
<td>0x104 </td><td>65 </td><td>PCI_RC_UNCESTS </td><td>Uncorrectable Error Status Register </td></tr>
<tr>
<td>0x108 </td><td>66 </td><td>PCI_RC_UNCEMASK </td><td>Uncorrectable Error Mask Register </td></tr>
<tr>
<td>0x10C </td><td>67 </td><td>PCI_RC_UNCESVY </td><td>Uncorrectable Error Severity Register </td></tr>
<tr>
<td>0x110 </td><td>68 </td><td>PCI_RC_CESTS </td><td>Correctable Error Status Register </td></tr>
<tr>
<td>0x114 </td><td>69 </td><td>PCI_RC_CEMASK </td><td>Correctable Error Mask Register </td></tr>
<tr>
<td>0x118 </td><td>70 </td><td>PCI_RC_ADVECC </td><td>Advanced Error Capabilities and Control Register </td></tr>
<tr>
<td>0x11C </td><td>71 </td><td>PCI_RC_HLOG0 </td><td>Header Log Register 0 </td></tr>
<tr>
<td>0x120 </td><td>72 </td><td>PCI_RC_HLOG1 </td><td>Header Log Register 1 </td></tr>
<tr>
<td>0x124 </td><td>73 </td><td>PCI_RC_HLOG2 </td><td>Header Log Register 2 </td></tr>
<tr>
<td>0x128 </td><td>74 </td><td>PCI_RC_HLOG3 </td><td>Header Log Register 3 </td></tr>
<tr>
<td>0x12C </td><td>75 </td><td>PCI_RC_ROOTEC </td><td>Root Error Command Register </td></tr>
<tr>
<td>0x130 </td><td>76 </td><td>PCI_RC_ROOTES </td><td>Root Error Status Register </td></tr>
<tr>
<td>0x134 </td><td>77 </td><td>PCI_RC_ERRSI </td><td>Error Source Identification Register </td></tr>
<tr>
<td>0x150 </td><td>84 </td><td>PCI_RC_DEVSNEXTC </td><td>Device Serial Number Extended Capability Register </td></tr>
<tr>
<td>0x154 </td><td>85 </td><td>PCI_RC_SNL </td><td>Serial Number Register (Lower DW) Register </td></tr>
<tr>
<td>0x158 </td><td>86 </td><td>PCI_RC_SNU </td><td>Serial Number Register (Upper DW) Register </td></tr>
<tr>
<td>0x1B0 </td><td>108 </td><td>PCI_RC_SPEECH </td><td>Secondary PCI Express Extended Capability Header Register </td></tr>
<tr>
<td>0x1B4 </td><td>109 </td><td>PCI_RC_LINC3 </td><td>Link Control 3 Register </td></tr>
<tr>
<td>0x1B8 </td><td>110 </td><td>PCI_RC_LESTA </td><td>Lane Error Status Register </td></tr>
<tr>
<td>0x1BC </td><td>111 </td><td>PCI_RC_LEQCTL </td><td>Lane Equalization Control Register </td></tr>
</table>
<h3><a class="anchor" id="r-pcie_rc-initialization-of-configuration-register"></a>
Initializaiton of Configuration Register</h3>
<p>The PCIE_RC driver initializes the configuration register, in paticular, the registers with the HwInit attribute can only be initialized in <a class="el" href="group___p_c_i_e___r_c.html#gad0b21189fd15a22d0333dd1a69403512">R_PCIE_RC_Open</a>. Users can set the PCI compatible configuration registers up to address 0x40 using the FSP Configuration editor, and the configuration registers above address 0x40 can be set by setting pci_rc_configuration_register_init_t structure. The default template with one entry is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="group___p_c_i___a_p_i.html#structpci__configuration__register__init__t">pci_configuration_register_init_t</a> g_pci_rc0_configuration_register_init_list[PCIE_RC_CH0_CONFIG_REG_INIT_LIST_NUM] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        <span class="comment">/* Specify Register number.*/</span></div><div class="line">        .<a class="code" href="group___p_c_i___a_p_i.html#a301b19136279db1b1d1567aefbe1aae9">register_number</a> = 0x06C / 4,</div><div class="line"></div><div class="line">        <span class="comment">/* Value to be set in configuration register. */</span></div><div class="line">        .init_value      = 0x00000C00,</div><div class="line"></div><div class="line">        <span class="comment">/* Mask setting for values when setting configuration registers. */</span></div><div class="line">        .init_value_mask = R_PCIE0_PCI_RC_LINKC_ASPMS_Msk,</div><div class="line">    },</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="r-pcie_rc-access-of-configureation-register"></a>
Access of Configuration Register</h3>
<p>The PCIE_RC driver provides an API to access the own configuration space. Use <a class="el" href="group___p_c_i_e___r_c.html#ga669559b157e440b12c54ffc9c56b59e3">R_PCIE_RC_SelfConfigurationRegisterSet</a> or <a class="el" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a> to access the configuration space of PCIe peripheral of this RZ Microprocessor, and <a class="el" href="group___p_c_i_e___r_c.html#gad41bb4177d75b85c4ffe224d537fb2aa">R_PCIE_RC_ConfigurationRegisterWrite</a> or <a class="el" href="group___p_c_i_e___r_c.html#gab57b920f20120f16b010e5617c287404">R_PCIE_RC_ConfigurationRegisterRead</a> to access the configuration space on the endpoint side.</p>
<h4>Link retraining via configuration space</h4>
<p>For example, to retrain the link, set the Retrain Link bits of "PCI_RC_LINKCS: Link Control/Status Register" (address offset = 0x070, register number = 28) in the configuration space to 1.</p>
<h3><a class="anchor" id="r-pcie_rc-interrupt-handling"></a>
Interrupt Handling</h3>
<p>The following events cause an interrupt and notify the user via callback function :</p>
<ul>
<li>Link width change</li>
<li>Link Equalization Request</li>
</ul>
<p>The status of these interrupts is indicated by Link Bandwidth Management Status bit (30 bit) / Link Autonomous Bandwidth Status (31 bit) in "PCI_RC_LINKCS : Link Control/Status Register" (address offset = 0x070, register number = 28) or Link Equalization Request (21 bit) in "PCI_RC_LINCS2 : Link Control 2/Status 2 Register" (address offset = 0x090, register number = 36).</p>
<p>These registers are located in the configuration space and must be cleared by the user after interrupt handling. HAL Driver does not clear these bits.</p>
<h3><a class="anchor" id="r-pcie_rc-error-handling"></a>
Error Handling</h3>
<p>The PCI Express provides three types of error interrupts: Correctable, Fatal and Non Fatal.</p>
<p>Error interrupt callbacks will pass either PCI_RC_EVENT_CORRECTABLE_ERROR, PCI_RC_EVENT_UNCORRECTABLE_ERROR_NON_FATAL or PCI_RC_EVENT_UNCORRECTABLE_ERROR_FATAL in the pci_rc_callback_args_t::event field. Users can mask the error factor by setting "PCI_RC_UNCEMASK : Uncorrectable Error Mask Register" (address offset = 0x108, register number = 66) and "PCI_RC_CEMASK : Correctable Error Mask Register" (offset = 0x114, register number = 69) in the PCI configuration space.</p>
<p>The status of the error that occurred can be get via "PCI_RC_UNCESTS : Uncorrectable Error Status Register" (address offset = 0x104, regisister number = 65) and "PCI_RC_CESTS : Correctable Error Status Register" (address offset = 0x110, register number = 68) in the configuration space. After the error is notified via the callback function, the user must clear the error factor.</p>
<p>The PCIE outputs an error signal to the ICU. ICU can output PERI_ERRn interrupt (Peripherals error event n) to GIC or cause error reset when ICU accepts error signal from PCIE. To use PERI_ERRn interrupt or reset at PCIE, Interruput Controller Unit (ICU) ERROR (r_icu_error) need to be configured. When the PERI_ERRn interrupt is configured to use interrupt and triggered, the callback function registered during open is called.</p>
<h2><a class="anchor" id="r_pcie_rc-axi-window-settings"></a>
AXI Window settings (PCIe to AXI)</h2>
<p>The AXI Window settings are used when MWr/MRd data from PCI Express is transferred to AXI bus (Data Receive operation via MWr/MRd request). Set AXI Window Base and AXI Window Mask in the BAR region. (BAR: PCI Express Configuration Register, Base Address Register)</p>
<p>AXI access address is shown as below.</p>
<p>AXI Access Address = PCIe Access Address - BAR0 - AXI Window Base + AXI Window Destination</p>
<h3><a class="anchor" id="r_pcie_rc-example-of-axi-window-settings"></a>
Example of AXI Window settings</h3>
<table class="doxtable">
<tr>
<th>Element </th><th>Setting Value </th><th>Settings  </th></tr>
<tr>
<td>BAR0 </td><td>0x0000_0000_1000_0000 </td><td>Configuration Register "PCI_RC_BAR0"/"PCI_RC_BAR1". Can be set by Stack Configuration. </td></tr>
<tr>
<td>BAR Mask0 </td><td>0x0000_0000_0FFF_FFFC </td><td>Configuration Register "PCI_RC_BARMSK00L"/"PCI_RC_BARMSK00U". </td></tr>
<tr>
<td>AXI Window Base </td><td>0x0000_0000_0010_0000 </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>AXI Window Mask </td><td>0x0000_0000_0003_FFFF </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>AXI Window Destination </td><td>0x0000_0004_0100_0000 </td><td>Can be set by Stack Configuration. </td></tr>
</table>
<p>BAR0 Assigned region : 0x0000_0000_1000_0000 to 0x0000_0000_1FFF_FFFF (256 MB)</p>
<p>AXI Window region : 0x0100_0000 to 0x0103_FFFF (256 KB)</p>
<dl class="section warning"><dt>Warning</dt><dd>When configuring the AXI window in the FSP configuration editor, note the following conditions:<ul>
<li>For the AXI Window Base Address setting, the address must be 4Kbyte aligned.</li>
<li>For the AXI Window Mask setting, the loweer 12 bits must be 1, and must be set 1 from the lowest bit. In addition, the 63rd bit must be 0.</li>
<li>For the AXI Window Destination Address setting, the address must be 4Kbyte aligned.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="r_pcie_rc-pcie-window-settings"></a>
PCIe Window settings (AXI to PCIe)</h2>
<p>PCIe Window settings are used when MWr/MRd data from AXI bus is transferred to PCI Express (Data Transmit operation via MWr/MRd request).</p>
<p>PCIe access address is shown as below.</p>
<p>PCIe Access Address = AXI Access Address - PCIe Window Base + PCIe Window Destination</p>
<h3><a class="anchor" id="r_pcie_rc-example-of-pcie-window-settings"></a>
Example of PCIe Window settings</h3>
<table class="doxtable">
<tr>
<th>Element </th><th>Setting Value </th><th>Settings  </th></tr>
<tr>
<td>BAR0 </td><td>0x0000_0000_1000_0000 </td><td>Configuration Register "PCI_RC_BAR0"/"PCI_RC_BAR1". Can be set by Stack Configuration. </td></tr>
<tr>
<td>BAR Mask0 </td><td>0x0000_0000_07FF_FFFC </td><td>Configuration Register "PCI_RC_BARMSK00L"/"PCI_RC_BARMSK00U". </td></tr>
<tr>
<td>PCIe Window Base </td><td>0x0000_0000_0070_0000 </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>PCIe Window Mask </td><td>0x0000_0000_000F_FFFF </td><td>Can be set by Stack Configuration. </td></tr>
<tr>
<td>PCIe Window Destination </td><td>0x0000_0004_0070_0000 </td><td>Can be set by Stack Configuration. </td></tr>
</table>
<p>BAR0 Assigned region : 0x0000_0000_1000_0000 to 0x0000_0000_17FF_FFFF (128 MB)</p>
<p>PCIe Window region : 0x0070_0000 to 0x007F_FFFF (1 MB)</p>
<dl class="section warning"><dt>Warning</dt><dd>When configuring the PCIe window in the FSP configuration editor, note the following conditions:<ul>
<li>For the PCIe Window Base Address setting, the address must be 4Kbyte aligned.</li>
<li>For the PCIe Window Mask setting, the lower 12 bits must be 1, and must be set 1 from the lowest bit. In addition, the 63rd bit must be 0.</li>
<li>For the PCIe Window Destination Address setting, the address must be 4Kbyte aligned.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="r_pcie_rc-address-expander"></a>
Address Expander</h2>
<p>Using the PCIE_RC HAL driver, other PCIe devices can be accessed through PCIEn space (8GB) or through PCIEn mirror space (256MB) (n=0,1). In particular, if the bus master supports 32-bit address space only, PCIEn space must be accessed through PCIEn mirror space. When using the mirror space, the address expander setting must first be configured in the BSP configuration. Consult Section "Address Expander" in the RZ microprocessor User's Manual for details.</p>
<h2><a class="anchor" id="r-pcie_rc-limitations"></a>
Limitations</h2>
<h1><a class="anchor" id="r-pcie_rc-examples"></a>
Examples</h1>
<h2>Configuration Space (above address 0x40) Initialization Example</h2>
<p>The below is an example of configuration space initialization.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="group___p_c_i___a_p_i.html#structpci__configuration__register__init__t">pci_configuration_register_init_t</a> p_pcie_cfg_reg_init[PCIE_CONFIGURATION_REGISTER_INIT_NUM] =</div><div class="line">{</div><div class="line">    {</div><div class="line">        .<a class="code" href="group___p_c_i___a_p_i.html#a301b19136279db1b1d1567aefbe1aae9">register_number</a> = 0x06C / 4,  <span class="comment">/* Link Capabilities Register number */</span></div><div class="line">        .init_value      = 0x00000C00, <span class="comment">/* ASPMS[1:0] = 3 : L0s and L1 Entry Supported */</span></div><div class="line">        .init_value_mask = R_PCIE0_PCI_RC_LINKC_ASPMS_Msk,</div><div class="line">    },</div><div class="line">    {</div><div class="line">        .register_number = 0x070 / 4,  <span class="comment">/* Link Control/Status Register number */</span></div><div class="line">        .init_value      = 0x00000C03, <span class="comment">/* ASPMC[1:0] = 3 : L0s and L1 Entry Supported</span></div><div class="line"><span class="comment">                                        * LBMIE = 1      : Link Bandwidth Management Interrupt Enable</span></div><div class="line"><span class="comment">                                        * LABIE = 1      : Link Autonomous Bandwidth Interrupt Enable */</span></div><div class="line">        .init_value_mask = R_PCIE0_PCI_RC_LINKCS_LABIE_Msk | R_PCIE0_PCI_RC_LINKCS_LBMIE_Msk |</div><div class="line">                           R_PCIE0_PCI_RC_LINKCS_ASPMC_Msk,</div><div class="line">    },</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <h2>Basic Example</h2>
<p>This is a basic example of minimal use of the PCIE_RC module in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define CFG_REG_COMMAND_AND_STATUS_REGISTER_NUM     (1)</span></div><div class="line"><span class="preprocessor">#define CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM    (28)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define PCIE_EXAMPLE_WRITE_DATA                     (0x12345678U)</span></div><div class="line"></div><div class="line">uint32_t read_data;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> pcie_rc_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Open PCIE module */</span></div><div class="line">    err = <a class="code" href="group___p_c_i_e___r_c.html#gad0b21189fd15a22d0333dd1a69403512">R_PCIE_RC_Open</a>(&amp;g_pci0_ctrl, &amp;g_pci0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Link retrain */</span></div><div class="line">    <a class="code" href="group___p_c_i___a_p_i.html#structpci__status__t">pci_status_t</a> link_status;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Set RL (Retrain Link) bit of Link Control/Status Register to 1 for link retraining. */</span></div><div class="line">        uint32_t linkcs;</div><div class="line">        (void) <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM, &amp;linkcs);</div><div class="line">        linkcs |= R_PCIE0_PCI_RC_LINKCS_RL_Msk;</div><div class="line">        (void) <a class="code" href="group___p_c_i_e___r_c.html#ga669559b157e440b12c54ffc9c56b59e3">R_PCIE_RC_SelfConfigurationRegisterSet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM, linkcs);</div><div class="line"></div><div class="line">        (void) <a class="code" href="group___p_c_i_e___r_c.html#ga22461a21fa1bb07ba0500fdabbdce9f4">R_PCIE_RC_LinkStatusGet</a>(&amp;g_pci0_ctrl, &amp;link_status);</div><div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">true</span> != link_status.<a class="code" href="group___p_c_i___a_p_i.html#a4dfc9c065872b92eb87b3ee25c638549">is_link_up</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Bus Master and Memory space Enable */</span></div><div class="line">    uint32_t com_sta;</div><div class="line">    <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_COMMAND_AND_STATUS_REGISTER_NUM, &amp;com_sta);</div><div class="line">    com_sta |= (R_PCIE0_PCI_RC_COM_STA_MSE_Msk | R_PCIE0_PCI_RC_COM_STA_BME_Msk);</div><div class="line">    <a class="code" href="group___p_c_i_e___r_c.html#ga669559b157e440b12c54ffc9c56b59e3">R_PCIE_RC_SelfConfigurationRegisterSet</a>(&amp;g_pci0_ctrl, CFG_REG_COMMAND_AND_STATUS_REGISTER_NUM, com_sta);</div><div class="line"></div><div class="line">    <span class="comment">/* After R_PCIE_RC_Open() and any required device specific initialization, data can be write/read directly to/from the PCIE_EP device.</span></div><div class="line"><span class="comment">     * Set PCIEn space address or PCIEn mirror space address as PCIE0_SPACE_BASE.</span></div><div class="line"><span class="comment">     * When access via PCIEn mirror space, need to configure the address expander in advance. */</span></div><div class="line">    *((<span class="keyword">volatile</span> uint32_t *) PCIE0_SPACE_BASE) = PCIE_EXAMPLE_WRITE_DATA;</div><div class="line"></div><div class="line">    read_data = *((<span class="keyword">volatile</span> uint32_t *) PCIE0_SPACE_BASE);</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the read_data. */</span></div><div class="line">    <span class="keywordflow">if</span> (read_data != PCIE_EXAMPLE_WRITE_DATA)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Verify error. */</span></div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>PCIE_RC Interrupt Handling via Callback Example</h2>
<p>This is an example of a PCIE_RC callback when Link width change / Link Equalization Request event occurred.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM        (28)</span></div><div class="line"><span class="preprocessor">#define CFG_REG_LINK_CONTROL_2_STATUS_2_REGISTER_NUM    (36)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> user_pcie_rc_interrupt_handling_callback (<a class="code" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___p_c_i___a_p_i.html#ggacf7f5432fe7d5dc3e3f9f2ab7a0538a1a0e6120fbb9f3765cd5b36176364ff54d">PCI_EVENT_LINK_WIDTH_CHANGE</a> == p_args-&gt;<a class="code" href="group___p_c_i___a_p_i.html#a252e6908580582e492688eee99b411ef">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* User must clear the Link Bandwidth Management Status bit (bit 30) and the Link Autonomous Status bit (bit 31)</span></div><div class="line"><span class="comment">         * in the Link Control/Status Register (Configuration register offset 0x70) in the user callback function.  */</span></div><div class="line">        uint32_t linkcs;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM, &amp;linkcs);</div><div class="line">        linkcs |= (R_PCIE0_PCI_RC_LINKCS_LBMS_Msk | R_PCIE0_PCI_RC_LINKCS_LABS_Msk);</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#ga669559b157e440b12c54ffc9c56b59e3">R_PCIE_RC_SelfConfigurationRegisterSet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM, linkcs);</div><div class="line"></div><div class="line">        <span class="comment">/* Dummy read to ensure that interrupt event is cleared. */</span></div><div class="line">        uint32_t dummy;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_STATUS_REGISTER_NUM, &amp;dummy);</div><div class="line"></div><div class="line">        <span class="comment">/* Add application code when Link Band Change event occurred. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___p_c_i___a_p_i.html#ggacf7f5432fe7d5dc3e3f9f2ab7a0538a1ae357f9686b58e0e307e1d857bbe0aaa8">PCI_EVENT_LINK_EQUALIZATION_REQUEST</a> == p_args-&gt;<a class="code" href="group___p_c_i___a_p_i.html#a252e6908580582e492688eee99b411ef">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* User must clear the Link Equalization Request bit (bit 21) in the Link Control 2 / Status 2 Register</span></div><div class="line"><span class="comment">         * (Configuration register offset 0x90) in the user callback function. */</span></div><div class="line">        uint32_t linkcs2;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_2_STATUS_2_REGISTER_NUM, &amp;linkcs2);</div><div class="line">        linkcs2 |= R_PCIE0_PCI_RC_LINKCS2_LER_Msk;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#ga669559b157e440b12c54ffc9c56b59e3">R_PCIE_RC_SelfConfigurationRegisterSet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_2_STATUS_2_REGISTER_NUM, linkcs2);</div><div class="line"></div><div class="line">        <span class="comment">/* Dummy read to ensure that interrupt event is cleared. */</span></div><div class="line">        uint32_t dummy;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_LINK_CONTROL_2_STATUS_2_REGISTER_NUM, &amp;dummy);</div><div class="line"></div><div class="line">        <span class="comment">/* Add application code when Link Equalization event occurred. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>PCIE_RC Error Handling via Callback Example</h2>
<p>This is an example of a PCIE_RC callback when error occurred.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define CFG_REG_UNCORRECTABLE_ERROR_STATUS_REGISTER_NUM    (65)</span></div><div class="line"><span class="preprocessor">#define CFG_REG_CORRECTABLE_ERROR_STATUS_REGISTER_NUM      (68)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> user_pcie_rc_error_callback (<a class="code" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___p_c_i___a_p_i.html#ggacf7f5432fe7d5dc3e3f9f2ab7a0538a1a0a52b253a193b27749c3ad8699d91a6e">PCI_EVENT_CORRECTABLE_ERROR</a> == p_args-&gt;<a class="code" href="group___p_c_i___a_p_i.html#a252e6908580582e492688eee99b411ef">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Read Correctable Error Status Register. */</span></div><div class="line">        uint32_t cests;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_CORRECTABLE_ERROR_STATUS_REGISTER_NUM, &amp;cests);</div><div class="line"></div><div class="line">        <span class="comment">/* Add application code when correctable error occurred. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___p_c_i___a_p_i.html#ggacf7f5432fe7d5dc3e3f9f2ab7a0538a1a418201a327d0d4cf750343e6dc66d60f">PCI_EVENT_UNCORRECTABLE_ERROR_NON_FATAL</a> == p_args-&gt;<a class="code" href="group___p_c_i___a_p_i.html#a252e6908580582e492688eee99b411ef">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Read Uncorrectable Error Status Register. */</span></div><div class="line">        uint32_t uncests;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_UNCORRECTABLE_ERROR_STATUS_REGISTER_NUM, &amp;uncests);</div><div class="line"></div><div class="line">        <span class="comment">/* Add application code when uncorrectable error occurred. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___p_c_i___a_p_i.html#ggacf7f5432fe7d5dc3e3f9f2ab7a0538a1ae18556e59114f179456fef6160ce7619">PCI_EVENT_UNCORRECTABLE_ERROR_FATAL</a> == p_args-&gt;<a class="code" href="group___p_c_i___a_p_i.html#a252e6908580582e492688eee99b411ef">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Read Uncorrectable Error Status Register. */</span></div><div class="line">        uint32_t uncests;</div><div class="line">        <a class="code" href="group___p_c_i_e___r_c.html#gae2367dddb302cc5e915334e062c62172">R_PCIE_RC_SelfConfigurationRegisterGet</a>(&amp;g_pci0_ctrl, CFG_REG_UNCORRECTABLE_ERROR_STATUS_REGISTER_NUM, &amp;uncests);</div><div class="line"></div><div class="line">        <span class="comment">/* Add application code when uncorrectable error occurred. */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structpcie__rc__window__settings__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__window__settings__t">pcie_rc_window_settings_t</a></td></tr>
<tr class="separator:structpcie__rc__window__settings__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpcie__rc__msi__window__settings__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__msi__window__settings__t">pcie_rc_msi_window_settings_t</a></td></tr>
<tr class="separator:structpcie__rc__msi__window__settings__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpcie__rc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__instance__ctrl__t">pcie_rc_instance_ctrl_t</a></td></tr>
<tr class="separator:structpcie__rc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpcie__rc__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__extended__cfg__t">pcie_rc_extended_cfg_t</a></td></tr>
<tr class="separator:structpcie__rc__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga324a1a6bba97169834ec01c348df4425"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_c_i_e___r_c.html#ga324a1a6bba97169834ec01c348df4425">pcie_rc_link_mode_t</a> </td></tr>
<tr class="separator:ga324a1a6bba97169834ec01c348df4425"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structpcie__rc__window__settings__t" id="structpcie__rc__window__settings__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__rc__window__settings__t">&#9670;&nbsp;</a></span>pcie_rc_window_settings_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_rc_window_settings_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>AXI/PCIe window setting structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a7d6bfc3d5ecac627fdf38d3ca96e4fec"></a>uint64_t</td>
<td class="fieldname">
base_address</td>
<td class="fielddoc">
AXI/PCIe Window Base address. </td></tr>
<tr><td class="fieldtype">
<a id="ade47d02a30410eccc02d0c9ce92c0de7"></a>uint64_t</td>
<td class="fieldname">
mask_address</td>
<td class="fielddoc">
AXI/PCIe Window Mask address. </td></tr>
<tr><td class="fieldtype">
<a id="ac3c4da78b7645e6581ab6aa13df39a00"></a>uint64_t</td>
<td class="fieldname">
destination_address</td>
<td class="fielddoc">
AXI/PCIe Destination address. </td></tr>
<tr><td class="fieldtype">
<a id="aed688b7e318b1d85d7e0ac902fb13b8d"></a>bool</td>
<td class="fieldname">
window_enable</td>
<td class="fielddoc">
AXI/PCIe Window setting Enable/Disable. </td></tr>
</table>

</div>
</div>
<a name="structpcie__rc__msi__window__settings__t" id="structpcie__rc__msi__window__settings__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__rc__msi__window__settings__t">&#9670;&nbsp;</a></span>pcie_rc_msi_window_settings_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_rc_msi_window_settings_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>MSI window setting structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a779280953a10f1df7104cf551c418942"></a>uint64_t</td>
<td class="fieldname">
base_address</td>
<td class="fielddoc">
MSI Receive Window Base address. </td></tr>
<tr><td class="fieldtype">
<a id="abc662facf8b234300c5e1e77da3920e3"></a>uint64_t</td>
<td class="fieldname">
mask_address</td>
<td class="fielddoc">
MSI Receive Window Mask Address. </td></tr>
<tr><td class="fieldtype">
<a id="ab79cd7b4b04084ae77d092ab12c31281"></a>bool</td>
<td class="fieldname">
window_enable</td>
<td class="fielddoc">
MSI Receive Window setting Enable/Disable. </td></tr>
</table>

</div>
</div>
<a name="structpcie__rc__instance__ctrl__t" id="structpcie__rc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__rc__instance__ctrl__t">&#9670;&nbsp;</a></span>pcie_rc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_rc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Driver instance control structure. </p>
</div>
</div>
</div>
<a name="structpcie__rc__extended__cfg__t" id="structpcie__rc__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpcie__rc__extended__cfg__t">&#9670;&nbsp;</a></span>pcie_rc_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct pcie_rc_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>PCIE_RC extension data structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa051b7b965c8f6c5b2410cb4de71e47b"></a><a class="el" href="group___p_c_i_e___r_c.html#ga324a1a6bba97169834ec01c348df4425">pcie_rc_link_mode_t</a></td>
<td class="fieldname">
link_mode</td>
<td class="fielddoc">
PCI Express Link mode. </td></tr>
<tr><td class="fieldtype">
<a id="a5cee39fc38bb81d58d1d4a301135d744"></a><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__window__settings__t">pcie_rc_window_settings_t</a></td>
<td class="fieldname">
axi_window_settings[R_PCIE_RC_NUM_AXI_WINDOW]</td>
<td class="fielddoc">
Settings the AXI Window (PCIe to AXI) </td></tr>
<tr><td class="fieldtype">
<a id="a767c53bc409e82d825c6299c0d363242"></a><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__window__settings__t">pcie_rc_window_settings_t</a></td>
<td class="fieldname">
pci_window_settings[R_PCIE_RC_NUM_PCIE_WINDOW]</td>
<td class="fielddoc">
Settings the PCIe Window (AXI to PCIe) </td></tr>
<tr><td class="fieldtype">
<a id="a3b3c7c0991cb281270e2bc80b4afdf03"></a><a class="el" href="group___p_c_i_e___r_c.html#structpcie__rc__msi__window__settings__t">pcie_rc_msi_window_settings_t</a></td>
<td class="fieldname">
msi_window_setting</td>
<td class="fielddoc">
Setting the MSI Window. </td></tr>
<tr><td class="fieldtype">
<a id="a864db864ac6c7846f1594eaecd5b9353"></a>uint32_t</td>
<td class="fieldname">
event0_interrupts</td>
<td class="fielddoc">
Event0 interrupt enable bits. </td></tr>
<tr><td class="fieldtype">
<a id="a055868ac082eb4ae1e0986c84c181f4c"></a>uint32_t</td>
<td class="fieldname">
event1_interrupts</td>
<td class="fielddoc">
Event1 interrupt enable bits. </td></tr>
<tr><td class="fieldtype">
<a id="a9546c81ca8883d2ed166c4e85e882feb"></a>IRQn_Type</td>
<td class="fieldname">
msg_irq</td>
<td class="fielddoc">
Message Receive Interrupt Number. </td></tr>
<tr><td class="fieldtype">
<a id="ae25250870c03a6e1585a0b0ddafe4d8d"></a>uint8_t</td>
<td class="fieldname">
msg_ipl</td>
<td class="fielddoc">
Message Receive Interrupt Priority. </td></tr>
<tr><td class="fieldtype">
<a id="a15521d3159bc83ffa3cf553cd423139e"></a>IRQn_Type</td>
<td class="fieldname">
link_width_change_irq</td>
<td class="fielddoc">
Link width change interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a9b1886a459034db3e61b80e69841fffc"></a>uint8_t</td>
<td class="fieldname">
link_width_change_ipl</td>
<td class="fielddoc">
Link width change interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="ac91d99e00ebff8922cbb35613b4e57a4"></a>IRQn_Type</td>
<td class="fieldname">
link_equalization_request_irq</td>
<td class="fielddoc">
Link Equalization Request interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="ae3e2db007a01a2ae963eda6a83ce5216"></a>uint8_t</td>
<td class="fieldname">
link_equalization_request_ipl</td>
<td class="fielddoc">
Link Equalization Request interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="addc030ad64d9e1357a4d669bee04d3a8"></a>IRQn_Type</td>
<td class="fieldname">
poweroff_indication_l2_irq</td>
<td class="fielddoc">
POWEROFF indication on L2 interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="abcb5d670370729ea6ef99af0ba5992ef"></a>uint8_t</td>
<td class="fieldname">
poweroff_indication_l2_ipl</td>
<td class="fielddoc">
POWEROFF indication on L2 interrupt priority. </td></tr>
<tr><td class="fieldtype">
<a id="a048d3c61d5aae5b3bf69c16bc340ea2b"></a>IRQn_Type</td>
<td class="fieldname">
pcie_event_irq</td>
<td class="fielddoc">
Event Interrupt. </td></tr>
<tr><td class="fieldtype">
<a id="a4aa82ccf015ccabfd182166de9d5e29e"></a>uint8_t</td>
<td class="fieldname">
pcie_event_ipl</td>
<td class="fielddoc">
Event Interrupt priority. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga324a1a6bba97169834ec01c348df4425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga324a1a6bba97169834ec01c348df4425">&#9670;&nbsp;</a></span>pcie_rc_link_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___p_c_i_e___r_c.html#ga324a1a6bba97169834ec01c348df4425">pcie_rc_link_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PCI Express Link Mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga324a1a6bba97169834ec01c348df4425ac7973631989681c9c328835275fc77a8"></a>PCIE_RC_LINK_MODE_2LANE_1CHANNEL&#160;</td><td class="fielddoc"><p>PCIe 2 lanes x 1 channel. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga324a1a6bba97169834ec01c348df4425a2b9c3790e28ca59dcf57336eeb7d0d73"></a>PCIE_RC_LINK_MODE_1LANE_2CHANNEL&#160;</td><td class="fielddoc"><p>PCIe 1 lane x 2 channels. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad0b21189fd15a22d0333dd1a69403512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0b21189fd15a22d0333dd1a69403512">&#9670;&nbsp;</a></span>R_PCIE_RC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__cfg__t">pci_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the PCIE_RC API. Implements <a class="el" href="group___p_c_i___a_p_i.html#a79cbaa0de489936dfe4a4567ad2e11f1">pci_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>PCIE_RC successfully initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Invalid input argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2367dddb302cc5e915334e062c62172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2367dddb302cc5e915334e062c62172">&#9670;&nbsp;</a></span>R_PCIE_RC_SelfConfigurationRegisterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_SelfConfigurationRegisterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the value of configuration register of this PCIE. Implements <a class="el" href="group___p_c_i___a_p_i.html#a7af10c6d1a5fede2c64fd4627923434d">pci_api_t::selfConfigurationRegisterGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga669559b157e440b12c54ffc9c56b59e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga669559b157e440b12c54ffc9c56b59e3">&#9670;&nbsp;</a></span>R_PCIE_RC_SelfConfigurationRegisterSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_SelfConfigurationRegisterSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>register_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the value of configuration register of this PCIE device. Implements <a class="el" href="group___p_c_i___a_p_i.html#aaaced4e67f1d55c0a467a58839bab457">pci_api_t::selfConfigurationRegisterSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19b549a3562c5ebcd5fd66c6368ee2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19b549a3562c5ebcd5fd66c6368ee2a8">&#9670;&nbsp;</a></span>R_PCIE_RC_MessageWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_MessageWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing Msg/MsgD Request. Implements <a class="el" href="group___p_c_i___a_p_i.html#a28ced4f2ee19d75d42e6850ca6ffc827">pci_api_t::messageWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The message was issued successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f149ce5123415b0b4bf00c95e4da3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f149ce5123415b0b4bf00c95e4da3f8">&#9670;&nbsp;</a></span>R_PCIE_RC_MessageRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_MessageRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__message__transfer__t">pci_message_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read message data from PCI. Implements <a class="el" href="group___p_c_i___a_p_i.html#ac29888aa807bc3da902467d5ad4fffe3">pci_api_t::messageRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The message was read successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad41bb4177d75b85c4ffe224d537fb2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41bb4177d75b85c4ffe224d537fb2aa">&#9670;&nbsp;</a></span>R_PCIE_RC_ConfigurationRegisterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_ConfigurationRegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga4416af14da0b65e9990414db9e9e7ef3">pci_configuration_write_type_t</a>&#160;</td>
          <td class="paramname"><em>transaction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing CfgWr0/1 Request. Implements <a class="el" href="group___p_c_i___a_p_i.html#a3e27535ff515e7f225147718b6192660">pci_api_t::configurationRegisterWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The configuration write was issued successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab57b920f20120f16b010e5617c287404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57b920f20120f16b010e5617c287404">&#9670;&nbsp;</a></span>R_PCIE_RC_ConfigurationRegisterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_ConfigurationRegisterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#gaf5292151cc185e0b230652e03d785697">pci_configuration_read_type_t</a>&#160;</td>
          <td class="paramname"><em>transaction_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__configuration__register__transfer__t">pci_configuration_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing CfgRd0/1 Request. Implements <a class="el" href="group___p_c_i___a_p_i.html#a9aa57739805e24dbf9468db1168d1166">pci_api_t::configurationRegisterRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The configuration write was issued successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4874ef8466ecdd38557336753c2c346a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4874ef8466ecdd38557336753c2c346a">&#9670;&nbsp;</a></span>R_PCIE_RC_IORegisterWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_IORegisterWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing IOWr Request. API not supported. Implements <a class="el" href="group___p_c_i___a_p_i.html#ad3f4efb2160b728f9bdafe12e4427b6c">pci_api_t::iORegisterWrite</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_RC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga478e5d3425566132042831cdaac82924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga478e5d3425566132042831cdaac82924">&#9670;&nbsp;</a></span>R_PCIE_RC_IORegisterRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_IORegisterRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__io__register__transfer__t">pci_io_register_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issuing IORd Request. API not supported. Implements <a class="el" href="group___p_c_i___a_p_i.html#ae643638be50e3227ecc905f8518a9f9d">pci_api_t::iORegisterRead</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_RC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22461a21fa1bb07ba0500fdabbdce9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22461a21fa1bb07ba0500fdabbdce9f4">&#9670;&nbsp;</a></span>R_PCIE_RC_LinkStatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_LinkStatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__status__t">pci_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the Link status and LTSSM state. Implements <a class="el" href="group___p_c_i___a_p_i.html#a605d81e55617fecf03ee543b640688c0">pci_api_t::linkStatusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The PCI status is in p_status. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ecef08d9c4c45ca21324e75baab2de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ecef08d9c4c45ca21324e75baab2de3">&#9670;&nbsp;</a></span>R_PCIE_RC_IntxAssert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_IntxAssert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assert INTx interrupt Request. API not supported.</p>
<p>Implements <a class="el" href="group___p_c_i___a_p_i.html#a417431a426e07a808425895459c6587b">pci_api_t::intxAssert</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_RC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf13130e1eb3caa7c271cb28ad1cdc79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf13130e1eb3caa7c271cb28ad1cdc79a">&#9670;&nbsp;</a></span>R_PCIE_RC_IntxDeassert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_IntxDeassert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deassert INTx interrupt Request. API not supported.</p>
<p>Implements <a class="el" href="group___p_c_i___a_p_i.html#ad6d5bc97a21acf537238b89084fb1f47">pci_api_t::intxDeassert</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by PCIE_RC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb29748b668e50e432dd7e4161d950a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb29748b668e50e432dd7e4161d950a9">&#9670;&nbsp;</a></span>R_PCIE_RC_LinkWidthChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_LinkWidthChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>link_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the PCI Express link width. Implements <a class="el" href="group___p_c_i___a_p_i.html#aa3fb300545618e863893df76ddc5c6b5">pci_api_t::linkWidthChange</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Required link width is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Link Width change was not done in time and timeout occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0a1948b65b2f2760c28c024129f538f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a1948b65b2f2760c28c024129f538f">&#9670;&nbsp;</a></span>R_PCIE_RC_LinkSpeedChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_LinkSpeedChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#gae98003b04b0361c2f075e0b6cabfa850">pci_link_speed_t</a>&#160;</td>
          <td class="paramname"><em>link_speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the PCI Express link speed. Implements <a class="el" href="group___p_c_i___a_p_i.html#aba141c65f1a1735fe7807c6b2c72784a">pci_api_t::linkSpeedChange</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Required link speed is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Link speed change was not done in time and timeout occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabbbf421fdacba324727bd68726bc2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbbf421fdacba324727bd68726bc2a6">&#9670;&nbsp;</a></span>R_PCIE_RC_LinkEqualizationRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_LinkEqualizationRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requires the PCI Express link equalization request. Implements <a class="el" href="group___p_c_i___a_p_i.html#ace6807efb7c96559f56607f3a7b9cf97">pci_api_t::linkEqualizationRequest</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_TIMEOUT</td><td>Link Equalization was not done in time and timeout occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22c022be4a1f42761121d4e75f9af111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22c022be4a1f42761121d4e75f9af111">&#9670;&nbsp;</a></span>R_PCIE_RC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#structpci__callback__args__t">pci_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback with the option to provide memory for the callback argument structure. Implements <a class="el" href="group___p_c_i___a_p_i.html#a8d751a4ca5bfb0c1afa05508ed68d15a">pci_api_t::callbackSet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4887fd4f72738f056b484f7a3b01933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4887fd4f72738f056b484f7a3b01933">&#9670;&nbsp;</a></span>R_PCIE_RC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_PCIE_RC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___p_c_i___a_p_i.html#ga177f502edcbb6921fa61b347359a2ebf">pci_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the PCIE_RC module. Implements <a class="el" href="group___p_c_i___a_p_i.html#abe39a28509a18a203786dab85062b932">pci_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The module is successfully closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Invalid input argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v2.3.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
