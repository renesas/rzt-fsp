<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZT Flexible Software Package Documentation: Expanded Serial Peripheral Interface (xSPI) HyperBus (r_xspi_hyper)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZT Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___x_s_p_i___h_y_p_e_r.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Expanded Serial Peripheral Interface (xSPI) HyperBus (r_xspi_hyper)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___s_t_o_r_a_g_e___m_o_d_u_l_e_s.html">Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf8a2c741ebcc619ec85b896fedac688b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaf8a2c741ebcc619ec85b896fedac688b">R_XSPI_HYPER_Open</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl, <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__cfg__t">hyperbus_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gaf8a2c741ebcc619ec85b896fedac688b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f866b0d9e5e876018f448642fe9024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga18f866b0d9e5e876018f448642fe9024">R_XSPI_HYPER_Close</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga18f866b0d9e5e876018f448642fe9024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd1bd1a499b711b67881920d5e00a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga0dd1bd1a499b711b67881920d5e00a47">R_XSPI_HYPER_BurstTypeSet</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl, <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga4a303af2d7c438292696f29174791a69">hyperbus_burst_type_t</a> burst_type)</td></tr>
<tr class="separator:ga0dd1bd1a499b711b67881920d5e00a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb7cbd1abbb6230d65f5c80741bd23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaaeb7cbd1abbb6230d65f5c80741bd23c">R_XSPI_HYPER_AccessSpaceSet</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl, <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#gaaae0706da636f984d170cd1651abf04c">hyperbus_space_select_t</a> access_space)</td></tr>
<tr class="separator:gaaeb7cbd1abbb6230d65f5c80741bd23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bd6bcab769c986f4f7d96b135faed66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga1bd6bcab769c986f4f7d96b135faed66">R_XSPI_HYPER_DirectTransfer</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *const p_ctrl, <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__direct__transfer__t">hyperbus_direct_transfer_t</a> *const p_transfer)</td></tr>
<tr class="separator:ga1bd6bcab769c986f4f7d96b135faed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d34dd155d2dea4439cb196c0f97271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga41d34dd155d2dea4439cb196c0f97271">R_XSPI_HYPER_Write</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl, uint8_t const *const p_src, uint8_t *const p_dest, uint32_t byte_count)</td></tr>
<tr class="separator:ga41d34dd155d2dea4439cb196c0f97271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948d860aae9cf93a67762635067b8ddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga948d860aae9cf93a67762635067b8ddf">R_XSPI_HYPER_Erase</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl, uint8_t *const p_device_address, uint32_t byte_count)</td></tr>
<tr class="separator:ga948d860aae9cf93a67762635067b8ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacda208d0dc55871cab5c696388a24bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gacda208d0dc55871cab5c696388a24bc1">R_XSPI_HYPER_StatusGet</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl, <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__status__t">hyperbus_status_t</a> *const p_status)</td></tr>
<tr class="separator:gacda208d0dc55871cab5c696388a24bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f780852e6c6242ed3dc2df2de6a059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gad9f780852e6c6242ed3dc2df2de6a059">R_XSPI_HYPER_AutoCalibrate</a> (<a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:gad9f780852e6c6242ed3dc2df2de6a059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the xSPI peripheral on RZ microprocessor. This module implements the <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html">HyperBus Interface</a>. </p>
<h1><a class="anchor" id="r-xspi-hyper-overview"></a>
Overview</h1>
<p>The HyperBus peripheral interfaces with an external HyperRAM device to perform data I/O Operations.</p>
<h2><a class="anchor" id="r-xspi-hyper-features"></a>
Features</h2>
<p>The xSPI Hyper driver has the following key features to support the <b>HyperRAM</b> device:</p><ul>
<li>Can be configured with HyperRAM device on either of the 2 channels</li>
<li>Memory mapped read and write access to the HyperRAM memory space<a class="anchor" id="um_hyper_ram_read_write_memory_space"></a></li>
<li>Memory mapped read and write access to the HyperRAM register space<a class="anchor" id="um_hyper_ram_read_register_space"></a><a class="anchor" id="um_hyper_ram_write_register_space"></a></li>
<li>Can be configured the access destination address space: memory space or register space<a class="anchor" id="um_hyper_access_space_set"></a></li>
<li>Sending device specific commands and reading back responses<a class="anchor" id="um_hyper_direct_transfer"></a> </li>
</ul>
<h1><a class="anchor" id="r-xspi-hyper-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_xspi_hyper_cs_timing_settings"></a><a class="anchor" id="um_xspi_hyper_prefetch"></a><a class="anchor" id="um_hyper_ram_initial_latency_write"></a> </p><h2>HyperRAM</h2>
<p><h2>Build Time Configurations for r_xspi_hyper</h2>
The following build time configurations are defined in fsp_cfg/r_xspi_hyper_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 0 &gt; Start Address</td><td>Address should be the start address of xspi unit 0 external address space</td><td>0x60000000 </td><td>Start address of xSPI Unit 0 Chip Select 0 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 0 &gt; End Address</td><td>Address should be within xspi unit 0 external address space</td><td>0x600FFFFF </td><td>End address of xSPI Unit 0 Chip Select 1 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 1 &gt; Start Address</td><td>Address should be within xspi unit 0 external address space</td><td>0x64000000 </td><td>Start address of xSPI Unit 0 Chip Select 1 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 1 &gt; End Address</td><td>Address should be within xspi unit 0 external address space</td><td>0x640FFFFF </td><td>End address of xSPI Unit 0 Chip Select 1 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 0 &gt; Start Address</td><td>Address should be the start address of xspi unit 1 external address space</td><td>0x68000000 </td><td>Start address of xSPI Unit 1 Chip Select 0 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 0 &gt; End Address</td><td>Address should be within xspi unit 1 external address space</td><td>0x680FFFFF </td><td>End address of xSPI Unit 1 Chip Select 0 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 1 &gt; Start Address</td><td>Address should be within xspi unit 1 external address space</td><td>0x6C000000 </td><td>Start address of xSPI Unit 1 Chip Select 1 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 1 &gt; End Address</td><td>Address should be within xspi unit 1 external address space</td><td>0x6C0FFFFF </td><td>End address of xSPI Unit 1 Chip Select 1 in memory mapping mode. </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Memory Mapping Address Space Configuration Support</td><td>MCU Specific Options</td><td></td><td>Support status of Memory Mapping Address Space setting on this MCU. If Not supported, the address space set in Memory Mapping Address Space is invalid. </td></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Unit 0 Prefetch Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable prefetch function on memory-mapped reads of xSPI Unit 0. </td></tr>
<tr>
<td>Unit 1 Prefetch Function</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enable</li>
<li>
Disable</li>
</ul>
</td><td>Disable </td><td>Enable prefetch function on memory-mapped reads of xSPI Unit 1. </td></tr>
<tr>
<td>Unit 0 IO voltage</td><td>MCU Specific Options</td><td></td><td>Voltage setting of xSPI Unit 0. </td></tr>
<tr>
<td>Unit 1 IO voltage</td><td>MCU Specific Options</td><td></td><td>Voltage setting of xSPI Unit 1. </td></tr>
</table>
 <h2>Configurations for Storage &gt; HyperRAM (r_xspi_hyper)</h2>
This module can be added to the Stacks tab via New Stack &gt; Storage &gt; HyperRAM (r_xspi_hyper).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_hyperbus0 </td><td>Module name. </td></tr>
<tr>
<td>General &gt; Unit</td><td>Unit should be 0 or 1</td><td>1 </td><td>Specify the XSPI unit number. </td></tr>
<tr>
<td>General &gt; Chip Select</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Chip Select 0</li>
<li>
Chip Select 1</li>
</ul>
</td><td>Chip Select 0 </td><td>Specify the HyperBus chip select line to use. </td></tr>
<tr>
<td>General &gt; RAM Size</td><td>MCU Specific Options</td><td></td><td>Specify the HyperRAM size. </td></tr>
<tr>
<td>General &gt; Initial latency (Read)</td><td>Refer to the RZT Configuration tool for available options.</td><td>6 CYCLES </td><td>Specify the read latency cycle </td></tr>
<tr>
<td>General &gt; Initial latency (Memory Write)</td><td>Refer to the RZT Configuration tool for available options.</td><td>6 CYCLES </td><td>Specify the write latency cycle in memory write </td></tr>
<tr>
<td>General &gt; Initial latency (Register Write)</td><td>Refer to the RZT Configuration tool for available options.</td><td>0 CYCLE (No Latency) </td><td>Specify the write latency cycle in register write </td></tr>
<tr>
<td>HyperBus Transaction Characteristics &gt; Initial Burst Type</td><td>Linear burst (Burst type = 1)</td><td>Linear burst (Burst type = 1) </td><td>Set burst type when driver starts. </td></tr>
<tr>
<td>HyperBus Transaction Characteristics &gt; Initial Access Space</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Memory Space (AS = 0)</li>
<li>
Register Space (AS = 1)</li>
</ul>
</td><td>Memory Space (AS = 0) </td><td>Set the Hyper device access address when starting the driver. </td></tr>
<tr>
<td>Auto Calibration &gt; Data latching delay</td><td>Must be a valid non-negative integer</td><td>0x08 </td><td>Set this to 0 to enable auto-calibration. 0x08 is the default value </td></tr>
<tr>
<td>Auto Calibration &gt; Auto-Calibration Address</td><td>Must be a valid non-negative integer</td><td>0x00 </td><td>Set the address of the read/write destination to be performed for auto-calibration. </td></tr>
<tr>
<td>Bus Timing &gt; CS minimum idle term</td><td>Refer to the RZT Configuration tool for available options.</td><td>7 CYCLES </td><td>Define the CS minimum idle term. </td></tr>
<tr>
<td>Bus Timing &gt; CS Asserting extension</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Extension</li>
<li>
Extend 1 cycle</li>
</ul>
</td><td>No Extension </td><td>Define the CS asserting extension </td></tr>
<tr>
<td>Bus Timing &gt; CS Negating extension</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
No Extension</li>
<li>
Extend 1 cycle</li>
</ul>
</td><td>No Extension </td><td>Define the CS negating extension </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-xspi-hyper-clock-configuration"></a>
Clock Configuration</h2>
<p>The XSPI_CLKn frequencies can be set on the <b>Clocks</b> tab of FSP Configuration editor or by using the CGC Interface at run-time.</p>
<h2><a class="anchor" id="r-xspi-hyper-pin-configuration"></a>
Pin Configuration</h2>
<p>The following pins are available to connect to an external Hyper device:</p><ul>
<li>XSPIn_CKP/CKN: HyperBus clock positive/negative output(Differential Clock. Command, address, and data information is output with respect to the crossing of these signals.)</li>
<li>XSPIn_RWDS: HyperBus Read-Write-Data-Strobe signal</li>
<li>XSPIn_CS0: HyperBus device 0 select</li>
<li>XSPIn_CS1: HyperBus device 1 select</li>
<li>XSPIn_IO0: DQ 0 I/O</li>
<li>XSPIn_IO1: DQ 1 I/O</li>
<li>XSPIn_IO2: DQ 2 I/O</li>
<li>XSPIn_IO3: DQ 3 I/O</li>
<li>XSPIn_IO4: DQ 4 I/O</li>
<li>XSPIn_IO5: DQ 5 I/O</li>
<li>XSPIn_IO6: DQ 6 I/O</li>
<li>XSPIn_IO7: DQ 7 I/O</li>
</ul>
<h1><a class="anchor" id="r-xspi-hyper-usage-notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-xspi-memory-mapped-access"></a>
HYPER Memory Mapped Access</h2>
<p>After <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaf8a2c741ebcc619ec85b896fedac688b">R_XSPI_HYPER_Open()</a> completes successfully, the HYPER device contents are mapped to External Address Space xSPIn or their mirror spaces and can be read like on-chip memory. Please refer to xSPI "Overview" section in your device's manual on address map details.</p>
<p>In the configurator properties, 'Memory Mapping Address Space Configuration Support' is set to either 'Supported' or 'Not Supported' depending on your device. The method of memory mapped access address configuration depends on the value of 'Memory Mapping Address Space Configuration Support'.</p>
<h3>Example Configurations for the Device 'Memory Mapping Address Space Configuration Support' is 'Supported'</h3>
<p>If 'Memory Mapping Address Space Configuration Support' is 'Supported', 'Memory Mapping Address Space' should be set appropriately for your device. The table below shows an example of 'Memory Mapping Address Space' configurations when 64MB memory is used as a slave device in each Chip Select.</p>
<table class="doxtable">
<tr>
<th>Properties </th><th>RZ/T2ME </th><th>RZ/T2H  </th></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 0 &gt; Start Address </td><td>0x60000000 (Fixed) </td><td>0x40000000 (Fixed) </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 0 &gt; End Address </td><td>0x63FFFFFF </td><td>0x43FFFFFF </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 1 &gt; Start Address </td><td>0x64000000 </td><td>0x48000000 </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 0 &gt; Chip Select 1 &gt; End Address </td><td>0x67FFFFFF </td><td>0x4BFFFFFF </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 0 &gt; Start Address </td><td>0x68000000 (Fixed) </td><td>0x50000000 (Fixed) </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 0 &gt; End Address </td><td>0x6BFFFFFF </td><td>0x53FFFFFF </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 1 &gt; Start Address </td><td>0x6C000000 </td><td>0x58000000 </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Unit 1 &gt; Chip Select 1 &gt; End Address </td><td>0x6FFFFFFF </td><td>0x5BFFFFFF </td></tr>
<tr>
<td>Memory Mapping Address Space &gt; Memory Mapping Address Space Configuration Support </td><td>Supported </td><td>Supported </td></tr>
</table>
<p>The address space of each chip select set by the above configuration is as follows.</p>
<table class="doxtable">
<tr>
<th>Address Space of Each Chip Select </th><th>RZ/T2ME </th><th>RZ/T2H  </th></tr>
<tr>
<td>Unit 0 Chip Select 0 Start Address </td><td>0x60000000 (Fixed) </td><td>0x40000000 (Fixed) </td></tr>
<tr>
<td>Unit 0 Chip Select 0 End Address </td><td>0x63FFFFFF </td><td>0x43FFFFFF </td></tr>
<tr>
<td>Unit 0 Chip Select 1 Start Address </td><td>0x64000000 </td><td>0x48000000 </td></tr>
<tr>
<td>Unit 0 Chip Select 1 End Address </td><td>0x67FFFFFF </td><td>0x4BFFFFFF </td></tr>
<tr>
<td>Unit 1 Chip Select 0 Start Address </td><td>0x68000000 (Fixed) </td><td>0x50000000 (Fixed) </td></tr>
<tr>
<td>Unit 1 Chip Select 0 End Address </td><td>0x6BFFFFFF </td><td>0x53FFFFFF </td></tr>
<tr>
<td>Unit 1 Chip Select 1 Start Address </td><td>0x6C000000 </td><td>0x58000000 </td></tr>
<tr>
<td>Unit 1 Chip Select 1 End Address </td><td>0x6FFFFFFF </td><td>0x5BFFFFFF </td></tr>
</table>
<h3>Example Configurations for the Device 'Memory Mapping Address Space Configuration Support' is 'Not Supported'</h3>
<p>If 'Memory Mapping Address Space Configuration Support' is 'Not Supported' for your device, 'Memory Mapping Address Space' configurations are invalid. In this case, the start address of each chip select is fixed by device, and only the size of the address space is configured in 'Memory Size' property. The table below shows an example of the address space configuration when 64MB memory is used as a slave device in Unit 0 Chip Select 0.</p>
<table class="doxtable">
<tr>
<th>Properties </th><th>RZ/T2M </th><th>RZ/T2L  </th></tr>
<tr>
<td>Memory Mapping Address Space &gt; Memory Mapping Address Space Configuration Support </td><td>Not Supported </td><td>Not Supported </td></tr>
<tr>
<td>General &gt; Unit </td><td>0 </td><td>0 </td></tr>
<tr>
<td>General &gt; Chip Select </td><td>0 </td><td>0 </td></tr>
<tr>
<td>General &gt; Memory Size </td><td>64MB </td><td>64MB </td></tr>
</table>
<p>The address space of each chip select set by the above configuration is as follows. </p><table class="doxtable">
<tr>
<th>Address Space of Each Chip Select </th><th>RZ/T2M </th><th>RZ/T2L  </th></tr>
<tr>
<td>Unit 0 Chip Select 0 Start Address </td><td>0x60000000 (Fixed) </td><td>0x60000000 (Fixed) </td></tr>
<tr>
<td>Unit 0 Chip Select 0 End Address </td><td>0x63FFFFFF (64MB Size) </td><td>0x63FFFFFF (64MB Size) </td></tr>
<tr>
<td>Unit 0 Chip Select 1 Start Address </td><td>0x64000000 (Fixed) </td><td>0x64000000 (Fixed) </td></tr>
<tr>
<td>Unit 0 Chip Select 1 End Address </td><td>0x640FFFFF (default) </td><td>0x640FFFFF (default) </td></tr>
<tr>
<td>Unit 1 Chip Select 0 Start Address </td><td>0x68000000 (Fixed) </td><td>0x68000000 (Fixed) </td></tr>
<tr>
<td>Unit 1 Chip Select 0 End Address </td><td>0x680FFFFF (default) </td><td>0x680FFFFF (default) </td></tr>
<tr>
<td>Unit 1 Chip Select 1 Start Address </td><td>0x6C000000 (Fixed) </td><td>0x6C000000 (Fixed) </td></tr>
<tr>
<td>Unit 1 Chip Select 1 End Address </td><td>0x6C0FFFFF (default) </td><td>0x6C0FFFFF (default) </td></tr>
</table>
<h2><a class="anchor" id="r-xspi-hyper-access-space-select"></a>
Dynamic address space selection (Memory and Register)</h2>
<p>This driver allows user to dynamically select whether to access memory space or register space. Call <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaaeb7cbd1abbb6230d65f5c80741bd23c">R_XSPI_HYPER_AccessSpaceSet()</a>, and assign HYPERBUS_SPACE_SELECT_MEMORY_SPACE or HYPERBUS_SPACE_SELECT_REGISTER_SPACE to the second argument.</p>
<p>Note that register space access is in limited situations, such as when changing the HyperRAM device-specific configuration.</p>
<h2><a class="anchor" id="r-xspi-hyper-limitations"></a>
Limitations</h2>
<ul>
<li>Prefetch function support for memory-mapping access is applied to all slave devices connected xSPI0 or xSPI1. When using different types of xSPI modules (for example, xSPI_HYPER and xSPI_OSPI) to same xSPI unit, make sure that the prefetch function settings in the configurator properties are the same.</li>
<li>In the configurator properties, when 'Memory Mapping Address Space Configuration Support' is 'Supported', memory mapping address space settings are applied to all slave devices connected xSPI0 or xSPI1. When using different types of xSPI modules (for example, xSPI_HYPER and xSPI_OSPI), make sure that 'Memory Mapping Address Space' settings are the same for all xSPI modules.</li>
<li>When accessing register space in memory mapping, make sure that the memory attribute of the xSPI address space is device memory attribute.</li>
</ul>
<h1><a class="anchor" id="r-xspi-hyper-examples"></a>
Examples</h1>
<h2><a class="anchor" id="r-xspi-hyper-examples-basic"></a>
Basic Example</h2>
<p>This is a basic example of minimal use of the HyperBus module in an application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH    (256)</span></div><div class="line">uint16_t write_data[XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH];</div><div class="line">uint16_t read_data[XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_xspi_hyper_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Write some data to the write buffer */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        write_data[i] = i;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Open the XSPI_HYPER instance */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#gaf8a2c741ebcc619ec85b896fedac688b">R_XSPI_HYPER_Open</a>(&amp;g_hyperbus_ctrl, &amp;g_hyperbus_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* After R_XSPI_HYPER_Open() and any required device specific initialization, data can be write directly</span></div><div class="line"><span class="comment">     * to the HyperRAM connected to XSPI unit 1 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        *((<span class="keyword">volatile</span> uint16_t *) HYPERRAM_BASE_ADDRESS + 0x0000 + i) = write_data[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* After R_XSPI_HYPER_Open() and any required device specific initialization, data can be read directly</span></div><div class="line"><span class="comment">     * to the HyperRAM connected to XSPI unit 1 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        read_data[i] = *((<span class="keyword">volatile</span> uint16_t *) HYPERRAM_BASE_ADDRESS + 0x0000 + i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the read data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (read_data[i] != write_data[i])</div><div class="line">        {</div><div class="line">            <span class="comment">/* Verify error. */</span></div><div class="line">            __BKPT(0);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        ;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Register Space Access Example (R_XSPI_HYPER_AccessSpaceSet)</h2>
<p>This is an example of using <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaaeb7cbd1abbb6230d65f5c80741bd23c">R_XSPI_HYPER_AccessSpaceSet()</a> to change the address space from memory to register.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HYPERRAM_DEVICE_ID_REGISTER0_ADDRESS    (0x0U)</span></div><div class="line"><span class="preprocessor">#define HYPERRAM_ID_REGISTER0_DEFAULT_VALUE     (0x0C81U)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_xspi_hyper_access_space_register_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Open the XSPI_HYPER instance */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#gaf8a2c741ebcc619ec85b896fedac688b">R_XSPI_HYPER_Open</a>(&amp;g_hyperbus_ctrl, &amp;g_hyperbus_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Change address space to register space */</span></div><div class="line">    err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#gaaeb7cbd1abbb6230d65f5c80741bd23c">R_XSPI_HYPER_AccessSpaceSet</a>(&amp;g_hyperbus_ctrl, <a class="code" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ggaaae0706da636f984d170cd1651abf04ca83236d9b6814def686db93fbfc6802cb">HYPERBUS_SPACE_SELECT_REGISTER_SPACE</a>);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Reading ID register 0 with Memory-mapping */</span></div><div class="line">    <span class="keyword">volatile</span> uint16_t * p_id_register0_addr = (uint16_t *) HYPERRAM_BASE_ADDRESS +</div><div class="line">                                              HYPERRAM_DEVICE_ID_REGISTER0_ADDRESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the ID register0 value. Apply __REV16 to account for endian difference. */</span></div><div class="line">    <span class="keywordflow">if</span> (__REV16(HYPERRAM_ID_REGISTER0_DEFAULT_VALUE) != *p_id_register0_addr)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Verify error. */</span></div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Reading Status Register Example (R_XSPI_HYPER_DirectTransfer)</h2>
<p>This is an example of using R_XSPI_HYPER_DirectTransfer with read direction to read identification register 0 value from HyperRAM device.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HYPERRAM_CA_ID_REGISTER_0_READ         (0xE00000000000U)</span></div><div class="line"><span class="preprocessor">#define HYPERRAM_ID_REGISTER0_DEFAULT_VALUE    (0x0C81U)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_xspi_hyper_direct_transfer_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__direct__transfer__t">hyperbus_direct_transfer_t</a> hyper_direct_transfer_id =</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set Command-Address bits to access ID Register 0 Read. */</span></div><div class="line">        .<a class="code" href="group___h_y_p_e_r_b_u_s___a_p_i.html#a4a40b834ebb8273504ba7747cdb8f9b7">command_address</a>.command_address_info = (uint64_t) HYPERRAM_CA_ID_REGISTER_0_READ,</div><div class="line">        .data_length  = 2,</div><div class="line">        .dummy_cycles = 6,</div><div class="line"></div><div class="line">        <span class="comment">/* Read data is stored in .data member. */</span></div><div class="line">        .data                                 = 0,</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Open the XSPI_HYPER instance */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#gaf8a2c741ebcc619ec85b896fedac688b">R_XSPI_HYPER_Open</a>(&amp;g_hyperbus_ctrl, &amp;g_hyperbus_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Send transaction to read ID Register 0 */</span></div><div class="line">    err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#ga1bd6bcab769c986f4f7d96b135faed66">R_XSPI_HYPER_DirectTransfer</a>(&amp;g_hyperbus_ctrl, &amp;hyper_direct_transfer_id);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Verify the ID register0 value. Apply __REV16 to account for endian difference. */</span></div><div class="line">    <span class="keywordflow">if</span> (__REV16(HYPERRAM_ID_REGISTER0_DEFAULT_VALUE) != hyper_direct_transfer_id.data)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Verify error. */</span></div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Change Initial Latency Example (R_XSPI_HYPER_DirectTransfer)</h2>
<p>This is an example of changing the initial latency of HyperRAM. By sending register access command, rewrite the value of Confiugration register 0 of HyperRAM device.</p>
<dl class="section note"><dt>Note</dt><dd>This is a setting example specific to the HyperRAM device installed in RZ/T2M RSK. Please refer to the respective device datasheet for details. </dd>
<dd>
When using this example code, Set module configuration value as below.<ul>
<li>General &gt; Initial latency (Read) is 4 CYCLES</li>
<li>General &gt; Initial latency (Memory Write) is 4 CYCLES</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define HYPERRAM_CA_CONFIGURATION_REGISTER_0_WRITE                     (0x600001000000U)</span></div><div class="line"><span class="preprocessor">#define HYPERRAM_CONFIGURATION_REGISTER0_DEFAULT_VALUE                 (0x1F8FU)</span></div><div class="line"><span class="preprocessor">#define HYPERRAM_CONFIGURATION_REGISTER0_INITIAL_LATENCY_4CLOCK_SET    (0xFU)</span></div><div class="line"><span class="preprocessor">#define HYPERRAM_CONFIGURATION_REGISTER0_INITIAL_LATENCY_VALUE_MASK    (0xFF0FU)</span></div><div class="line"><span class="preprocessor">#define HYPERRAM_CONFIGURATION_REGISTER0_INITIAL_LATENCY_OFFSET        (4U)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH                              (256)</span></div><div class="line">uint16_t write_data[XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH];</div><div class="line">uint16_t read_data[XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH];</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> r_xspi_hyper_change_initial_latency_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__direct__transfer__t">hyperbus_direct_transfer_t</a> hyper_direct_transfer =</div><div class="line">    {</div><div class="line">        <span class="comment">/* Set Command-Address bits to access Configuration Register 0 Write. */</span></div><div class="line">        .<a class="code" href="group___h_y_p_e_r_b_u_s___a_p_i.html#a4a40b834ebb8273504ba7747cdb8f9b7">command_address</a>.command_address_info = (uint64_t) HYPERRAM_CA_CONFIGURATION_REGISTER_0_WRITE,</div><div class="line">        .data_length  = 2,</div><div class="line">        .dummy_cycles = 6,</div><div class="line"></div><div class="line">        <span class="comment">/* Set the value of CR0 in the byte order of HyperBus protocol compliant.</span></div><div class="line"><span class="comment">         * Initial latency will be changed from 6 cycles(default) to 4 cycles.</span></div><div class="line"><span class="comment">         * (in HyperRAM with RZ/T2M RSK, the function bit of initial latency is CR0[7-4]) */</span></div><div class="line">        .data                                 =</div><div class="line">            __REV16((HYPERRAM_CONFIGURATION_REGISTER0_INITIAL_LATENCY_4CLOCK_SET &lt;&lt;</div><div class="line">                     HYPERRAM_CONFIGURATION_REGISTER0_INITIAL_LATENCY_OFFSET) |</div><div class="line">                    (HYPERRAM_CONFIGURATION_REGISTER0_DEFAULT_VALUE &amp;</div><div class="line">                     HYPERRAM_CONFIGURATION_REGISTER0_INITIAL_LATENCY_VALUE_MASK)),</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Open the XSPI_HYPER instance */</span></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#gaf8a2c741ebcc619ec85b896fedac688b">R_XSPI_HYPER_Open</a>(&amp;g_hyperbus_ctrl, &amp;g_hyperbus_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Send transaction to update Configuration Register 0 */</span></div><div class="line">    err = <a class="code" href="group___x_s_p_i___h_y_p_e_r.html#ga1bd6bcab769c986f4f7d96b135faed66">R_XSPI_HYPER_DirectTransfer</a>(&amp;g_hyperbus_ctrl, &amp;hyper_direct_transfer);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Write some data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        write_data[i] = i;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* After R_XSPI_HYPER_Open() and any required device specific initialization, data can be write directly</span></div><div class="line"><span class="comment">     * to the HyperRAM connected to XSPI unit 1 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        *((<span class="keyword">volatile</span> uint16_t *) HYPERRAM_BASE_ADDRESS + 0x0000 + i) = write_data[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* After R_XSPI_HYPER_Open() and any required device specific initialization, data can be read directly</span></div><div class="line"><span class="comment">     * to the HyperRAM connected to XSPI unit 1 */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        read_data[i] = *((<span class="keyword">volatile</span> uint16_t *) HYPERRAM_BASE_ADDRESS + 0x0000 + i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the read data */</span></div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; XSPI_HYPERRAM_EXAMPLE_DATA_LENGTH; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (read_data[i] != write_data[i])</div><div class="line">        {</div><div class="line">            <span class="comment">/* Verify error. */</span></div><div class="line">            __BKPT(0);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The initial latency can be changed by changing the settings of bits [7:4] of CR0. The sample code describes the case of changing from the factory default 6 cycle latency (at a maximum operating frequency of 166 MHz) to 4 cycle latency (at a maximum operating frequency of 100 MHz). Set the latency cycle for the HyperBus controller and HyperRAM according to the specification of the using HyperRAM.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structxspi__hyper__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#structxspi__hyper__instance__ctrl__t">xspi_hyper_instance_ctrl_t</a></td></tr>
<tr class="separator:structxspi__hyper__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga585ed0d7516ff895de6ea0c98d602ce3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga585ed0d7516ff895de6ea0c98d602ce3">xspi_hyper_chip_select_t</a> </td></tr>
<tr class="separator:ga585ed0d7516ff895de6ea0c98d602ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589217595b3f7033749a79e31d03717b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga589217595b3f7033749a79e31d03717b">xspi_hyper_device_type_t</a> </td></tr>
<tr class="separator:ga589217595b3f7033749a79e31d03717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab2852ecb0fb609dd472ca66ffaee1c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga3ab2852ecb0fb609dd472ca66ffaee1c">xspi_hyper_memory_size_t</a> </td></tr>
<tr class="separator:ga3ab2852ecb0fb609dd472ca66ffaee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2991cbbbbcce92799356a9f55e7403"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaed2991cbbbbcce92799356a9f55e7403">xspi_hyper_transaction_interval_clocks_t</a> </td></tr>
<tr class="separator:gaed2991cbbbbcce92799356a9f55e7403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab712168989db83eda78b55e5fd7e0b94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gab712168989db83eda78b55e5fd7e0b94">xspi_hyper_cs_pulldown_clocks_t</a> </td></tr>
<tr class="separator:gab712168989db83eda78b55e5fd7e0b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da98bb87115fcb5bb303fd619c8d76b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga0da98bb87115fcb5bb303fd619c8d76b">xspi_hyper_cs_pullup_clocks_t</a> </td></tr>
<tr class="separator:ga0da98bb87115fcb5bb303fd619c8d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b84328e019d51f1b017e089cd0330b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gab1b84328e019d51f1b017e089cd0330b">xspi_hyper_prefetch_function_t</a> </td></tr>
<tr class="separator:gab1b84328e019d51f1b017e089cd0330b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74610755ec73d9392b07945cb01ce0ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga74610755ec73d9392b07945cb01ce0ec">xspi_hyper_io_voltage_t</a> </td></tr>
<tr class="separator:ga74610755ec73d9392b07945cb01ce0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structxspi__hyper__instance__ctrl__t" id="structxspi__hyper__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structxspi__hyper__instance__ctrl__t">&#9670;&nbsp;</a></span>xspi_hyper_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xspi_hyper_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Instance control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#aef6c90f5c5a94e43fc65ffaf4d7d9133">hyperbus_api_t::open</a> is called </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga585ed0d7516ff895de6ea0c98d602ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585ed0d7516ff895de6ea0c98d602ce3">&#9670;&nbsp;</a></span>xspi_hyper_chip_select_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga585ed0d7516ff895de6ea0c98d602ce3">xspi_hyper_chip_select_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga585ed0d7516ff895de6ea0c98d602ce3a9adac39894c50c962d55fd22fc8b77c7"></a>XSPI_HYPER_CHIP_SELECT_0&#160;</td><td class="fielddoc"><p>Device connected to Chip-Select 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga585ed0d7516ff895de6ea0c98d602ce3ac92c314d90380329350dd453ff380ce8"></a>XSPI_HYPER_CHIP_SELECT_1&#160;</td><td class="fielddoc"><p>Device connected to Chip-Select 1. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga589217595b3f7033749a79e31d03717b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga589217595b3f7033749a79e31d03717b">&#9670;&nbsp;</a></span>xspi_hyper_device_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga589217595b3f7033749a79e31d03717b">xspi_hyper_device_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga589217595b3f7033749a79e31d03717baee9b850a0c415f23d1ca2db5d68ee3da"></a>XSPI_HYPER_DEVICE_TYPE_FLASH&#160;</td><td class="fielddoc"><p>Device Memory type HyperFlash. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga589217595b3f7033749a79e31d03717ba6c3ee738d3aa98f3e72862d845f9f252"></a>XSPI_HYPER_DEVICE_TYPE_RAM&#160;</td><td class="fielddoc"><p>Device Memory type HyperRAM. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3ab2852ecb0fb609dd472ca66ffaee1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab2852ecb0fb609dd472ca66ffaee1c">&#9670;&nbsp;</a></span>xspi_hyper_memory_size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga3ab2852ecb0fb609dd472ca66ffaee1c">xspi_hyper_memory_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1ca47b30e038f462db81c0f3db1e54343b8"></a>XSPI_HYPER_MEMORY_SIZE_1MB&#160;</td><td class="fielddoc"><p>Memory size 1MB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1ca562d69826b2b8e7a441bc02eb58599fc"></a>XSPI_HYPER_MEMORY_SIZE_2MB&#160;</td><td class="fielddoc"><p>Memory size 2MB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1ca71224ac802131152a6622c71f5283eef"></a>XSPI_HYPER_MEMORY_SIZE_4MB&#160;</td><td class="fielddoc"><p>Memory size 4MB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1ca67b343ac6b00e6a037b98e6fdf2b6a89"></a>XSPI_HYPER_MEMORY_SIZE_8MB&#160;</td><td class="fielddoc"><p>Memory size 8MB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1caa776079ecec0d0db54236a9ad982b3fd"></a>XSPI_HYPER_MEMORY_SIZE_16MB&#160;</td><td class="fielddoc"><p>Memory size 16MB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1caba9a9eefc70f08101b912eeac80d2d32"></a>XSPI_HYPER_MEMORY_SIZE_32MB&#160;</td><td class="fielddoc"><p>Memory size 32MB. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3ab2852ecb0fb609dd472ca66ffaee1ca4936202f2fdc8d56d3e6f9edd93c824a"></a>XSPI_HYPER_MEMORY_SIZE_64MB&#160;</td><td class="fielddoc"><p>Memory size 64MB. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaed2991cbbbbcce92799356a9f55e7403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed2991cbbbbcce92799356a9f55e7403">&#9670;&nbsp;</a></span>xspi_hyper_transaction_interval_clocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gaed2991cbbbbcce92799356a9f55e7403">xspi_hyper_transaction_interval_clocks_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a927643cff429a8e5269c41510652f914"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_1&#160;</td><td class="fielddoc"><p>1 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a99c7fd84f338bfe3579a884ca137b9b9"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_2&#160;</td><td class="fielddoc"><p>2 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a81d452ec698f3514badd7620503911a4"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_3&#160;</td><td class="fielddoc"><p>3 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a97ba8fa166961229b5b5539c7fab82d2"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_4&#160;</td><td class="fielddoc"><p>4 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a62334f4e4a742600fe278197be8e89e5"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_5&#160;</td><td class="fielddoc"><p>5 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a5b387342e9fb802195c85c8340458685"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_6&#160;</td><td class="fielddoc"><p>6 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403abb236b3ef674fab6a107d72b18bf7e19"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_7&#160;</td><td class="fielddoc"><p>7 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a631bffa7ab69cafa07ea77aa079beec5"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_8&#160;</td><td class="fielddoc"><p>8 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403aa856c0948c338f8c3dab9d24acac33fc"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_9&#160;</td><td class="fielddoc"><p>9 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403adf4ebedb81c1fde1d616f6bdfe928017"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_10&#160;</td><td class="fielddoc"><p>10 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403aa1cd4f04c9f31d05364c4ad906aab0a7"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_11&#160;</td><td class="fielddoc"><p>11 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a36036a2d0703ac95382e3fcdf37f5590"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_12&#160;</td><td class="fielddoc"><p>12 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a72c3cf6915cd38ff284b78de235b9d63"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_13&#160;</td><td class="fielddoc"><p>13 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403aeddf7653a201e57d50b85b4f508674e1"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_14&#160;</td><td class="fielddoc"><p>14 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a0c279e9a627d7eec95eef9b7e418249a"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_15&#160;</td><td class="fielddoc"><p>15 interval clocks </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaed2991cbbbbcce92799356a9f55e7403a25a6762f6a97ea52fa494c3219fd92cb"></a>XSPI_HYPER_TRANSACTION_INTERVAL_CLOCKS_16&#160;</td><td class="fielddoc"><p>16 interval clocks </p>
</td></tr>
</table>

</div>
</div>
<a id="gab712168989db83eda78b55e5fd7e0b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab712168989db83eda78b55e5fd7e0b94">&#9670;&nbsp;</a></span>xspi_hyper_cs_pulldown_clocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gab712168989db83eda78b55e5fd7e0b94">xspi_hyper_cs_pulldown_clocks_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab712168989db83eda78b55e5fd7e0b94a9387b8b6b39210df1f85e3c7a270178f"></a>XSPI_HYPER_CS_PULLDOWN_CLOCKS_NO_EXTENSION&#160;</td><td class="fielddoc"><p>CS asserting No extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab712168989db83eda78b55e5fd7e0b94a2e32527fec60ef2f47d1cdffe22e9b7f"></a>XSPI_HYPER_CS_PULLDOWN_CLOCKS_1&#160;</td><td class="fielddoc"><p>CS asserting Extend 1 cycle. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0da98bb87115fcb5bb303fd619c8d76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0da98bb87115fcb5bb303fd619c8d76b">&#9670;&nbsp;</a></span>xspi_hyper_cs_pullup_clocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga0da98bb87115fcb5bb303fd619c8d76b">xspi_hyper_cs_pullup_clocks_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0da98bb87115fcb5bb303fd619c8d76bad37491c445bdb04a8db0476b7e1bc2bf"></a>XSPI_HYPER_CS_PULLUP_CLOCKS_NO_EXTENSION&#160;</td><td class="fielddoc"><p>CS negating No extension. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0da98bb87115fcb5bb303fd619c8d76ba9669e5b16d9ee934ee08c09728efdba1"></a>XSPI_HYPER_CS_PULLUP_CLOCKS_1&#160;</td><td class="fielddoc"><p>CS negating Extend 1 cycle. </p>
</td></tr>
</table>

</div>
</div>
<a id="gab1b84328e019d51f1b017e089cd0330b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b84328e019d51f1b017e089cd0330b">&#9670;&nbsp;</a></span>xspi_hyper_prefetch_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#gab1b84328e019d51f1b017e089cd0330b">xspi_hyper_prefetch_function_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab1b84328e019d51f1b017e089cd0330baac2e3a39b0a0804c9e34ff65e55c24f4"></a>XSPI_HYPER_PREFETCH_FUNCTION_DISABLE&#160;</td><td class="fielddoc"><p>Prefetch function disable. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab1b84328e019d51f1b017e089cd0330ba869484640fd3c040179e9dc41028d9f2"></a>XSPI_HYPER_PREFETCH_FUNCTION_ENABLE&#160;</td><td class="fielddoc"><p>Prefetch function enable. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga74610755ec73d9392b07945cb01ce0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74610755ec73d9392b07945cb01ce0ec">&#9670;&nbsp;</a></span>xspi_hyper_io_voltage_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___x_s_p_i___h_y_p_e_r.html#ga74610755ec73d9392b07945cb01ce0ec">xspi_hyper_io_voltage_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga74610755ec73d9392b07945cb01ce0eca6afa5e0173d8808fac374aa316bc7648"></a>XSPI_HYPER_IO_VOLTAGE_1_8V&#160;</td><td class="fielddoc"><p>IO voltage 1.8V. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga74610755ec73d9392b07945cb01ce0ecac5024b764881836a70a06ca2463ad697"></a>XSPI_HYPER_IO_VOLTAGE_3_3V&#160;</td><td class="fielddoc"><p>IO voltage 3.3V. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf8a2c741ebcc619ec85b896fedac688b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a2c741ebcc619ec85b896fedac688b">&#9670;&nbsp;</a></span>R_XSPI_HYPER_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__cfg__t">hyperbus_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open the HYPER driver module. After the driver is open, the HyperRAM can be accessed like internal memory.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#aef6c90f5c5a94e43fc65ffaf4d7d9133">hyperbus_api_t::open</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl or p_cfg is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Driver has already been opened with the same p_ctrl. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18f866b0d9e5e876018f448642fe9024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f866b0d9e5e876018f448642fe9024">&#9670;&nbsp;</a></span>R_XSPI_HYPER_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the HYPER driver module.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ae9977d51a242df3cd21e8abb4424b8e6">hyperbus_api_t::close</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Configuration was successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>p_instance_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If another chip select of the same unit is used by other drivers, the other chip select operation will also stop when this function is executed. </dd></dl>

</div>
</div>
<a id="ga0dd1bd1a499b711b67881920d5e00a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dd1bd1a499b711b67881920d5e00a47">&#9670;&nbsp;</a></span>R_XSPI_HYPER_BurstTypeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_BurstTypeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga4a303af2d7c438292696f29174791a69">hyperbus_burst_type_t</a>&#160;</td>
          <td class="paramname"><em>burst_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamic burst type configuration.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#a0bda295fe6536d760a1fd8e8bb3933f0">hyperbus_api_t::burstTypeSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by Hyper - HyperRAM. (Only can use Linear Burst) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaeb7cbd1abbb6230d65f5c80741bd23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaeb7cbd1abbb6230d65f5c80741bd23c">&#9670;&nbsp;</a></span>R_XSPI_HYPER_AccessSpaceSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_AccessSpaceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#gaaae0706da636f984d170cd1651abf04c">hyperbus_space_select_t</a>&#160;</td>
          <td class="paramname"><em>access_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dynamic access address space configuration.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#afc8cc6488b7263d4183a1600ba1dab25">hyperbus_api_t::accessSpaceSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Address space successfully changed as specified by the argument. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>The parameter p_ctrl is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1bd6bcab769c986f4f7d96b135faed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bd6bcab769c986f4f7d96b135faed66">&#9670;&nbsp;</a></span>R_XSPI_HYPER_DirectTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_DirectTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__direct__transfer__t">hyperbus_direct_transfer_t</a> *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read/Write raw data directly with the HyperRAM.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#a3d08a9c6918b8b6932e0d15b5b21fd88">hyperbus_api_t::directTransfer</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>The flash was programmed successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Driver is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41d34dd155d2dea4439cb196c0f97271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41d34dd155d2dea4439cb196c0f97271">&#9670;&nbsp;</a></span>R_XSPI_HYPER_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Program a page of data to the flash.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#a5d12f7a396114f4509de4b5b3f2fee11">hyperbus_api_t::write</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by HyperBus - HyperRAM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga948d860aae9cf93a67762635067b8ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga948d860aae9cf93a67762635067b8ddf">&#9670;&nbsp;</a></span>R_XSPI_HYPER_Erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_Erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>p_device_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erase a block or sector of flash. The byte_count must exactly match one of the erase sizes defined in <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__cfg__t">hyperbus_cfg_t</a>. For chip erase, byte_count must be HYPER_FLASH_ERASE_SIZE_CHIP_ERASE.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ae6250081482ac1a88d195860018bbad8">hyperbus_api_t::erase</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by HyperBus - HyperRAM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacda208d0dc55871cab5c696388a24bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacda208d0dc55871cab5c696388a24bc1">&#9670;&nbsp;</a></span>R_XSPI_HYPER_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#structhyperbus__status__t">hyperbus_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the write or erase status of the flash.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ae606a7a11c7c48e6dbb804a208078c40">hyperbus_api_t::statusGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by HyperBus - HyperRAM. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9f780852e6c6242ed3dc2df2de6a059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f780852e6c6242ed3dc2df2de6a059">&#9670;&nbsp;</a></span>R_XSPI_HYPER_AutoCalibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_XSPI_HYPER_AutoCalibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#ga76e479fdbeed623a1b44f162a6bad31e">hyperbus_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auto-calibrate the HyperRAM device using the preamble pattern.</p>
<p>Implements <a class="el" href="group___h_y_p_e_r_b_u_s___a_p_i.html#a63bb5fad782082d0f4e9033bef2ba8ef">hyperbus_api_t::autoCalibrate</a>. </p><dl class="section note"><dt>Note</dt><dd>The preamble pattern must be written to the configured address before calling this API.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>API not supported by HyperBus - HyperFlash. (Planned support for FSP v2.1.0 or later.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright © (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
