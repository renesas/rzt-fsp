<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RZT Flexible Software Package Documentation: ADC (r_adc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RZT Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.0.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_d_c.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">ADC (r_adc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a> &raquo; <a class="el" href="group___r_e_n_e_s_a_s___a_n_a_l_o_g___m_o_d_u_l_e_s.html">Analog</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gade895e0810cecb3be6a9e5217f5c78ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gade895e0810cecb3be6a9e5217f5c78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994514574730e0701dc1a6ad41889f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, void const *const p_channel_cfg)</td></tr>
<tr class="separator:ga994514574730e0701dc1a6ad41889f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">R_ADC_InfoGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *p_adc_info)</td></tr>
<tr class="separator:ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a7fb2265b5a03c7586253ff28b3faf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga4a7fb2265b5a03c7586253ff28b3faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d4b4406ff0aa0c7ae8f068432a72f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga12d4b4406ff0aa0c7ae8f068432a72f5">R_ADC_ScanGroupStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a> group_mask)</td></tr>
<tr class="separator:ga12d4b4406ff0aa0c7ae8f068432a72f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5242c153c6320a564ed9ffd324f144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga9b5242c153c6320a564ed9ffd324f144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga676b1c7f1ccceda288cbb2ad79a14ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *p_status)</td></tr>
<tr class="separator:ga676b1c7f1ccceda288cbb2ad79a14ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bfc8395b53a96ee89f266fc940e2da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint16_t *const p_data)</td></tr>
<tr class="separator:gad6bfc8395b53a96ee89f266fc940e2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905e1cd6ff8ca4aaf91ee63529dc0d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga905e1cd6ff8ca4aaf91ee63529dc0d0d">R_ADC_Read32</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint32_t *const p_data)</td></tr>
<tr class="separator:ga905e1cd6ff8ca4aaf91ee63529dc0d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0701bf45818dee071cb12e979017bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c.html#structadc__sample__state__t">adc_sample_state_t</a> *p_sample)</td></tr>
<tr class="separator:gaf0701bf45818dee071cb12e979017bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499187b3067534e42a57239ead111797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga499187b3067534e42a57239ead111797">R_ADC_Close</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga499187b3067534e42a57239ead111797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3bc65f19ba61612e0b7517dfd41ab61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf3bc65f19ba61612e0b7517dfd41ab61">R_ADC_OffsetSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, int32_t offset)</td></tr>
<tr class="separator:gaf3bc65f19ba61612e0b7517dfd41ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac73578543d084faf58d17474dbaad23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gac73578543d084faf58d17474dbaad23a">R_ADC_Calibrate</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void const *p_extend)</td></tr>
<tr class="separator:gac73578543d084faf58d17474dbaad23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b7b4813962829f9e25731cd88f4c708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga0b7b4813962829f9e25731cd88f4c708">R_ADC_CallbackSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void(*p_callback)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga0b7b4813962829f9e25731cd88f4c708"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the and ADC12 peripherals on RZ microprocessor. This module implements the <a class="el" href="group___a_d_c___a_p_i.html">ADC Interface</a>. </p>
<h1><a class="anchor" id="r-adc-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-adc-features"></a>
Features</h2>
<p>The ADC module supports the following features:</p>
<ul>
<li>12 bit maximum resolution depending on the MCU</li>
<li>Configure scans to include:<ul>
<li>Multiple analog channels</li>
</ul>
</li>
<li>Configurable scan start trigger:<ul>
<li>Software scan triggers<a class="anchor" id="um_adc_starting_a_conversion"></a></li>
<li>Hardware scan triggers (timer expiration, for example)</li>
<li>External scan triggers from the ADTRGn port pins</li>
</ul>
</li>
<li>Configurable scan mode:<ul>
<li>Single scan mode, where each trigger starts a single scan</li>
<li>Continuous scan mode, where all channels are scanned continuously</li>
<li>Group scan mode, where channels are grouped into group A and group B and group C. The groups can be assigned different start triggers, and group A can be given priority over group B. When group A has priority over group B, a group A trigger suspends an ongoing group B scan.</li>
</ul>
</li>
<li>Supports adding and averaging converted samples</li>
<li>Optional callback when scan completes<a class="anchor" id="um_adc_interrupt_callback_data"></a><a class="anchor" id="um_adc_support_for_group_mode_scan_completion_interrupts"></a></li>
<li>Sample and hold support</li>
<li>Double-trigger support</li>
<li>Hardware comparator with interrupt and event output</li>
</ul>
<h1><a class="anchor" id="r-adc-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_adc_configure_conversion_data_resolution"></a><a class="anchor" id="um_adc_configure_conversion_data_alignment"></a><a class="anchor" id="um_adc_automatically_clearing_conversion_results"></a><a class="anchor" id="um_adc_hardware_support_for_automatically_adding_converted_data"></a><a class="anchor" id="um_adc_hardware_support_for_automatically_averaging_sampled_data"></a><a class="anchor" id="um_adc_configure_single_scan_mode"></a><a class="anchor" id="um_adc_configure_software_trigger"></a><a class="anchor" id="um_adc_configure_the_hardware_trigger"></a><a class="anchor" id="um_adc_configure_continuous_mode"></a><a class="anchor" id="um_adc_configure_channels_for_group_mode"></a><a class="anchor" id="um_adc_configure_group_scan_mode"></a><a class="anchor" id="um_adc_configure_window_compare"></a><a class="anchor" id="um_adc_configuring_sample_and_hold"></a><a class="anchor" id="um_adc_configuring_double_trigger"></a><a class="anchor" id="um_adc_reading_conversion_data"></a> <h2>Build Time Configurations for r_adc</h2>
The following build time configurations are defined in fsp_cfg/r_adc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Multiplex Interrupt</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable multiplex interrupt system-wide. </td></tr>
</table>
 <h2>Configurations for Analog &gt; ADC (r_adc)</h2>
This module can be added to the Stacks tab via New Stack &gt; Analog &gt; ADC (r_adc).<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Name</td><td>Name must be a valid C symbol</td><td>g_adc0 </td><td>Module name </td></tr>
<tr>
<td>General &gt; Unit</td><td>Unit must be a non-negative integer</td><td>0 </td><td>Specifies the ADC Unit to be used. </td></tr>
<tr>
<td>General &gt; Clear after read</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Off</li>
<li>
On</li>
</ul>
</td><td>On </td><td>Specifies if the result register will be automatically cleared after the conversion result is read. </td></tr>
<tr>
<td>General &gt; Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Single Scan</li>
<li>
Continuous Scan</li>
<li>
Group Scan</li>
</ul>
</td><td>Single Scan </td><td>Specifies the mode that this ADC unit is used in. </td></tr>
<tr>
<td>General &gt; Double-trigger</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
<li>
Enabled (extended mode)</li>
</ul>
</td><td>Disabled </td><td>When enabled, the scan-end interrupt for Group A is only thrown on every second scan. Extended double-trigger mode (single-scan only) triggers on both ELC events, allowing (for example) a scan on two different timer compare match values.<br />
<br />
In group mode Group B is unaffected.<br />
<br />
 </td></tr>
<tr>
<td>Input &gt; Sample and Hold &gt; Sample and Hold Channels (Available only on selected MCUs)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Channel 0</li>
<li>
Channel 1</li>
<li>
Channel 2</li>
</ul>
</td><td></td><td>Specifies if this channel is included in the Sample and Hold Mask. </td></tr>
<tr>
<td>Input &gt; Sample and Hold &gt; Sample Hold States (Applies only to channels 0, 1, 2)</td><td>Must be a valid non-negative integer with configurable value 4 to 255</td><td>24 </td><td>Specifies the updated sample-and-hold count for the channel dedicated sample-and-hold circuit </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window A &gt; Enable</td><td>MCU Specific Options</td><td></td><td>Enable or disable comparison with Window A. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window A &gt; Channels to compare (channel availability varies by MCU and unit)</td><td>Refer to the RZT Configuration tool for available options.</td><td></td><td>Select channels to be compared to Window A. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window A &gt; Channel comparison mode (channel availability varies by MCU and unit)</td><td>Refer to the RZT Configuration tool for available options.</td><td></td><td>Checking a box sets the comparison mode for that channel to Greater Than or Inside Window depending on whether Window Mode is disabled or enabled (respectively). If left unchecked the comparison mode will likewise be Less Than or Outside Window (respectively). </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window A &gt; Lower Reference</td><td>Must be a positive 16-bit integer.</td><td>0 </td><td>Set the lower comparison value. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window A &gt; Upper Reference</td><td>Must be a positive 16-bit integer.</td><td>0 </td><td>Set the upper comparison value. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window B &gt; Enable</td><td>MCU Specific Options</td><td></td><td>Enable or disable comparison with Window B. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window B &gt; Channel to compare (channel availability varies by MCU and unit)</td><td>MCU Specific Options</td><td></td><td>Select a channel to be compared to Window B. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window B &gt; Comparison mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Less Than or Outside Window</li>
<li>
Greater Than or Inside Window</li>
</ul>
</td><td>module.driver.adc.compare.window_b.mode </td><td>Select the comparison mode for Window B. For each option, the first condition applies when Window Mode is disabled and the second option applies when Window Mode is enabled. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window B &gt; Lower Reference</td><td>Must be a positive 16-bit integer.</td><td>0 </td><td>Set the lower comparison value. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window B &gt; Upper Reference</td><td>Must be a positive 16-bit integer.</td><td>0 </td><td>Set the upper comparison value. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Window Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>When disabled, ADC values will be compared only with the lower reference on each comparator. When enabled, both the lower and upper reference values will be used to create a comparison window. </td></tr>
<tr>
<td>Input &gt; Window Compare &gt; Event Output</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
OR</li>
<li>
XOR</li>
<li>
AND</li>
</ul>
</td><td>OR </td><td>Select how comparison results should be composited for event output. </td></tr>
<tr>
<td>Input &gt; Start Trigger &gt; Group A</td><td>Refer to the RZT Configuration tool for available options.</td><td>Disabled </td><td>A/D Conversion Start Trigger Select for Group A. </td></tr>
<tr>
<td>Input &gt; Start Trigger &gt; Group B</td><td>Refer to the RZT Configuration tool for available options.</td><td>Disabled </td><td>A/D Conversion Start Trigger Select for Group B. </td></tr>
<tr>
<td>Input &gt; Start Trigger &gt; Group C Enabled</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Disabled </td><td>Set to true to enable Group C, false to disable Group C. </td></tr>
<tr>
<td>Input &gt; Start Trigger &gt; Group C</td><td>Refer to the RZT Configuration tool for available options.</td><td>Disabled </td><td>A/D Conversion Start Trigger Select for Group C. </td></tr>
<tr>
<td>Input &gt; Channel Scan Mask (channel availability varies by MCU)</td><td>Refer to the RZT Configuration tool for available options.</td><td></td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input &gt; Group B Scan Mask (channel availability varies by MCU)</td><td>Refer to the RZT Configuration tool for available options.</td><td></td><td>In group mode, this field specifies which channels belong to group B. </td></tr>
<tr>
<td>Input &gt; Add/Average Count</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Add two samples</li>
<li>
Add three samples</li>
<li>
Add four samples</li>
<li>
Add sixteen samples</li>
<li>
Average two samples</li>
<li>
Average four samples</li>
</ul>
</td><td>Disabled </td><td>Specifies if addition or averaging needs to be done for any of the channels in this unit. </td></tr>
<tr>
<td>Input &gt; Addition/Averaging Mask (channel availability varies by MCU and unit)</td><td>Refer to the RZT Configuration tool for available options.</td><td></td><td>Select channels to include in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input &gt; Group C Scan Mask (channel availability varies by MCU)</td><td>Refer to the RZT Configuration tool for available options.</td><td></td><td>In group mode, this field specifies which channels belong to group C. </td></tr>
<tr>
<td>Interrupts &gt; Normal/Group A Trigger</td><td>MCU Specific Options</td><td></td><td>Specifies the trigger type to be used for this unit. Triggers that specify ADC Unit must be selected for correct ADC unit to operate correctly. </td></tr>
<tr>
<td>Interrupts &gt; Group B Trigger</td><td>MCU Specific Options</td><td></td><td>Specifies the trigger for Group B scanning in group scanning mode. This event is also used to trigger Group A in extended double-trigger mode. Triggers that specify ADC Unit must be selected for correct ADC unit to operate correctly. </td></tr>
<tr>
<td>Interrupts &gt; Group Priority (Valid only in Group Scan Mode)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Group A cannot interrupt Group B</li>
<li>
Group A can interrupt Group B; Group B scan restarts at next trigger</li>
<li>
Group A can interrupt Group B; Group B scan restarts immediately</li>
<li>
Group A can interrupt Group B; Group B scan restarts immediately and scans continuously</li>
</ul>
</td><td>Group A cannot interrupt Group B </td><td>Determines whether an ongoing group B scan can be interrupted by a group A trigger, whether it should abort on a group A trigger, or if it should pause to allow group A scan and restart immediately after group A scan is complete. </td></tr>
<tr>
<td>Interrupts &gt; Callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR) each time the ADC scan completes. </td></tr>
<tr>
<td>Interrupts &gt; Scan End Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select scan end interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Scan End Group B Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select group B scan end interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Scan End Group C Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select group C scan end interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Window Compare A Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select Window Compare A interrupt priority. </td></tr>
<tr>
<td>Interrupts &gt; Window Compare B Interrupt Priority</td><td>MCU Specific Options</td><td></td><td>Select Window Compare B interrupt priority. </td></tr>
<tr>
<td>ELC &gt; ADC0 event A &gt; Trigger Source</td><td>MCU Specific Options</td><td></td><td>ELC_SSEL settings. </td></tr>
<tr>
<td>ELC &gt; ADC0 event B &gt; Trigger Source</td><td>MCU Specific Options</td><td></td><td>ELC_SSEL settings. </td></tr>
<tr>
<td>ELC &gt; ADC1 event A &gt; Trigger Source</td><td>MCU Specific Options</td><td></td><td>ELC_SSEL settings. </td></tr>
<tr>
<td>ELC &gt; ADC1 event B &gt; Trigger Source</td><td>MCU Specific Options</td><td></td><td>ELC_SSEL settings. </td></tr>
<tr>
<td>ELC &gt; ADC2 event A &gt; Trigger Source</td><td>MCU Specific Options</td><td></td><td>ELC_SSEL settings. </td></tr>
<tr>
<td>ELC &gt; ADC2 event B &gt; Trigger Source</td><td>MCU Specific Options</td><td></td><td>ELC_SSEL settings. </td></tr>
<tr>
<td>ELC &gt; Output Event Signal</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Single</li>
<li>
Contiuous</li>
<li>
Group A</li>
<li>
Group B</li>
<li>
Group A or B or C</li>
<li>
Group C</li>
</ul>
</td><td>Single </td><td>A/D Event Link Control. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-adc-clock-configuration"></a>
Clock Configuration</h2>
<p>Peripheral module clock (Unit 0: PCLKH, Unit 1: PCLKL) and A/D conversion clock PCLKADC can be set with the following division ratios: PCLKH to PCLKADC frequency ratios = 8:1</p>
<p>The ADC clock must be at 25 MHz or 18.75 MHz (ICLK/8) when the ADC is used.</p>
<p>For T2H device</p>
<p>Peripheral module clock (Unit 0: PCLKH, Unit 1: PCLKH, Unit 2: PCLKM) and A/D conversion clock PCLKADC can be set with the following division ratios: PCLKH to PCLKADC frequency ratios = 4:1</p>
<p>The ADC clock must be at 62.5 MHz (PCLKH/4) when the ADC is used.</p>
<h2><a class="anchor" id="r-adc-pin-configuration"></a>
Pin Configuration</h2>
<p>The ANxxx pins are analog input channels that can be used with the ADC.</p>
<p><a class="anchor" id="um_adc_configure_the_external_trigger"></a>ADTRG0 and ADTRG1 can be used to start scans with an external trigger for unit 0 and 1 respectively. When external triggers are used, ADC scans begin on the falling edge of the ADTRG pin.</p>
<h1><a class="anchor" id="r-adc-usage_notes"></a>
Usage Notes</h1>
<h2>Sample Hold</h2>
<p>Enabling the sample and hold functionality reduces the maximum scan frequency because the sample and hold time is added to each scan. Refer to the hardware manual for details on the sample and hold time.</p>
<h2><a class="anchor" id="adc-hal-module-operational-overview"></a>
ADC Operational Modes</h2>
<p>The driver supports three operation modes: single-scan, continuous-scan, and group-scan modes. In each mode, analog channels are converted in ascending order of channel number, followed by scans of the voltage sensor if they are included in the mask of channels to scan.</p>
<h3>Single-scan Mode</h3>
<p>In single scan mode, one or more specified channels are scanned once per trigger.</p>
<h3>Continuous-scan Mode</h3>
<p>In continuous scan mode, a single trigger is required to start the scan. Scans continue until <a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop()</a> is called.</p>
<h3>Group-scan Mode</h3>
<p>Group-scan mode allows the application to allocate channels to one of two groups (A and B and C). Conversion begins when the specified ELC start trigger for that group is received.</p>
<p>The priority of group priority operations is group A &gt; group B &gt; group C. In group priority operation, if the scan start of group B is accepted during the scan of group C, the scan of group C is interrupted and the scan of group B is started. If the scan start of group A is accepted during the scan of group C, the scan of group A is started. The scan of Group C is interrupted and the scan of Group A is started. Similarly, if the scan start of Group A is accepted during the scan of Group B, the scan of Group B is interrupted and the scan of Group A is started. The interrupted group scan is able to resume after the priority group scan is complete also.:</p>
<ul>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_restart"></a>To restart the interrupted group B scan after the group A scan completes.</li>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_wait"></a>To wait for another group B trigger and forget the interrupted scan.</li>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_continuous"></a>To continuously scan group B and suspend scanning group B only when a group A trigger is received. <dl class="section note"><dt>Note</dt><dd>If this option is selected, group B scanning begins immediately after <a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg()</a>. Group A scan triggers must be enabled by <a class="el" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart()</a> and can be disabled by <a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop()</a>. Group B scans can only be disabled by reconfiguring the group A priority to a different mode.</dd></dl>
<br />
</li>
</ul>
<h3>Double-triggering</h3>
<p>When double-triggering is enabled a single channel is selected to be scanned twice before an interrupt is thrown. The first scan result when using double-triggering is always saved to the selected channel's data register. The second result is saved to the data duplexing register (<a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814a2602b0a06ce1ce485d0812de6f6f4091">ADC_CHANNEL_DUPLEX</a>).</p>
<p>Double-triggering uses Group A; only one channel can be selected when enabled. No other scanning is possible on Group A while double-trigger mode is selected.</p>
<p>When extended double-triggering is enabled, both ADC input (ELC) events are routed to Group A. The interrupt is still thrown after every two scans regardless of the triggering event(s). While the first and second scan are saved to the selected ADC data register and the ADC duplexing register as before, scans associated with event A and B are additionally copied into duplexing register A and B, respectively (<a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814aadc3763b403f4b9ab667602137a9de57">ADC_CHANNEL_DUPLEX_A</a> and <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814aa66d57680818caebf7be4d68f8c505be">ADC_CHANNEL_DUPLEX_B</a>).</p>
<h2>Window Compare Function</h2>
<p>The ADC contains comparators that allow scan data to be compared to user-provided reference values. When a value meets the configured condition an interrupt and/or an ELC event can be produced.</p>
<p>Each unit has two configurable comparison units, Window A and Window B. Window A allows for configuring multiple simultaneous channels to compare while Window B only allows one channel at a time.</p>
<p>The window compare function can be configured both through the FSP Configuration tool and at runtime by providing a pointer to an <a class="el" href="group___a_d_c.html#structadc__window__cfg__t">adc_window_cfg_t</a> struct to <a class="el" href="group___a_d_c.html#a01eb9675c5cef9993c5a9e85dbadb4b0">adc_channel_cfg_t::p_window_cfg</a> when calling <a class="el" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>. The available comparison modes are shown below:</p>
<table class="doxtable">
<tr>
<th>Window setting </th><th>Channel mode 0 </th><th>Channel mode 1  </th></tr>
<tr>
<td>Disabled </td><td>Scan &lt; Low Ref </td><td>Scan &gt; Low Ref </td></tr>
<tr>
<td>Enabled </td><td>(Scan &lt; Low Ref) OR (Scan &gt; High Ref) </td><td>Low Ref &lt; Scan &lt; High Ref </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The window setting applies to all channels configured on a unit.</dd></dl>
<h2>Event Output Function</h2>
<p>To use the event output of compare function, Set the mode of operation to Single Scan Mode. The compare function can be configured by enabling both Window A and Window B. In Window A, any channel from unit support can be selected. In Window B, one channel of unit support can be selected.</p>
<dl class="section note"><dt>Note</dt><dd>: When using event output using only window A of compare function, please follow the step below.<ul>
<li>Enable both Window A and Window B.</li>
<li>Select "OR condition" for compound condition setting for Window A and Window B.</li>
<li>Set channel in Window B to "Unselected".</li>
<li>Set the comparison condition of window B to 0 &lt; conversion result &lt; 0, which is "always inconsistent".</li>
</ul>
</dd></dl>
<h2>Sample-State Count Setting</h2>
<p>The application program can modify the setting of the sample-state count for analog channels by calling the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function. The application program only needs to modify the sample-state count settings from their default values to increase the sampling time. This can be either because the impedance of the input signal is too high to secure sufficient sampling time under the default setting or if the ADCLK is too slow. To modify the sample-state count for a given channel, set the channel number and the number of states when calling the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function. Valid sample state counts are 8-255.</p>
<p>If the sample state count needs to be changed for multiple channels, the application program must call the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function repeatedly, with appropriately modified arguments for each channel.</p>
<p>If the ADCLK frequency changes, the sample states may need to be updated.</p>
<h3>Selecting Reference Voltage</h3>
<p>The ADC12 can select VREFH0 or VREFH1 as the high-potential reference voltage on selected MCU's.</p>
<h2>Usage Notes for ADC12</h2>
<h3>Range of ADC12 Results</h3>
<p>The range of the ADC12 is from 0 (lowest) to 0xFFF (highest) when used in single-ended mode. This driver only supports single ended mode.</p>
<h2>Limitations</h2>
<p>Developers should be aware of the following limitations when using the ADC:</p>
<ul>
<li>When using the Window Compare function:<ul>
<li>Only Single Scan mode may be configured when match or mismatch ELC events are used.</li>
<li>Both windows cannot reference the same channel.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="r-adc-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the ADC in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">/* A channel configuration is generated by the FSP Configuration editor based on the options selected.  If additional</span></div><div class="line"><span class="comment"> * configurations are desired additional adc_channel_cfg_t elements can be defined and passed to R_ADC_ScanCfg. */</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="group___a_d_c.html#structadc__channel__cfg__t">adc_channel_cfg_t</a> g_adc0_channel_cfg =</div><div class="line">{</div><div class="line">    .<a class="code" href="group___a_d_c.html#a706f698d4cd3a57b1e04503c143003dc">scan_mask</a>          = <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaac501dac2fb65d1f922a6177d149b56bd">ADC_MASK_CHANNEL_0</a> | <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaaee05b1448c74da666ef0ed4bf1bbfb8e">ADC_MASK_CHANNEL_1</a>,</div><div class="line">    .scan_mask_group_b  = 0,</div><div class="line">    .priority_group_a   = (<a class="code" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a>) 0,</div><div class="line">    .add_mask           = 0,</div><div class="line">    .sample_hold_mask   = 0,</div><div class="line">    .sample_hold_states = 0,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable channels. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        (void) <a class="code" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t channel1_conversion_result;</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Double-Trigger Example</h2>
<p>This example demonstrates reading data from a double-trigger scan. A flag is used to wait for a callback event. Two scans must occur before the callback is called. These results are read via <a class="el" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a> using the selected channel enum value as well as <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814a2602b0a06ce1ce485d0812de6f6f4091">ADC_CHANNEL_DUPLEX</a>.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> scan_complete_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_callback (<a class="code" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line"></div><div class="line">    scan_complete_flag = <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_double_trigger_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable double-trigger channel. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable scan triggering from ELC events. */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. Two scans must be triggered before a callback occurs. */</span></div><div class="line">    scan_complete_flag = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">while</span> (!scan_complete_flag)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Wait for callback to set flag. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data from both scans. */</span></div><div class="line">    uint16_t channel1_conversion_result_0;</div><div class="line">    uint16_t channel1_conversion_result_1;</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result_0);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814a2602b0a06ce1ce485d0812de6f6f4091">ADC_CHANNEL_DUPLEX</a>, &amp;channel1_conversion_result_1);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Window Compare Example</h2>
<p>This example shows how to configure the window compare function at runtime as well as how to handle events and obtain comparison results through a callback.</p>
<div class="fragment"><div class="line"></div><div class="line"><a class="code" href="group___a_d_c.html#structadc__window__cfg__t">adc_window_cfg_t</a> g_adc0_window_cfg =</div><div class="line">{</div><div class="line">    <span class="comment">/* Enable Window A and Window B; enable Window mode */</span></div><div class="line">    .<a class="code" href="group___a_d_c.html#a6aad2860ef31d707f9184f8849ae3cbc">compare_cfg</a>        =</div><div class="line">        (<a class="code" href="group___a_d_c.html#ga5d55db8f35fe6d81d9ed2189e6915259">adc_compare_cfg_t</a>) (ADC_COMPARE_CFG_A_ENABLE | ADC_COMPARE_CFG_B_ENABLE | ADC_COMPARE_CFG_WINDOW_ENABLE),</div><div class="line"></div><div class="line">    <span class="comment">/* Compare scan values from Channels 0 and 1 */</span></div><div class="line">    .compare_mask       = <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaac501dac2fb65d1f922a6177d149b56bd">ADC_MASK_CHANNEL_0</a> | <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaaee05b1448c74da666ef0ed4bf1bbfb8e">ADC_MASK_CHANNEL_1</a>,</div><div class="line"></div><div class="line">    <span class="comment">/* Set Channel 1 condition to be inside the window instead of outside */</span></div><div class="line">    .compare_mode_mask  = <a class="code" href="group___a_d_c.html#ggada437c4b88ed24eb8b9c94c0b45d76eaaee05b1448c74da666ef0ed4bf1bbfb8e">ADC_MASK_CHANNEL_1</a>,</div><div class="line"></div><div class="line">    <span class="comment">/* Set reference voltage levels for Window A */</span></div><div class="line">    .compare_ref_low  = ADC_SCAN_MAX / 3,</div><div class="line">    .compare_ref_high = ADC_SCAN_MAX * 2 / 3,</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Window B to compare Channel 2 (inside window) */</span></div><div class="line">    .compare_b_channel = <a class="code" href="group___a_d_c.html#ggaf6b1491f26c341e3a6507881969bdad3a61e48f57bac5198cffcf68debbc15e40">ADC_WINDOW_B_CHANNEL_2</a>,</div><div class="line">    .compare_b_mode    = ADC_WINDOW_B_MODE_GREATER_THAN_OR_INSIDE,</div><div class="line"></div><div class="line">    <span class="comment">/* Set reference voltage levels for Window B */</span></div><div class="line">    .compare_b_ref_low  = ADC_SCAN_MAX / 4,</div><div class="line">    .compare_b_ref_high = ADC_SCAN_MAX * 3 / 4,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc0_callback (<a class="code" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___a_d_c___a_p_i.html#ggae2177d6e5bf43e3749cc60f835456847a0194955f4f59f8d6952adc058539632b">ADC_EVENT_WINDOW_COMPARE_A</a> == p_args-&gt;<a class="code" href="group___a_d_c___a_p_i.html#a7b1ea18a97eee3565ef6cfb084222453">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get channel that met the comparison criteria */</span></div><div class="line">        <a class="code" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> channel = p_args-&gt;<a class="code" href="group___a_d_c___a_p_i.html#a1e9351a3cb3ab91b4953b29cac73f5cc">channel</a>;</div><div class="line"></div><div class="line">        <span class="comment">/* Process event here */</span></div><div class="line">        <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(channel);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group___a_d_c___a_p_i.html#ggae2177d6e5bf43e3749cc60f835456847ab32572630797968579adeed03f19bcd3">ADC_EVENT_WINDOW_COMPARE_B</a> == p_args-&gt;<a class="code" href="group___a_d_c___a_p_i.html#a7b1ea18a97eee3565ef6cfb084222453">event</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process Window B events here */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_window_compare_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Open the ADC module */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Set the window compare configuration in the channel config */</span></div><div class="line">    g_adc0_channel_runtime_cfg.p_window_cfg = &amp;g_adc0_window_cfg;</div><div class="line"></div><div class="line">    <span class="comment">/* The window compare function is configured as part of the scan configuration */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga994514574730e0701dc1a6ad41889f88">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_runtime_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="comment">/* Main program loop - scan the ADC every second */</span></div><div class="line">    <span class="keywordflow">while</span> (1)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Start a scan */</span></div><div class="line">        err = <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">        <span class="comment">/* Delay; any compare events will be handled by the callback */</span></div><div class="line">        <a class="code" href="group___b_s_p___m_c_u.html#gaf3219448adfd1531cf69f68697ab184b">R_BSP_SoftwareDelay</a>(1, <a class="code" href="group___b_s_p___m_c_u.html#ggafd98e2a6f080d6a52a3ef72e3d731b2bacc709da08ef4acc99bf6e2e84946be5d">BSP_DELAY_UNITS_SECONDS</a>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structadc__sample__state__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__sample__state__t">adc_sample_state_t</a></td></tr>
<tr class="separator:structadc__sample__state__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__window__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__window__cfg__t">adc_window_cfg_t</a></td></tr>
<tr class="separator:structadc__window__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__extended__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__extended__cfg__t">adc_extended_cfg_t</a></td></tr>
<tr class="separator:structadc__extended__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__channel__cfg__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__channel__cfg__t">adc_channel_cfg_t</a></td></tr>
<tr class="separator:structadc__channel__cfg__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structadc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__instance__ctrl__t">adc_instance_ctrl_t</a></td></tr>
<tr class="separator:structadc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada437c4b88ed24eb8b9c94c0b45d76ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gada437c4b88ed24eb8b9c94c0b45d76ea">adc_mask_t</a> </td></tr>
<tr class="separator:gada437c4b88ed24eb8b9c94c0b45d76ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ce774d7384e84ac724f5a1c6ca0d21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gae9ce774d7384e84ac724f5a1c6ca0d21">adc_add_t</a> </td></tr>
<tr class="separator:gae9ce774d7384e84ac724f5a1c6ca0d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ddc074052e3b84fcc2defed431fe022"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga9ddc074052e3b84fcc2defed431fe022">adc_clear_t</a> </td></tr>
<tr class="separator:ga9ddc074052e3b84fcc2defed431fe022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2817e17c728f9a2b041b54fd92244c3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga2817e17c728f9a2b041b54fd92244c3b">adc_sample_state_reg_t</a> </td></tr>
<tr class="separator:ga2817e17c728f9a2b041b54fd92244c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d55db8f35fe6d81d9ed2189e6915259"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga5d55db8f35fe6d81d9ed2189e6915259">adc_compare_cfg_t</a> </td></tr>
<tr class="separator:ga5d55db8f35fe6d81d9ed2189e6915259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b1491f26c341e3a6507881969bdad3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf6b1491f26c341e3a6507881969bdad3">adc_window_b_channel_t</a> </td></tr>
<tr class="separator:gaf6b1491f26c341e3a6507881969bdad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d0c470ca46c2801d243c06f03916e67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga0d0c470ca46c2801d243c06f03916e67">adc_window_b_mode_t</a> </td></tr>
<tr class="separator:ga0d0c470ca46c2801d243c06f03916e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79014196d08d86b161b77892bf26b100"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a> </td></tr>
<tr class="separator:ga79014196d08d86b161b77892bf26b100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8dbc21689111fadfff9dd51d612eb8e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gac8dbc21689111fadfff9dd51d612eb8e">adc_active_trigger_t</a> </td></tr>
<tr class="separator:gac8dbc21689111fadfff9dd51d612eb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802c536966b5905a58039e347c5dbbc5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga802c536966b5905a58039e347c5dbbc5">adc_double_trigger_t</a> </td></tr>
<tr class="separator:ga802c536966b5905a58039e347c5dbbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42fdf34706dd9fc70b44d89d5a7fec8f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga42fdf34706dd9fc70b44d89d5a7fec8f">adc_elc_t</a> </td></tr>
<tr class="separator:ga42fdf34706dd9fc70b44d89d5a7fec8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structadc__sample__state__t" id="structadc__sample__state__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__sample__state__t">&#9670;&nbsp;</a></span>adc_sample_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_sample_state_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC sample state configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a369eb3d0d52d0b68bcd36f3b0dbdeaef"></a><a class="el" href="group___a_d_c.html#ga2817e17c728f9a2b041b54fd92244c3b">adc_sample_state_reg_t</a></td>
<td class="fieldname">
reg_id</td>
<td class="fielddoc">
Sample state register ID. </td></tr>
<tr><td class="fieldtype">
<a id="aedbb76489ecc68110ccf3ede6f02fce9"></a>uint8_t</td>
<td class="fieldname">
num_states</td>
<td class="fielddoc">
Number of sampling states for conversion. Ch16-20/21 use the same value. </td></tr>
</table>

</div>
</div>
<a name="structadc__window__cfg__t" id="structadc__window__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__window__cfg__t">&#9670;&nbsp;</a></span>adc_window_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_window_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC Window Compare configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="acfa5530e9234fa2fec1e228553d472fd"></a>uint32_t</td>
<td class="fieldname">
compare_mask</td>
<td class="fielddoc">
Channel mask to compare with Window A. </td></tr>
<tr><td class="fieldtype">
<a id="a2d52bc98af8b83031ba2367b701a579d"></a>uint32_t</td>
<td class="fieldname">
compare_mode_mask</td>
<td class="fielddoc">
Per-channel condition mask for Window A. </td></tr>
<tr><td class="fieldtype">
<a id="a6aad2860ef31d707f9184f8849ae3cbc"></a><a class="el" href="group___a_d_c.html#ga5d55db8f35fe6d81d9ed2189e6915259">adc_compare_cfg_t</a></td>
<td class="fieldname">
compare_cfg</td>
<td class="fielddoc">
Window Compare configuration. </td></tr>
<tr><td class="fieldtype">
<a id="a1f3cd6ebb8bb738590ddcddbddff5099"></a>uint16_t</td>
<td class="fieldname">
compare_ref_low</td>
<td class="fielddoc">
Window A lower reference value. </td></tr>
<tr><td class="fieldtype">
<a id="a38044325d92f31dfc0643bb04b67e67c"></a>uint16_t</td>
<td class="fieldname">
compare_ref_high</td>
<td class="fielddoc">
Window A upper reference value. </td></tr>
<tr><td class="fieldtype">
<a id="a0b47f297e60558660503e363217088f6"></a>uint16_t</td>
<td class="fieldname">
compare_b_ref_low</td>
<td class="fielddoc">
Window B lower reference value. </td></tr>
<tr><td class="fieldtype">
<a id="af1882c3161187dd3b952b87b2f818c7b"></a>uint16_t</td>
<td class="fieldname">
compare_b_ref_high</td>
<td class="fielddoc">
Window B upper reference value. </td></tr>
<tr><td class="fieldtype">
<a id="a4cfe8de660042d6b772da2a7d7fee359"></a><a class="el" href="group___a_d_c.html#gaf6b1491f26c341e3a6507881969bdad3">adc_window_b_channel_t</a></td>
<td class="fieldname">
compare_b_channel</td>
<td class="fielddoc">
Window B channel. </td></tr>
<tr><td class="fieldtype">
<a id="a31ee514e76f00d45fcd35fe1f852e10e"></a><a class="el" href="group___a_d_c.html#ga0d0c470ca46c2801d243c06f03916e67">adc_window_b_mode_t</a></td>
<td class="fieldname">
compare_b_mode</td>
<td class="fielddoc">
Window B condition setting. </td></tr>
</table>

</div>
</div>
<a name="structadc__extended__cfg__t" id="structadc__extended__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__extended__cfg__t">&#9670;&nbsp;</a></span>adc_extended_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_extended_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Extended configuration structure for ADC. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a44fb36e649b135f9803548a488f6684d"></a><a class="el" href="group___a_d_c.html#gae9ce774d7384e84ac724f5a1c6ca0d21">adc_add_t</a></td>
<td class="fieldname">
add_average_count</td>
<td class="fielddoc">
Add or average samples. </td></tr>
<tr><td class="fieldtype">
<a id="a3ea48b1c97df4f5169bdfe5af3911396"></a><a class="el" href="group___a_d_c.html#ga9ddc074052e3b84fcc2defed431fe022">adc_clear_t</a></td>
<td class="fieldname">
clearing</td>
<td class="fielddoc">
Clear after read. </td></tr>
<tr><td class="fieldtype">
<a id="ae8c077fe7cbf5c28f605ed84f68dca9b"></a><a class="el" href="group___a_d_c___a_p_i.html#ga1ac380ffe2ebef256338616747d330e3">adc_trigger_t</a></td>
<td class="fieldname">
trigger_group_b</td>
<td class="fielddoc">
Group B trigger source; valid only for group mode. </td></tr>
<tr><td class="fieldtype">
<a id="ad2be3785d3a8153d8ec71123583450b9"></a><a class="el" href="group___a_d_c.html#ga802c536966b5905a58039e347c5dbbc5">adc_double_trigger_t</a></td>
<td class="fieldname">
double_trigger_mode</td>
<td class="fielddoc">
Double-trigger mode setting. </td></tr>
<tr><td class="fieldtype">
<a id="ada4406bec174acd8666f427e205efa25"></a><a class="el" href="group___a_d_c.html#gac8dbc21689111fadfff9dd51d612eb8e">adc_active_trigger_t</a></td>
<td class="fieldname">
adc_start_trigger_a</td>
<td class="fielddoc">
A/D Conversion Start Trigger Group A. </td></tr>
<tr><td class="fieldtype">
<a id="a7317424a6d0fa545da6ec2605cae9685"></a><a class="el" href="group___a_d_c.html#gac8dbc21689111fadfff9dd51d612eb8e">adc_active_trigger_t</a></td>
<td class="fieldname">
adc_start_trigger_b</td>
<td class="fielddoc">
A/D Conversion Start Trigger Group B. </td></tr>
<tr><td class="fieldtype">
<a id="ae13020f0d8a4dd6617e57ac6cf68a400"></a>bool</td>
<td class="fieldname">
adc_start_trigger_c_enabled</td>
<td class="fielddoc">
Set to true to enable Group C, false to disable Group C. </td></tr>
<tr><td class="fieldtype">
<a id="a303e91667e2515a0127479f7079275c6"></a><a class="el" href="group___a_d_c.html#gac8dbc21689111fadfff9dd51d612eb8e">adc_active_trigger_t</a></td>
<td class="fieldname">
adc_start_trigger_c</td>
<td class="fielddoc">
A/D Conversion Start Trigger Group C. </td></tr>
<tr><td class="fieldtype">
<a id="a447826555274dc161910eec013fb7caf"></a><a class="el" href="group___a_d_c.html#ga42fdf34706dd9fc70b44d89d5a7fec8f">adc_elc_t</a></td>
<td class="fieldname">
adc_elc_ctrl</td>
<td class="fielddoc">
A/D Event Link Control. </td></tr>
<tr><td class="fieldtype">
<a id="a9cdf0d84793db3e109d6795475bd5b22"></a>IRQn_Type</td>
<td class="fieldname">
window_a_irq</td>
<td class="fielddoc">
IRQ number for Window Compare A interrupts. </td></tr>
<tr><td class="fieldtype">
<a id="af4d38f88e8e629e1bec67a46f65e62dc"></a>uint8_t</td>
<td class="fieldname">
window_a_ipl</td>
<td class="fielddoc">
Priority for Window Compare A interrupts. </td></tr>
<tr><td class="fieldtype">
<a id="ab95bd65fa66c0d6eca6514523e1fe910"></a>IRQn_Type</td>
<td class="fieldname">
window_b_irq</td>
<td class="fielddoc">
IRQ number for Window Compare B interrupts. </td></tr>
<tr><td class="fieldtype">
<a id="a9bbaed92b2e497b9f054b9c72f3967e3"></a>uint8_t</td>
<td class="fieldname">
window_b_ipl</td>
<td class="fielddoc">
Priority for Window Compare B interrupts. </td></tr>
</table>

</div>
</div>
<a name="structadc__channel__cfg__t" id="structadc__channel__cfg__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__channel__cfg__t">&#9670;&nbsp;</a></span>adc_channel_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_channel_cfg_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC channel(s) configuration </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a706f698d4cd3a57b1e04503c143003dc"></a>uint32_t</td>
<td class="fieldname">
scan_mask</td>
<td class="fielddoc">
Channels/bits: bit 0 is ch0; bit 15 is ch15. </td></tr>
<tr><td class="fieldtype">
<a id="aa1cf641bc6b225b233baa1c11ee7d4b5"></a>uint32_t</td>
<td class="fieldname">
scan_mask_group_b</td>
<td class="fielddoc">
Valid for group modes. </td></tr>
<tr><td class="fieldtype">
<a id="a3dc144da7a6c88f0e985bbc6e4bca5cc"></a>uint32_t</td>
<td class="fieldname">
scan_mask_group_c</td>
<td class="fielddoc">
Valid for group modes. </td></tr>
<tr><td class="fieldtype">
<a id="a81489e3b2a0f142e6e902065e82dfe81"></a>uint32_t</td>
<td class="fieldname">
add_mask</td>
<td class="fielddoc">
Valid if add enabled in Open(). </td></tr>
<tr><td class="fieldtype">
<a id="a01eb9675c5cef9993c5a9e85dbadb4b0"></a><a class="el" href="group___a_d_c.html#structadc__window__cfg__t">adc_window_cfg_t</a> *</td>
<td class="fieldname">
p_window_cfg</td>
<td class="fielddoc">
Pointer to Window Compare configuration. </td></tr>
<tr><td class="fieldtype">
<a id="aef59542e008313144646bd057d840c8a"></a><a class="el" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a></td>
<td class="fieldname">
priority_group_a</td>
<td class="fielddoc">
Valid for group modes. </td></tr>
<tr><td class="fieldtype">
<a id="a2963c15f5fd0b6c358926e22f67eb740"></a>uint8_t</td>
<td class="fieldname">
sample_hold_mask</td>
<td class="fielddoc">
Channels/bits 0-2. </td></tr>
<tr><td class="fieldtype">
<a id="a91b488601bfb54ef0cf793c2ea44a001"></a>uint8_t</td>
<td class="fieldname">
sample_hold_states</td>
<td class="fielddoc">
Number of states to be used for sample and hold. Affects channels 0-2. </td></tr>
</table>

</div>
</div>
<a name="structadc__instance__ctrl__t" id="structadc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__instance__ctrl__t">&#9670;&nbsp;</a></span>adc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC instance control block. DO NOT INITIALIZE. Initialized in <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gada437c4b88ed24eb8b9c94c0b45d76ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada437c4b88ed24eb8b9c94c0b45d76ea">&#9670;&nbsp;</a></span>adc_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gada437c4b88ed24eb8b9c94c0b45d76ea">adc_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For ADC Scan configuration <a class="el" href="group___a_d_c.html#a706f698d4cd3a57b1e04503c143003dc" title="Channels/bits: bit 0 is ch0; bit 15 is ch15. ">adc_channel_cfg_t::scan_mask</a>, <a class="el" href="group___a_d_c.html#aa1cf641bc6b225b233baa1c11ee7d4b5" title="Valid for group modes. ">adc_channel_cfg_t::scan_mask_group_b</a>, <a class="el" href="group___a_d_c.html#a81489e3b2a0f142e6e902065e82dfe81" title="Valid if add enabled in Open(). ">adc_channel_cfg_t::add_mask</a> and <a class="el" href="group___a_d_c.html#a2963c15f5fd0b6c358926e22f67eb740" title="Channels/bits 0-2. ">adc_channel_cfg_t::sample_hold_mask</a>. Use bitwise OR to combine these masks for desired channels and sensors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa1a520b21e25b15e8771e66ec30e821c0"></a>ADC_MASK_OFF&#160;</td><td class="fielddoc"><p>No channels selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac501dac2fb65d1f922a6177d149b56bd"></a>ADC_MASK_CHANNEL_0&#160;</td><td class="fielddoc"><p>Channel 0 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaee05b1448c74da666ef0ed4bf1bbfb8e"></a>ADC_MASK_CHANNEL_1&#160;</td><td class="fielddoc"><p>Channel 1 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaf6ed6dc12b9f00816248fab86defd438"></a>ADC_MASK_CHANNEL_2&#160;</td><td class="fielddoc"><p>Channel 2 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac6b4aff675dec9cadaae4199ed4ff1ce"></a>ADC_MASK_CHANNEL_3&#160;</td><td class="fielddoc"><p>Channel 3 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa31384e0aedc6d3bb72bb337bc3a26926"></a>ADC_MASK_CHANNEL_4&#160;</td><td class="fielddoc"><p>Channel 4 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa37244da83766b5339012612cb94c24a1"></a>ADC_MASK_CHANNEL_5&#160;</td><td class="fielddoc"><p>Channel 5 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa2d0d20c8b71625964503f427e34c087f"></a>ADC_MASK_CHANNEL_6&#160;</td><td class="fielddoc"><p>Channel 6 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac4230924f979ea41f84bb7b1b5923aa8"></a>ADC_MASK_CHANNEL_7&#160;</td><td class="fielddoc"><p>Channel 7 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaabc48f28b2cd64aa57646414fccfcf20d"></a>ADC_MASK_CHANNEL_8&#160;</td><td class="fielddoc"><p>Channel 8 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa4abb79c0220229121fc0191df18b1489"></a>ADC_MASK_CHANNEL_9&#160;</td><td class="fielddoc"><p>Channel 9 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaabe5718054829cb20152408348c39e6ad"></a>ADC_MASK_CHANNEL_10&#160;</td><td class="fielddoc"><p>Channel 10 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa1aae5dbbbb242e4fb8152e05944964ff"></a>ADC_MASK_CHANNEL_11&#160;</td><td class="fielddoc"><p>Channel 11 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaa7d739e17b3579f4f792f646ae1dca32c"></a>ADC_MASK_CHANNEL_12&#160;</td><td class="fielddoc"><p>Channel 12 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaae00f3e1d56e90441de81d6ca35dd7602"></a>ADC_MASK_CHANNEL_13&#160;</td><td class="fielddoc"><p>Channel 13 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaac544630494da89f6d7a2f1cca190dc1c"></a>ADC_MASK_CHANNEL_14&#160;</td><td class="fielddoc"><p>Channel 14 mask. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggada437c4b88ed24eb8b9c94c0b45d76eaaf087bfd9d507a86f7a5f6211b9f0b8db"></a>ADC_MASK_CHANNEL_15&#160;</td><td class="fielddoc"><p>Channel 15 mask. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae9ce774d7384e84ac724f5a1c6ca0d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ce774d7384e84ac724f5a1c6ca0d21">&#9670;&nbsp;</a></span>adc_add_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gae9ce774d7384e84ac724f5a1c6ca0d21">adc_add_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC data sample addition and averaging options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a090916b0598df17cfc4cbc6da7a24361"></a>ADC_ADD_OFF&#160;</td><td class="fielddoc"><p>Addition turned off for channels/sensors. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21aae57197b45505b18cb188b1a44bb0411"></a>ADC_ADD_TWO&#160;</td><td class="fielddoc"><p>Add two samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21adec8cd78254fbd95b677c5b842b6209e"></a>ADC_ADD_THREE&#160;</td><td class="fielddoc"><p>Add three samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a0c4068dac9f508406946326b31cc45cd"></a>ADC_ADD_FOUR&#160;</td><td class="fielddoc"><p>Add four samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a09798f7c00aef944195aa7039081f171"></a>ADC_ADD_SIXTEEN&#160;</td><td class="fielddoc"><p>Add sixteen samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a6c9935940088b096683ce038643c93c8"></a>ADC_ADD_AVERAGE_TWO&#160;</td><td class="fielddoc"><p>Average two samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a3a7e0243d419140e1ae4204860befc65"></a>ADC_ADD_AVERAGE_THREE&#160;</td><td class="fielddoc"><p>Average three samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21aa5551fce055385439e74076ea349ca38"></a>ADC_ADD_AVERAGE_FOUR&#160;</td><td class="fielddoc"><p>Average four samples. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae9ce774d7384e84ac724f5a1c6ca0d21a9026625853db106940c2418a1d65226e"></a>ADC_ADD_AVERAGE_SIXTEEN&#160;</td><td class="fielddoc"><p>Average sixteen samples. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9ddc074052e3b84fcc2defed431fe022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ddc074052e3b84fcc2defed431fe022">&#9670;&nbsp;</a></span>adc_clear_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga9ddc074052e3b84fcc2defed431fe022">adc_clear_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC clear after read definitions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9ddc074052e3b84fcc2defed431fe022a40a15e57eb830cd349dc65bbb1804983"></a>ADC_CLEAR_AFTER_READ_OFF&#160;</td><td class="fielddoc"><p>Clear after read off. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9ddc074052e3b84fcc2defed431fe022a0ba72fa05c9e7855c869e82c39ce8634"></a>ADC_CLEAR_AFTER_READ_ON&#160;</td><td class="fielddoc"><p>Clear after read on. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2817e17c728f9a2b041b54fd92244c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2817e17c728f9a2b041b54fd92244c3b">&#9670;&nbsp;</a></span>adc_sample_state_reg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga2817e17c728f9a2b041b54fd92244c3b">adc_sample_state_reg_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC sample state registers </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baf811443b06aa8bcdfc814fd3df5bf087"></a>ADC_SAMPLE_STATE_REG_CHANNEL_0&#160;</td><td class="fielddoc"><p>Sample state register channel 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baaf43a19b1c8dbf913581a33910a1f0c6"></a>ADC_SAMPLE_STATE_REG_CHANNEL_1&#160;</td><td class="fielddoc"><p>Sample state register channel 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bad279023f3d8bee747645ab78e2f6be85"></a>ADC_SAMPLE_STATE_REG_CHANNEL_2&#160;</td><td class="fielddoc"><p>Sample state register channel 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba0a4d9c95eb541e12efa92c548faf1a9f"></a>ADC_SAMPLE_STATE_REG_CHANNEL_3&#160;</td><td class="fielddoc"><p>Sample state register channel 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba81dbc3d2420c39db3f8083f260c405a3"></a>ADC_SAMPLE_STATE_REG_CHANNEL_4&#160;</td><td class="fielddoc"><p>Sample state register channel 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baa4a4adaee8119e62baeb4dd3a086d05c"></a>ADC_SAMPLE_STATE_REG_CHANNEL_5&#160;</td><td class="fielddoc"><p>Sample state register channel 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba15fa88246edbf2eebf082fa5dd9f836c"></a>ADC_SAMPLE_STATE_REG_CHANNEL_6&#160;</td><td class="fielddoc"><p>Sample state register channel 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bae91fb230a08219d885ec2b9cca6e6555"></a>ADC_SAMPLE_STATE_REG_CHANNEL_7&#160;</td><td class="fielddoc"><p>Sample state register channel 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baab26f8f60f4138c46361c7e2f8da4d24"></a>ADC_SAMPLE_STATE_REG_CHANNEL_8&#160;</td><td class="fielddoc"><p>Sample state register channel 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bab903533b180a914b644a3057e9141a7a"></a>ADC_SAMPLE_STATE_REG_CHANNEL_9&#160;</td><td class="fielddoc"><p>Sample state register channel 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba97689a88f60ddafbeee6c7e5ee849d27"></a>ADC_SAMPLE_STATE_REG_CHANNEL_10&#160;</td><td class="fielddoc"><p>Sample state register channel 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba3d8353b474c659dec20f8cb273f171bf"></a>ADC_SAMPLE_STATE_REG_CHANNEL_11&#160;</td><td class="fielddoc"><p>Sample state register channel 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba222bb717ccd4ffbd16ab5394d12b529b"></a>ADC_SAMPLE_STATE_REG_CHANNEL_12&#160;</td><td class="fielddoc"><p>Sample state register channel 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3bab270132ba52acc9818dc4713aaf3c011"></a>ADC_SAMPLE_STATE_REG_CHANNEL_13&#160;</td><td class="fielddoc"><p>Sample state register channel 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3ba363ef989e5099957df96c6dbd077b618"></a>ADC_SAMPLE_STATE_REG_CHANNEL_14&#160;</td><td class="fielddoc"><p>Sample state register channel 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3babb07e48ee601912e22558cbd4246c4ce"></a>ADC_SAMPLE_STATE_REG_CHANNEL_15&#160;</td><td class="fielddoc"><p>Sample state register channel 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2817e17c728f9a2b041b54fd92244c3baff392de5f4360366983bf2a253fd4684"></a>ADC_SAMPLE_STATE_REG_CHANNEL_16_TO_31&#160;</td><td class="fielddoc"><p>Sample state register channel 16 to 31. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5d55db8f35fe6d81d9ed2189e6915259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d55db8f35fe6d81d9ed2189e6915259">&#9670;&nbsp;</a></span>adc_compare_cfg_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga5d55db8f35fe6d81d9ed2189e6915259">adc_compare_cfg_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC comparison settings </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5d55db8f35fe6d81d9ed2189e6915259a02d9f87ff15e67d4f6cc19bb027a2826"></a>ADC_COMPARE_CFG_EVENT_OUTPUT_OR&#160;</td><td class="fielddoc"><p>Compound condition OR setting. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d55db8f35fe6d81d9ed2189e6915259a0559afe6232d4c1a60271e5bd86d7ce7"></a>ADC_COMPARE_CFG_EVENT_OUTPUT_XOR&#160;</td><td class="fielddoc"><p>Compound condition XOR setting. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5d55db8f35fe6d81d9ed2189e6915259a75da70c47c1a446819748c2f08e89b60"></a>ADC_COMPARE_CFG_EVENT_OUTPUT_AND&#160;</td><td class="fielddoc"><p>Compound condition AND setting. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf6b1491f26c341e3a6507881969bdad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b1491f26c341e3a6507881969bdad3">&#9670;&nbsp;</a></span>adc_window_b_channel_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gaf6b1491f26c341e3a6507881969bdad3">adc_window_b_channel_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC Window B channel </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a8f4fdff7c986f1f4721974cf2ab82e6b"></a>ADC_WINDOW_B_CHANNEL_0&#160;</td><td class="fielddoc"><p>Window B channel 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a767a0e14bd2712c181abed5447aa9e37"></a>ADC_WINDOW_B_CHANNEL_1&#160;</td><td class="fielddoc"><p>Window B channel 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a61e48f57bac5198cffcf68debbc15e40"></a>ADC_WINDOW_B_CHANNEL_2&#160;</td><td class="fielddoc"><p>Window B channel 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a93e2dc29d5d2b595d5cb4ec1c2515aa9"></a>ADC_WINDOW_B_CHANNEL_3&#160;</td><td class="fielddoc"><p>Window B channel 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a1adca53f356eb4e3e06b5f6ad900d619"></a>ADC_WINDOW_B_CHANNEL_4&#160;</td><td class="fielddoc"><p>Window B channel 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a1ed718d6a5b97908ba212a4e3cf0c180"></a>ADC_WINDOW_B_CHANNEL_5&#160;</td><td class="fielddoc"><p>Window B channel 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a220acdf94b25966827569d09d989dfa4"></a>ADC_WINDOW_B_CHANNEL_6&#160;</td><td class="fielddoc"><p>Window B channel 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a723cc0f0d58b3fa13483feffb84a3c87"></a>ADC_WINDOW_B_CHANNEL_7&#160;</td><td class="fielddoc"><p>Window B channel 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3ac9eff67581c3c4a5bd7b7ac5bf5ae85e"></a>ADC_WINDOW_B_CHANNEL_8&#160;</td><td class="fielddoc"><p>Window B channel 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a7b86bab08a4b481cd3050ebd1ff65bbc"></a>ADC_WINDOW_B_CHANNEL_9&#160;</td><td class="fielddoc"><p>Window B channel 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a035a9de51c3e95bb6044880e9573cb54"></a>ADC_WINDOW_B_CHANNEL_10&#160;</td><td class="fielddoc"><p>Window B channel 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a613a92439db723183fb742c1a5b011d5"></a>ADC_WINDOW_B_CHANNEL_11&#160;</td><td class="fielddoc"><p>Window B channel 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3ae0da5f50766c0522e37a8fe515984a2a"></a>ADC_WINDOW_B_CHANNEL_12&#160;</td><td class="fielddoc"><p>Window B channel 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a61af59fb34e8b44768d630e824c3cc1c"></a>ADC_WINDOW_B_CHANNEL_13&#160;</td><td class="fielddoc"><p>Window B channel 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3adb66aacf179c977977d60842dcc495fd"></a>ADC_WINDOW_B_CHANNEL_14&#160;</td><td class="fielddoc"><p>Window B channel 14. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3a8ca6128339cea0546d98107aac104f56"></a>ADC_WINDOW_B_CHANNEL_15&#160;</td><td class="fielddoc"><p>Window B channel 15. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf6b1491f26c341e3a6507881969bdad3aefff52854eb8bd5e5e0ed679d922290d"></a>ADC_WINDOW_B_CHANNEL_NONE&#160;</td><td class="fielddoc"><p>No channel is selected. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0d0c470ca46c2801d243c06f03916e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d0c470ca46c2801d243c06f03916e67">&#9670;&nbsp;</a></span>adc_window_b_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga0d0c470ca46c2801d243c06f03916e67">adc_window_b_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC Window B comparison mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0d0c470ca46c2801d243c06f03916e67a9c18cac37a1497a88d9e891fd3b0fe90"></a>ADC_WINDOW_B_MODE_LESS_THAN_OR_OUTSIDE&#160;</td><td class="fielddoc"><p>Window B comparison condition is less than or outside. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga79014196d08d86b161b77892bf26b100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79014196d08d86b161b77892bf26b100">&#9670;&nbsp;</a></span>adc_group_a_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga79014196d08d86b161b77892bf26b100">adc_group_a_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC action for group A interrupts group B scan. This enumeration is used to specify the priority between Group A and B in group mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a356a40c69cc74ea30a461d7dd3e4d55e"></a>ADC_GROUP_A_PRIORITY_OFF&#160;</td><td class="fielddoc"><p>Group A ignored and does not interrupt ongoing group B scan. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100aad6bf6c403c26b6891f27a40d65359c9"></a>ADC_GROUP_A_GROUP_B_WAIT_FOR_TRIGGER&#160;</td><td class="fielddoc"><p>Group A interrupts Group B(single scan) which restarts at next Group B trigger. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a008539c98b123b9a7db52e3bf8ebc631"></a>ADC_GROUP_A_GROUP_B_RESTART_SCAN&#160;</td><td class="fielddoc"><p>Group A interrupts Group B(single scan) which restarts immediately after Group A scan is complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a8b7bf2cb86043bcba54fc36aa69fb964"></a>ADC_GROUP_A_GROUP_B_RESUME_SCAN&#160;</td><td class="fielddoc"><p>Resume scanning of interrupted channels. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79014196d08d86b161b77892bf26b100a555241a868ee8b93557c4358c21caea0"></a>ADC_GROUP_A_GROUP_B_CONTINUOUS_SCAN&#160;</td><td class="fielddoc"><p>Group A interrupts Group B(continuous scan) which continues scanning without a new Group B trigger. </p>
</td></tr>
</table>

</div>
</div>
<a id="gac8dbc21689111fadfff9dd51d612eb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8dbc21689111fadfff9dd51d612eb8e">&#9670;&nbsp;</a></span>adc_active_trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#gac8dbc21689111fadfff9dd51d612eb8e">adc_active_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the registers settings for the ADC trigger. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea639d721bf23a73a57e867c8ae409bc87"></a>ADC_ACTIVE_TRIGGER_EXTERNAL&#160;</td><td class="fielddoc"><p>Input pin for the trigger. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8eaa3b9b543c65de40b6f9af687bc3dc636"></a>ADC_ACTIVE_TRIGGER_TRGA1N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU1.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea53eef8387f5dbe08b91e7d8cd4b7ff9f"></a>ADC_ACTIVE_TRIGGER_TRGA2N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU2.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8eaad1a7a531c63df64fb961448e08dab79"></a>ADC_ACTIVE_TRIGGER_TRGA3N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU3.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8eaa80d2cea86da409dff59ed0d33fdc955"></a>ADC_ACTIVE_TRIGGER_TRGA0N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU0.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea6ef5b4c98cbefd00d5b3bd83b6019cf8"></a>ADC_ACTIVE_TRIGGER_TRGA4N&#160;</td><td class="fielddoc"><p>Compare match with or input capture to MTU4.TGRA, or an underflow of MTU4.TCNT (in the trough) in complementary PWM mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8eaf66ff215625beeb2a3d6c60118deb257"></a>ADC_ACTIVE_TRIGGER_TRGA6N&#160;</td><td class="fielddoc"><p>Compare match with MTU6.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea45b4b3bb239ef67ab57574608d483d4d"></a>ADC_ACTIVE_TRIGGER_TRGA7N&#160;</td><td class="fielddoc"><p>Compare match with MTU7.TGRA. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea4e41710638d7396d38008a6451da41fa"></a>ADC_ACTIVE_TRIGGER_TRG0N&#160;</td><td class="fielddoc"><p>Compare match with MTU0.TGRE. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea631d5867d1e6f5216ecfa296bd2d7c01"></a>ADC_ACTIVE_TRIGGER_TRG4AN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORA and MTU4.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea49e9f40bfeba99a0623df45bfd73ee74"></a>ADC_ACTIVE_TRIGGER_TRG4BN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORB and MTU4.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea32518ec637d6db371d9767494e2129d2"></a>ADC_ACTIVE_TRIGGER_TRG4AN_BN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORA and MTU4.TCNT, or between MTU4.TADCORB and MTU4.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea8ef7342b9dfe4dbc59c24e288899adf0"></a>ADC_ACTIVE_TRIGGER_TRG4ABN&#160;</td><td class="fielddoc"><p>Compare match between MTU4.TADCORA and MTU4.TCNT, and between MTU4.TADCORB and MTU4.TCNT (when interrupt skipping function 2 is in use) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea89c1fc921f26098de8b2aa3b24668340"></a>ADC_ACTIVE_TRIGGER_TRG7AN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORA and MTU7.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8eaa1c821e8d25268f3d5a2300deba6bf76"></a>ADC_ACTIVE_TRIGGER_TRG7BN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORB and MTU7.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ead52c8bc1c017dcfabae1ee746ae13076"></a>ADC_ACTIVE_TRIGGER_TRG7AN_BN&#160;</td><td class="fielddoc"><p>Compare match between MTU7.TADCORA and MTU7.TCNT, or between MTU7.TADCORB and MTU7.TCNT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea9c4373972e9eb38b33e3aeda52906c79"></a>ADC_ACTIVE_TRIGGER_TRG7ABN&#160;</td><td class="fielddoc"><p>(when interrupt skipping function 2 is in use) </p>
<p>Compare match between MTU7.TADCORA and MTU7.TCNT, and between MTU7.TADCORB and MTU7.TCNT </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea7d19992a7017e8aa96935a1d3328edec"></a>ADC_ACTIVE_TRIGGER_ELC_TRIGGER&#160;</td><td class="fielddoc"><p>A/D Startup source A from ELC. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8ea0a66d38ba607481b4c7e0ff7fbe8727a"></a>ADC_ACTIVE_TRIGGER_ELC_TRIGGER_GROUP_B&#160;</td><td class="fielddoc"><p>A/D Startup source B from ELC. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8dbc21689111fadfff9dd51d612eb8eac4376574620777c8c80a0f1d5b3af3ef"></a>ADC_ACTIVE_TRIGGER_DISABLED&#160;</td><td class="fielddoc"><p>A/D Start trigger disabled. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga802c536966b5905a58039e347c5dbbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802c536966b5905a58039e347c5dbbc5">&#9670;&nbsp;</a></span>adc_double_trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga802c536966b5905a58039e347c5dbbc5">adc_double_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC double-trigger mode definitions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga802c536966b5905a58039e347c5dbbc5a5bba4c6110fce02531f6f7822604ed08"></a>ADC_DOUBLE_TRIGGER_DISABLED&#160;</td><td class="fielddoc"><p>Double-triggering disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802c536966b5905a58039e347c5dbbc5a0c5f35117003eac5370c768e56f160a1"></a>ADC_DOUBLE_TRIGGER_ENABLED&#160;</td><td class="fielddoc"><p>Double-triggering enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga802c536966b5905a58039e347c5dbbc5a67e6c1666364c908d8ceb504b4ccf15f"></a>ADC_DOUBLE_TRIGGER_ENABLED_EXTENDED&#160;</td><td class="fielddoc"><p>Double-triggering enabled on both ADC ELC events. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga42fdf34706dd9fc70b44d89d5a7fec8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42fdf34706dd9fc70b44d89d5a7fec8f">&#9670;&nbsp;</a></span>adc_elc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_d_c.html#ga42fdf34706dd9fc70b44d89d5a7fec8f">adc_elc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AD event link control definitions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga42fdf34706dd9fc70b44d89d5a7fec8fa889f553719d7a6acf1b0aa6fd3f71b0f"></a>ADC_ELC_SINGLE_SCAN&#160;</td><td class="fielddoc"><p>At the end of a single scan GCELC = 0b, ELCC[1:0] = 00b. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga42fdf34706dd9fc70b44d89d5a7fec8facd08e0c69fb8f099dff57abcad0b78ba"></a>ADC_ELC_CONTINUOUS_SCAN&#160;</td><td class="fielddoc"><p>At the end of a contiuous scan GCELC = 0b, ELCC[1:0] = 00b. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga42fdf34706dd9fc70b44d89d5a7fec8fa4164d8624f4b6b57b858cb708eeb7e9b"></a>ADC_ELC_GROUP_A_SCAN&#160;</td><td class="fielddoc"><p>At the end of a group_a scan GCELC = 0b, ELCC[1:0] = 00b. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga42fdf34706dd9fc70b44d89d5a7fec8fa9829f1e81e9fd42993f818ad04bcca1c"></a>ADC_ELC_GROUP_B_SCAN&#160;</td><td class="fielddoc"><p>At the end of a group_b scan GCELC = 0b, ELCC[1:0] = 01b. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga42fdf34706dd9fc70b44d89d5a7fec8faad9f598546bfcfc520a7a953cf426182"></a>ADC_ELC_GROUP_A_B_C_SCAN&#160;</td><td class="fielddoc"><p>At the end of a group_abc scan GCELC = 0b, ELCC[1:0] = 1xb. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga42fdf34706dd9fc70b44d89d5a7fec8fad76dfc1d43656eb16df24fd937d300c3"></a>ADC_ELC_GROUP_C_SCAN&#160;</td><td class="fielddoc"><p>At the end of a group_c scan GCELC = 1b, ELCC[1:0] = 00b. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gade895e0810cecb3be6a9e5217f5c78ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade895e0810cecb3be6a9e5217f5c78ac">&#9670;&nbsp;</a></span>R_ADC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the operational mode, trigger sources, interrupt priority, and configurations for the peripheral as a whole. If interrupt is enabled, the function registers a callback function pointer for notifying the user whenever a scan has completed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is ready for use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The instance control structure has already been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A callback is provided, but the interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The requested unit does not exist on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>The ADC clock must be at least 1 MHz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga994514574730e0701dc1a6ad41889f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994514574730e0701dc1a6ad41889f88">&#9670;&nbsp;</a></span>R_ADC_ScanCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_channel_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the ADC scan parameters. Channel specific settings are set in this function. Pass a pointer to <a class="el" href="group___a_d_c.html#structadc__channel__cfg__t">adc_channel_cfg_t</a> to p_channel_cfg.</p>
<dl class="section note"><dt>Note</dt><dd>This starts group B scans if <a class="el" href="group___a_d_c.html#aef59542e008313144646bd057d840c8a" title="Valid for group modes. ">adc_channel_cfg_t::priority_group_a</a> is set to ADC_GROUP_A_GROUP_B_CONTINUOUS_SCAN.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel specific settings applied. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">&#9670;&nbsp;</a></span>R_ADC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_adc_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the lowest number configured channel and the total number of bytes to be read in order to read the results of the configured channels and return the ELC Event name. If no channels are configured, then a length of 0 is returned.</p>
<dl class="section note"><dt>Note</dt><dd>In group mode, information is returned for group A only. Calculating information for group B is not currently supported.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a7fb2265b5a03c7586253ff28b3faf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a7fb2265b5a03c7586253ff28b3faf2">&#9670;&nbsp;</a></span>R_ADC_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a software scan or enables the hardware trigger for a scan depending on how the triggers were configured in the R_ADC_Open call. If the unit was configured for ELC or external hardware triggering, then this function allows the trigger signal to get to the ADC unit. The function is not able to control the generation of the trigger itself. If the unit was configured for software triggering, then this function starts the software triggered scan.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Call R_ADC_ScanCfg after R_ADC_Open before starting a scan.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan started (software trigger) or hardware triggers enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Another scan is still in progress (software trigger). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12d4b4406ff0aa0c7ae8f068432a72f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12d4b4406ff0aa0c7ae8f068432a72f5">&#9670;&nbsp;</a></span>R_ADC_ScanGroupStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanGroupStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaee17c30275c1c9376cc485a62ea121eb">adc_group_mask_t</a>&#160;</td>
          <td class="paramname"><em>group_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#aeae126b8a09e1ec34e8e3afb4a3344ff">adc_api_t::scanGroupStart</a> is not supported on the ADC. Use scanStart instead.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b5242c153c6320a564ed9ffd324f144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5242c153c6320a564ed9ffd324f144">&#9670;&nbsp;</a></span>R_ADC_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the software scan or disables the unit from being triggered by the hardware trigger (ELC or external) based on what type of trigger the unit was configured for in the R_ADC_Open function. Stopping a hardware triggered scan via this function does not abort an ongoing scan, but prevents the next scan from occurring. Stopping a software triggered scan aborts an ongoing scan.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan stopped (software trigger) or hardware triggers disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga676b1c7f1ccceda288cbb2ad79a14ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga676b1c7f1ccceda288cbb2ad79a14ff2">&#9670;&nbsp;</a></span>R_ADC_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the status of any scan process that was started, including scans started by ELC or external triggers.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module status stored in the provided pointer p_status </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6bfc8395b53a96ee89f266fc940e2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6bfc8395b53a96ee89f266fc940e2da">&#9670;&nbsp;</a></span>R_ADC_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga905e1cd6ff8ca4aaf91ee63529dc0d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga905e1cd6ff8ca4aaf91ee63529dc0d0d">&#9670;&nbsp;</a></span>R_ADC_Read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Read32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor register into a 32-bit result.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0701bf45818dee071cb12e979017bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0701bf45818dee071cb12e979017bce">&#9670;&nbsp;</a></span>R_ADC_SampleStateCountSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_SampleStateCountSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c.html#structadc__sample__state__t">adc_sample_state_t</a> *&#160;</td>
          <td class="paramname"><em>p_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sample state count for individual channels. This only needs to be set for special use cases. Normally, use the default values out of reset.</p>
<dl class="section note"><dt>Note</dt><dd>The sample states for the temperature and voltage sensor are set in R_ADC_ScanCfg.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Sample state count updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_INITIALIZED</td><td>Unit is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga499187b3067534e42a57239ead111797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499187b3067534e42a57239ead111797">&#9670;&nbsp;</a></span>R_ADC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function ends any scan in progress, disables interrupts, and removes power to the A/D peripheral.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3bc65f19ba61612e0b7517dfd41ab61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3bc65f19ba61612e0b7517dfd41ab61">&#9670;&nbsp;</a></span>R_ADC_OffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_OffsetSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet</a> is not supported on the ADC.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac73578543d084faf58d17474dbaad23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac73578543d084faf58d17474dbaad23a">&#9670;&nbsp;</a></span>R_ADC_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c.html#gac73578543d084faf58d17474dbaad23a">adc_api_t::R_ADC_Calibrate</a> is not supported on the ADC.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b7b4813962829f9e25731cd88f4c708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b7b4813962829f9e25731cd88f4c708">&#9670;&nbsp;</a></span>R_ADC_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__callback__args__t">adc_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___a_d_c___a_p_i.html#a2cd8e8911dcf8c4c617fe62f185b4363">adc_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.0.0 User's Manual Copyright  (2025) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
